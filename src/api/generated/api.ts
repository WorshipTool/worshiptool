/* tslint:disable */
/* eslint-disable */
/**
 * WorshipTool API
 * API for WorshipTool app
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig as RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddFavouriteInDto
 */
export interface AddFavouriteInDto {
    /**
     * 
     * @type {string}
     * @memberof AddFavouriteInDto
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface AddFileToParseQueueOutDto
 */
export interface AddFileToParseQueueOutDto {
    /**
     * 
     * @type {string}
     * @memberof AddFileToParseQueueOutDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AddMediaToPackInDto
 */
export interface AddMediaToPackInDto {
    /**
     * 
     * @type {string}
     * @memberof AddMediaToPackInDto
     */
    'mediaUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AddMediaToPackInDto
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface AddNoteToVariantInDto
 */
export interface AddNoteToVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof AddNoteToVariantInDto
     */
    'content': string;
    /**
     * 
     * @type {object}
     * @memberof AddNoteToVariantInDto
     */
    'packGuid': object;
}
/**
 * 
 * @export
 * @interface AddPackToTeamSelectionInDto
 */
export interface AddPackToTeamSelectionInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPackToTeamSelectionInDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPackToTeamSelectionInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface AddPermissionToGroupInDto
 */
export interface AddPermissionToGroupInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToGroupInDto
     */
    'groupGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToGroupInDto
     */
    'permissionGuid': string;
}
/**
 * 
 * @export
 * @interface AddPermissionToUserInDto
 */
export interface AddPermissionToUserInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'permissionGuid': string;
}
/**
 * 
 * @export
 * @interface AddTeamMebmerByEmailInDto
 */
export interface AddTeamMebmerByEmailInDto {
    /**
     * 
     * @type {string}
     * @memberof AddTeamMebmerByEmailInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AddTeamMebmerByEmailInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface AddTeamNoteToVariantInDto
 */
export interface AddTeamNoteToVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof AddTeamNoteToVariantInDto
     */
    'content': string;
    /**
     * 
     * @type {object}
     * @memberof AddTeamNoteToVariantInDto
     */
    'packGuid': object;
    /**
     * 
     * @type {string}
     * @memberof AddTeamNoteToVariantInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface AddUserLikeToTranslationInDto
 */
export interface AddUserLikeToTranslationInDto {
    /**
     * 
     * @type {string}
     * @memberof AddUserLikeToTranslationInDto
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface AddVariantToPlaylistInDto
 */
export interface AddVariantToPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'playlist': string;
}
/**
 * 
 * @export
 * @interface AllTeamNoteData
 */
export interface AllTeamNoteData {
    /**
     * 
     * @type {string}
     * @memberof AllTeamNoteData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof AllTeamNoteData
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof AllTeamNoteData
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface AllTeamSubdomainAlias
 */
export interface AllTeamSubdomainAlias {
    /**
     * 
     * @type {string}
     * @memberof AllTeamSubdomainAlias
     */
    'teamAlias': string;
    /**
     * 
     * @type {string}
     * @memberof AllTeamSubdomainAlias
     */
    'subdomain': string;
}
/**
 * 
 * @export
 * @interface AttachPlaylistToTeamInDto
 */
export interface AttachPlaylistToTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof AttachPlaylistToTeamInDto
     */
    'playlistGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AttachPlaylistToTeamInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface BaseUserInfoOutDto
 */
export interface BaseUserInfoOutDto {
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof BaseUserInfoOutDto
     */
    'role': BaseUserInfoOutDtoRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'pictureGuid': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof BaseUserInfoOutDto
     */
    'loginMethods': Array<BaseUserInfoOutDtoLoginMethodsEnum>;
}

export const BaseUserInfoOutDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type BaseUserInfoOutDtoRoleEnum = typeof BaseUserInfoOutDtoRoleEnum[keyof typeof BaseUserInfoOutDtoRoleEnum];
export const BaseUserInfoOutDtoLoginMethodsEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseUserInfoOutDtoLoginMethodsEnum = typeof BaseUserInfoOutDtoLoginMethodsEnum[keyof typeof BaseUserInfoOutDtoLoginMethodsEnum];

/**
 * 
 * @export
 * @interface BasicSongDto
 */
export interface BasicSongDto {
    /**
     * 
     * @type {object}
     * @memberof BasicSongDto
     */
    'guid': object;
    /**
     * 
     * @type {string}
     * @memberof BasicSongDto
     */
    'title': string;
    /**
     * 
     * @type {BasicVariantPackDto}
     * @memberof BasicSongDto
     */
    'original'?: BasicVariantPackDto;
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof BasicSongDto
     */
    'packs': Array<BasicVariantPackDto>;
}
/**
 * 
 * @export
 * @interface BasicVariantPackDto
 */
export interface BasicVariantPackDto {
    /**
     * 
     * @type {object}
     * @memberof BasicVariantPackDto
     */
    'packGuid': object;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'packAlias': string;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof BasicVariantPackDto
     */
    'songGuid': object;
    /**
     * 
     * @type {boolean}
     * @memberof BasicVariantPackDto
     */
    'public': boolean;
    /**
     * 
     * @type {number}
     * @memberof BasicVariantPackDto
     */
    'publishApprovalStatus': BasicVariantPackDtoPublishApprovalStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'publishedAt': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BasicVariantPackDto
     */
    'verified': boolean;
    /**
     * 
     * @type {number}
     * @memberof BasicVariantPackDto
     */
    'translationType': BasicVariantPackDtoTranslationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BasicVariantPackDto
     */
    'translationLikes': number;
    /**
     * 
     * @type {object}
     * @memberof BasicVariantPackDto
     */
    'language': object;
    /**
     * 
     * @type {boolean}
     * @memberof BasicVariantPackDto
     */
    'ggValidated': boolean;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof BasicVariantPackDto
     */
    'createdByGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof BasicVariantPackDto
     */
    'createdByLoader': boolean;
}

export const BasicVariantPackDtoPublishApprovalStatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type BasicVariantPackDtoPublishApprovalStatusEnum = typeof BasicVariantPackDtoPublishApprovalStatusEnum[keyof typeof BasicVariantPackDtoPublishApprovalStatusEnum];
export const BasicVariantPackDtoTranslationTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type BasicVariantPackDtoTranslationTypeEnum = typeof BasicVariantPackDtoTranslationTypeEnum[keyof typeof BasicVariantPackDtoTranslationTypeEnum];

/**
 * 
 * @export
 * @interface CSVLink
 */
export interface CSVLink {
    /**
     * 
     * @type {string}
     * @memberof CSVLink
     */
    'guid': string;
    /**
     * 
     * @type {Creator}
     * @memberof CSVLink
     */
    'creator': Creator;
    /**
     * 
     * @type {number}
     * @memberof CSVLink
     */
    'type': CSVLinkTypeEnum;
    /**
     * 
     * @type {SongVariant}
     * @memberof CSVLink
     */
    'variant': SongVariant;
}

export const CSVLinkTypeEnum = {
    NUMBER_0: 0
} as const;

export type CSVLinkTypeEnum = typeof CSVLinkTypeEnum[keyof typeof CSVLinkTypeEnum];

/**
 * 
 * @export
 * @interface ChangePasswordInDto
 */
export interface ChangePasswordInDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordInDto
     */
    'oldPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordInDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface ChangeProfilePhotoInDto
 */
export interface ChangeProfilePhotoInDto {
    /**
     * 
     * @type {string}
     * @memberof ChangeProfilePhotoInDto
     */
    'pictureGuid': string;
}
/**
 * 
 * @export
 * @interface ChangeTeamInfoInDto
 */
export interface ChangeTeamInfoInDto {
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamInfoInDto
     */
    'teamGuid': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamInfoInDto
     */
    'teamName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamInfoInDto
     */
    'joinCode'?: string;
}
/**
 * 
 * @export
 * @interface ChangeUserNameInDto
 */
export interface ChangeUserNameInDto {
    /**
     * 
     * @type {string}
     * @memberof ChangeUserNameInDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeUserNameInDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface CreateTeamEventInDto
 */
export interface CreateTeamEventInDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamEventInDto
     */
    'teamGuid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamEventInDto
     */
    'leaderUserGuid': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTeamEventInDto
     */
    'memberUserGuids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamEventInDto
     */
    'eventTitle': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamEventInDto
     */
    'eventDescription': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamEventInDto
     */
    'playlistGuid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamEventInDto
     */
    'eventDate': string;
}
/**
 * 
 * @export
 * @interface CreateTeamInDto
 */
export interface CreateTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamInDto
     */
    'teamName': string;
}
/**
 * 
 * @export
 * @interface CreateTeamOutDto
 */
export interface CreateTeamOutDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface Creator
 */
export interface Creator {
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'name': string;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof Creator
     */
    'links': Array<CSVLink>;
}
/**
 * 
 * @export
 * @interface CreatorDTO
 */
export interface CreatorDTO {
    /**
     * 
     * @type {string}
     * @memberof CreatorDTO
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreatorDTO
     */
    'type': CreatorDTOTypeEnum;
}

export const CreatorDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type CreatorDTOTypeEnum = typeof CreatorDTOTypeEnum[keyof typeof CreatorDTOTypeEnum];

/**
 * 
 * @export
 * @interface DeleteNoteInDto
 */
export interface DeleteNoteInDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteNoteInDto
     */
    'noteGuid': string;
}
/**
 * 
 * @export
 * @interface DeleteTeamInDto
 */
export interface DeleteTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteTeamInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface DeleteTeamNoteInDto
 */
export interface DeleteTeamNoteInDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteTeamNoteInDto
     */
    'noteGuid': string;
}
/**
 * 
 * @export
 * @interface EditItemInDto
 */
export interface EditItemInDto {
    /**
     * 
     * @type {string}
     * @memberof EditItemInDto
     */
    'itemGuid': string;
    /**
     * 
     * @type {string}
     * @memberof EditItemInDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditItemInDto
     */
    'sheetData'?: string;
}
/**
 * 
 * @export
 * @interface EditPayloadInDto
 */
export interface EditPayloadInDto {
    /**
     * 
     * @type {string}
     * @memberof EditPayloadInDto
     */
    'teamGuid': string;
    /**
     * 
     * @type {string}
     * @memberof EditPayloadInDto
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface EditTeamEventInDto
 */
export interface EditTeamEventInDto {
    /**
     * 
     * @type {string}
     * @memberof EditTeamEventInDto
     */
    'eventGuid': string;
    /**
     * 
     * @type {string}
     * @memberof EditTeamEventInDto
     */
    'eventTitle': string;
    /**
     * 
     * @type {string}
     * @memberof EditTeamEventInDto
     */
    'eventDescription': string;
    /**
     * 
     * @type {string}
     * @memberof EditTeamEventInDto
     */
    'eventDate': string;
    /**
     * 
     * @type {string}
     * @memberof EditTeamEventInDto
     */
    'playlistGuid': string;
    /**
     * 
     * @type {string}
     * @memberof EditTeamEventInDto
     */
    'leaderUserGuid': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditTeamEventInDto
     */
    'memberUserGuids': Array<string>;
}
/**
 * 
 * @export
 * @interface EditVariantOutDto
 */
export interface EditVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof EditVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof EditVariantOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface ExtendedVariantPackDto
 */
export interface ExtendedVariantPackDto {
    /**
     * 
     * @type {object}
     * @memberof ExtendedVariantPackDto
     */
    'packGuid': object;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'packAlias': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof ExtendedVariantPackDto
     */
    'songGuid': object;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedVariantPackDto
     */
    'public': boolean;
    /**
     * 
     * @type {number}
     * @memberof ExtendedVariantPackDto
     */
    'publishApprovalStatus': ExtendedVariantPackDtoPublishApprovalStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'publishedAt': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedVariantPackDto
     */
    'verified': boolean;
    /**
     * 
     * @type {number}
     * @memberof ExtendedVariantPackDto
     */
    'translationType': ExtendedVariantPackDtoTranslationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ExtendedVariantPackDto
     */
    'translationLikes': number;
    /**
     * 
     * @type {object}
     * @memberof ExtendedVariantPackDto
     */
    'language': object;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedVariantPackDto
     */
    'ggValidated': boolean;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedVariantPackDto
     */
    'createdByGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedVariantPackDto
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedVariantPackDto
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedVariantPackDto
     */
    'inFormat': boolean;
    /**
     * 
     * @type {number}
     * @memberof ExtendedVariantPackDto
     */
    'createdType': ExtendedVariantPackDtoCreatedTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof ExtendedVariantPackDto
     */
    'createdForPlaylistGuid': object | null;
    /**
     * 
     * @type {Array<SourceDTO>}
     * @memberof ExtendedVariantPackDto
     */
    'sources': Array<SourceDTO>;
}

export const ExtendedVariantPackDtoPublishApprovalStatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type ExtendedVariantPackDtoPublishApprovalStatusEnum = typeof ExtendedVariantPackDtoPublishApprovalStatusEnum[keyof typeof ExtendedVariantPackDtoPublishApprovalStatusEnum];
export const ExtendedVariantPackDtoTranslationTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type ExtendedVariantPackDtoTranslationTypeEnum = typeof ExtendedVariantPackDtoTranslationTypeEnum[keyof typeof ExtendedVariantPackDtoTranslationTypeEnum];
export const ExtendedVariantPackDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type ExtendedVariantPackDtoCreatedTypeEnum = typeof ExtendedVariantPackDtoCreatedTypeEnum[keyof typeof ExtendedVariantPackDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface GetAllTeamNotesOutDto
 */
export interface GetAllTeamNotesOutDto {
    /**
     * 
     * @type {Array<AllTeamNoteData>}
     * @memberof GetAllTeamNotesOutDto
     */
    'notes': Array<AllTeamNoteData>;
}
/**
 * 
 * @export
 * @interface GetAllTeamSubdomainAliasesOutDto
 */
export interface GetAllTeamSubdomainAliasesOutDto {
    /**
     * 
     * @type {Array<AllTeamSubdomainAlias>}
     * @memberof GetAllTeamSubdomainAliasesOutDto
     */
    'aliases': Array<AllTeamSubdomainAlias>;
}
/**
 * 
 * @export
 * @interface GetFavouritesItemData
 */
export interface GetFavouritesItemData {
    /**
     * 
     * @type {string}
     * @memberof GetFavouritesItemData
     */
    'variantGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetFavouritesItemData
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetFavouritesItemData
     */
    'teamName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFavouritesItemData
     */
    'teamAlias'?: string;
}
/**
 * 
 * @export
 * @interface GetFavouritesOutDto
 */
export interface GetFavouritesOutDto {
    /**
     * 
     * @type {Array<GetFavouritesItemData>}
     * @memberof GetFavouritesOutDto
     */
    'items': Array<GetFavouritesItemData>;
    /**
     * 
     * @type {string}
     * @memberof GetFavouritesOutDto
     */
    'selectionGuid': string;
}
/**
 * 
 * @export
 * @interface GetGlobalSongsOutDto
 */
export interface GetGlobalSongsOutDto {
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof GetGlobalSongsOutDto
     */
    'variants': Array<BasicVariantPackDto>;
}
/**
 * 
 * @export
 * @interface GetJoinCodeOutDto
 */
export interface GetJoinCodeOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetJoinCodeOutDto
     */
    'joinCode': string;
}
/**
 * 
 * @export
 * @interface GetListSongData
 */
export interface GetListSongData {
    /**
     * 
     * @type {BasicVariantPackDto}
     * @memberof GetListSongData
     */
    'original'?: BasicVariantPackDto;
    /**
     * 
     * @type {BasicVariantPackDto}
     * @memberof GetListSongData
     */
    'main': BasicVariantPackDto;
}
/**
 * 
 * @export
 * @interface GetNotesOfVariantOutDto
 */
export interface GetNotesOfVariantOutDto {
    /**
     * 
     * @type {Array<NoteData>}
     * @memberof GetNotesOfVariantOutDto
     */
    'notes': Array<NoteData>;
}
/**
 * 
 * @export
 * @interface GetOrCreatePermissionInDto
 */
export interface GetOrCreatePermissionInDto {
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetPackAliasFromSourceUrlOutDto
 */
export interface GetPackAliasFromSourceUrlOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetPackAliasFromSourceUrlOutDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof GetPackAliasFromSourceUrlOutDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetPackAliasFromSourceUrlOutDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface GetPinnedPlaylistsToTeamOutDto
 */
export interface GetPinnedPlaylistsToTeamOutDto {
    /**
     * 
     * @type {Array<TeamPlaylistData>}
     * @memberof GetPinnedPlaylistsToTeamOutDto
     */
    'playlists': Array<TeamPlaylistData>;
}
/**
 * 
 * @export
 * @interface GetPlaylistsResult
 */
export interface GetPlaylistsResult {
    /**
     * 
     * @type {Array<PlaylistData>}
     * @memberof GetPlaylistsResult
     */
    'playlists': Array<PlaylistData>;
}
/**
 * 
 * @export
 * @interface GetRandomVariantOutDto
 */
export interface GetRandomVariantOutDto {
    /**
     * 
     * @type {BasicVariantPackDto}
     * @memberof GetRandomVariantOutDto
     */
    'variant': BasicVariantPackDto;
}
/**
 * 
 * @export
 * @interface GetRecommendedSongsOutDto
 */
export interface GetRecommendedSongsOutDto {
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof GetRecommendedSongsOutDto
     */
    'variants': Array<BasicVariantPackDto>;
}
/**
 * 
 * @export
 * @interface GetSearchInPlaylistResult
 */
export interface GetSearchInPlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof GetSearchInPlaylistResult
     */
    'guid': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof GetSearchInPlaylistResult
     */
    'items': Array<PlaylistItemOutDto>;
}
/**
 * 
 * @export
 * @interface GetSongDataOutDto
 */
export interface GetSongDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'mainTitle': string;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof GetSongDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {Array<SongDataVariant>}
     * @memberof GetSongDataOutDto
     */
    'variants': Array<SongDataVariant>;
    /**
     * 
     * @type {Array<SongDataMedia>}
     * @memberof GetSongDataOutDto
     */
    'media': Array<SongDataMedia>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSongDataOutDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetTeamAliasFromSubdomainOutDto
 */
export interface GetTeamAliasFromSubdomainOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetTeamAliasFromSubdomainOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface GetTeamEventsOutDto
 */
export interface GetTeamEventsOutDto {
    /**
     * 
     * @type {Array<TeamEventData>}
     * @memberof GetTeamEventsOutDto
     */
    'events': Array<TeamEventData>;
}
/**
 * 
 * @export
 * @interface GetTeamInfoOutDto
 */
export interface GetTeamInfoOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'selectionGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'createdByGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'joinCode': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'logoGuid': string | null;
}
/**
 * 
 * @export
 * @interface GetTeamMembersOutDto
 */
export interface GetTeamMembersOutDto {
    /**
     * 
     * @type {Array<TeamMemberDto>}
     * @memberof GetTeamMembersOutDto
     */
    'members': Array<TeamMemberDto>;
}
/**
 * 
 * @export
 * @interface GetTeamStatisticsOutDto
 */
export interface GetTeamStatisticsOutDto {
    /**
     * 
     * @type {Array<LeastPlayedSong>}
     * @memberof GetTeamStatisticsOutDto
     */
    'leastPlayedSongs': Array<LeastPlayedSong>;
    /**
     * 
     * @type {Array<LeastPlayedSong>}
     * @memberof GetTeamStatisticsOutDto
     */
    'topPlayedSongs': Array<LeastPlayedSong>;
    /**
     * 
     * @type {Array<TrendingSong>}
     * @memberof GetTeamStatisticsOutDto
     */
    'mostTrendingSongs': Array<TrendingSong>;
    /**
     * 
     * @type {Array<PlayedCountSong>}
     * @memberof GetTeamStatisticsOutDto
     */
    'playedCountSongs': Array<PlayedCountSong>;
    /**
     * 
     * @type {Array<MostFavouriteSong>}
     * @memberof GetTeamStatisticsOutDto
     */
    'mostFavouriteSongs': Array<MostFavouriteSong>;
}
/**
 * 
 * @export
 * @interface GetTeamsOfUserOutDto
 */
export interface GetTeamsOfUserOutDto {
    /**
     * 
     * @type {Array<TeamOfUserDto>}
     * @memberof GetTeamsOfUserOutDto
     */
    'teams': Array<TeamOfUserDto>;
}
/**
 * 
 * @export
 * @interface GetUserPermissionOutDto
 */
export interface GetUserPermissionOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetUserTranslationLikesOutDto
 */
export interface GetUserTranslationLikesOutDto {
    /**
     * 
     * @type {Array<TranslationLikeItemOutDto>}
     * @memberof GetUserTranslationLikesOutDto
     */
    'likes': Array<TranslationLikeItemOutDto>;
}
/**
 * 
 * @export
 * @interface GetVariantDataOutDto
 */
export interface GetVariantDataOutDto {
    /**
     * 
     * @type {object}
     * @memberof GetVariantDataOutDto
     */
    'packGuid': object;
    /**
     * 
     * @type {ExtendedVariantPackDto}
     * @memberof GetVariantDataOutDto
     */
    'main': ExtendedVariantPackDto;
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof GetVariantDataOutDto
     */
    'other': Array<BasicVariantPackDto>;
    /**
     * 
     * @type {Array<SongDataMedia>}
     * @memberof GetVariantDataOutDto
     */
    'media': Array<SongDataMedia>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetVariantDataOutDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetVariantsOfUserOutDto
 */
export interface GetVariantsOfUserOutDto {
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof GetVariantsOfUserOutDto
     */
    'variants': Array<BasicVariantPackDto>;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'guid': string;
    /**
     * 
     * @type {object}
     * @memberof Image
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'mimeType': string;
}
/**
 * 
 * @export
 * @interface IsUserMemberOfTeamOutDto
 */
export interface IsUserMemberOfTeamOutDto {
    /**
     * 
     * @type {boolean}
     * @memberof IsUserMemberOfTeamOutDto
     */
    'isMember': boolean;
}
/**
 * 
 * @export
 * @interface JoinTeamInDto
 */
export interface JoinTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof JoinTeamInDto
     */
    'joinCode': string;
}
/**
 * 
 * @export
 * @interface JoinTeamOutDto
 */
export interface JoinTeamOutDto {
    /**
     * 
     * @type {string}
     * @memberof JoinTeamOutDto
     */
    'teamAlias': string;
    /**
     * 
     * @type {boolean}
     * @memberof JoinTeamOutDto
     */
    'newMember': boolean;
}
/**
 * 
 * @export
 * @interface JwtResult
 */
export interface JwtResult {
    /**
     * 
     * @type {BaseUserInfoOutDto}
     * @memberof JwtResult
     */
    'user': BaseUserInfoOutDto;
    /**
     * 
     * @type {string}
     * @memberof JwtResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LeastPlayedSong
 */
export interface LeastPlayedSong {
    /**
     * 
     * @type {number}
     * @memberof LeastPlayedSong
     */
    'playedCount': number;
    /**
     * 
     * @type {Array<StatisticsSongData>}
     * @memberof LeastPlayedSong
     */
    'songs': Array<StatisticsSongData>;
}
/**
 * 
 * @export
 * @interface LeaveTeamInDto
 */
export interface LeaveTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof LeaveTeamInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof LeaveTeamInDto
     */
    'teamAlias': string;
}
/**
 * 
 * @export
 * @interface LoginInputData
 */
export interface LoginInputData {
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'type': MediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'url': string;
}

export const MediaTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type MediaTypeEnum = typeof MediaTypeEnum[keyof typeof MediaTypeEnum];

/**
 * 
 * @export
 * @interface MergeFamiliesInDto
 */
export interface MergeFamiliesInDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof MergeFamiliesInDto
     */
    'songGuids': Array<string>;
}
/**
 * 
 * @export
 * @interface MostFavouriteSong
 */
export interface MostFavouriteSong {
    /**
     * 
     * @type {StatisticsSongData}
     * @memberof MostFavouriteSong
     */
    'song': StatisticsSongData;
    /**
     * 
     * @type {number}
     * @memberof MostFavouriteSong
     */
    'favouriteCount': number;
}
/**
 * 
 * @export
 * @interface MovePacksToFamilyInDto
 */
export interface MovePacksToFamilyInDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof MovePacksToFamilyInDto
     */
    'packGuids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MovePacksToFamilyInDto
     */
    'targetSongGuid'?: string;
}
/**
 * 
 * @export
 * @interface NoteData
 */
export interface NoteData {
    /**
     * 
     * @type {string}
     * @memberof NoteData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof NoteData
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface ParserSongData
 */
export interface ParserSongData {
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ParserSongDataResult
 */
export interface ParserSongDataResult {
    /**
     * 
     * @type {Array<ParserSongData>}
     * @memberof ParserSongDataResult
     */
    'sheets': Array<ParserSongData>;
    /**
     * 
     * @type {boolean}
     * @memberof ParserSongDataResult
     */
    'useAi': boolean;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'payload'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Permission
     */
    'users': Array<User>;
    /**
     * 
     * @type {Array<PermissionUserGroup>}
     * @memberof Permission
     */
    'groups': Array<PermissionUserGroup>;
}
/**
 * 
 * @export
 * @interface PermissionUserBaseOutDto
 */
export interface PermissionUserBaseOutDto {
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof PermissionUserBaseOutDto
     */
    'role': PermissionUserBaseOutDtoRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'pictureGuid': string;
}

export const PermissionUserBaseOutDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type PermissionUserBaseOutDtoRoleEnum = typeof PermissionUserBaseOutDtoRoleEnum[keyof typeof PermissionUserBaseOutDtoRoleEnum];

/**
 * 
 * @export
 * @interface PermissionUserGroup
 */
export interface PermissionUserGroup {
    /**
     * 
     * @type {string}
     * @memberof PermissionUserGroup
     */
    'guid': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PermissionUserGroup
     */
    'users': Array<User>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PermissionUserGroup
     */
    'permissions': Array<Permission>;
}
/**
 * 
 * @export
 * @interface PinPlaylistToTeamInDto
 */
export interface PinPlaylistToTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof PinPlaylistToTeamInDto
     */
    'playlistGuid': string;
    /**
     * 
     * @type {string}
     * @memberof PinPlaylistToTeamInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface PlayedCountSong
 */
export interface PlayedCountSong {
    /**
     * 
     * @type {StatisticsSongData}
     * @memberof PlayedCountSong
     */
    'song': StatisticsSongData;
    /**
     * 
     * @type {number}
     * @memberof PlayedCountSong
     */
    'playedCount': number;
}
/**
 * 
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof Playlist
     */
    'items': Array<PlaylistItem>;
    /**
     * 
     * @type {User}
     * @memberof Playlist
     */
    'owner': User;
    /**
     * 
     * @type {boolean}
     * @memberof Playlist
     */
    'isSelection': boolean;
    /**
     * 
     * @type {PermissionUserGroup}
     * @memberof Playlist
     */
    'editorsPermissionGroup': PermissionUserGroup;
    /**
     * 
     * @type {Team}
     * @memberof Playlist
     */
    'belongsToTeam': Team;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'openedAt': string;
}
/**
 * 
 * @export
 * @interface PlaylistData
 */
export interface PlaylistData {
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'teamGuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'teamName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'openedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof PlaylistData
     */
    'itemsCount': number;
}
/**
 * 
 * @export
 * @interface PlaylistDataOutDto
 */
export interface PlaylistDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof PlaylistDataOutDto
     */
    'items': Array<PlaylistItemOutDto>;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'ownerGuid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'teamGuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'teamAlias'?: string;
}
/**
 * 
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {object}
     * @memberof PlaylistItem
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'order': number;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof PlaylistItem
     */
    'variantPack': SongVariantHistoryPack;
    /**
     * 
     * @type {Playlist}
     * @memberof PlaylistItem
     */
    'playlist': Playlist;
}
/**
 * 
 * @export
 * @interface PlaylistItemOutDto
 */
export interface PlaylistItemOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'toneKey': string;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItemOutDto
     */
    'order': number;
    /**
     * 
     * @type {BasicVariantPackDto}
     * @memberof PlaylistItemOutDto
     */
    'pack': BasicVariantPackDto;
}
/**
 * 
 * @export
 * @interface PostAiRequestInDto
 */
export interface PostAiRequestInDto {
    /**
     * 
     * @type {string}
     * @memberof PostAiRequestInDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PostAiRequestOutDto
 */
export interface PostAiRequestOutDto {
    /**
     * 
     * @type {string}
     * @memberof PostAiRequestOutDto
     */
    'outputString': string;
}
/**
 * 
 * @export
 * @interface PostChangeLanguageInDto
 */
export interface PostChangeLanguageInDto {
    /**
     * 
     * @type {object}
     * @memberof PostChangeLanguageInDto
     */
    'packGuid': object;
    /**
     * 
     * @type {string}
     * @memberof PostChangeLanguageInDto
     */
    'languageString'?: string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyInDto
 */
export interface PostCreateCopyInDto {
    /**
     * 
     * @type {object}
     * @memberof PostCreateCopyInDto
     */
    'packGuid': object;
}
/**
 * 
 * @export
 * @interface PostCreateCopyOutDto
 */
export interface PostCreateCopyOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateCopyOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface PostCreatePlaylistResult
 */
export interface PostCreatePlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreatePlaylistResult
     */
    'guid': string;
}
/**
 * 
 * @export
 * @interface PostCreateVariantInDto
 */
export interface PostCreateVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'sheetData': string;
    /**
     * 
     * @type {SongDataSource}
     * @memberof PostCreateVariantInDto
     */
    'source'?: SongDataSource;
    /**
     * 
     * @type {number}
     * @memberof PostCreateVariantInDto
     */
    'createdType': PostCreateVariantInDtoCreatedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'language'?: string;
}

export const PostCreateVariantInDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostCreateVariantInDtoCreatedTypeEnum = typeof PostCreateVariantInDtoCreatedTypeEnum[keyof typeof PostCreateVariantInDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface PostCreateVariantOutDto
 */
export interface PostCreateVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantOutDto
     */
    'alias': string;
    /**
     * 
     * @type {object}
     * @memberof PostCreateVariantOutDto
     */
    'packGuid': object;
}
/**
 * 
 * @export
 * @interface PostEditVariantInDto
 */
export interface PostEditVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'variantAlias': string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'sheetData'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostEditVariantInDto
     */
    'createdType': PostEditVariantInDtoCreatedTypeEnum;
}

export const PostEditVariantInDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostEditVariantInDtoCreatedTypeEnum = typeof PostEditVariantInDtoCreatedTypeEnum[keyof typeof PostEditVariantInDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface PostGetKeywordsInDto
 */
export interface PostGetKeywordsInDto {
    /**
     * 
     * @type {object}
     * @memberof PostGetKeywordsInDto
     */
    'packGuid': object;
}
/**
 * 
 * @export
 * @interface PostGoogleLoginBody
 */
export interface PostGoogleLoginBody {
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'userToken': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'picture': string;
}
/**
 * 
 * @export
 * @interface PostPublishVariantInDto
 */
export interface PostPublishVariantInDto {
    /**
     * 
     * @type {object}
     * @memberof PostPublishVariantInDto
     */
    'packGuid': object;
}
/**
 * 
 * @export
 * @interface PostSendMailFeedbackInDto
 */
export interface PostSendMailFeedbackInDto {
    /**
     * 
     * @type {string}
     * @memberof PostSendMailFeedbackInDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendMailFeedbackInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendMailFeedbackInDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostSendPackToApprovalInDto
 */
export interface PostSendPackToApprovalInDto {
    /**
     * 
     * @type {object}
     * @memberof PostSendPackToApprovalInDto
     */
    'packGuid': object;
}
/**
 * 
 * @export
 * @interface PostValidateSheetDataAndTitleInDto
 */
export interface PostValidateSheetDataAndTitleInDto {
    /**
     * 
     * @type {string}
     * @memberof PostValidateSheetDataAndTitleInDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof PostValidateSheetDataAndTitleInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PostVerifyVariantInDto
 */
export interface PostVerifyVariantInDto {
    /**
     * 
     * @type {object}
     * @memberof PostVerifyVariantInDto
     */
    'packGuid': object;
    /**
     * 
     * @type {boolean}
     * @memberof PostVerifyVariantInDto
     */
    'verify': boolean | null;
}
/**
 * 
 * @export
 * @interface ProgramSongData
 */
export interface ProgramSongData {
    /**
     * 
     * @type {number}
     * @memberof ProgramSongData
     */
    'confidence': number;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof ProgramSongData
     */
    'createdType': ProgramSongDataCreatedTypeEnum;
}

export const ProgramSongDataCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type ProgramSongDataCreatedTypeEnum = typeof ProgramSongDataCreatedTypeEnum[keyof typeof ProgramSongDataCreatedTypeEnum];

/**
 * 
 * @export
 * @interface RemoveFavouriteInDto
 */
export interface RemoveFavouriteInDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveFavouriteInDto
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface RemoveMediaToPackInDto
 */
export interface RemoveMediaToPackInDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveMediaToPackInDto
     */
    'mediaGuid': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveMediaToPackInDto
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface RemoveTeamLogoInDto
 */
export interface RemoveTeamLogoInDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveTeamLogoInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface RenamePlaylistInDto
 */
export interface RenamePlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistInDto
 */
export interface ReorderPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {Array<ReorderPlaylistItem>}
     * @memberof ReorderPlaylistInDto
     */
    'items': Array<ReorderPlaylistItem>;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistItem
 */
export interface ReorderPlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof ReorderPlaylistItem
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface RequireItemEditInDto
 */
export interface RequireItemEditInDto {
    /**
     * 
     * @type {string}
     * @memberof RequireItemEditInDto
     */
    'itemGuid': string;
}
/**
 * 
 * @export
 * @interface RequireItemEditOutDto
 */
export interface RequireItemEditOutDto {
    /**
     * 
     * @type {boolean}
     * @memberof RequireItemEditOutDto
     */
    'createdCopy': boolean;
    /**
     * 
     * @type {string}
     * @memberof RequireItemEditOutDto
     */
    'packAlias': string;
}
/**
 * 
 * @export
 * @interface ResetPasswordInDto
 */
export interface ResetPasswordInDto {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordInDto
     */
    'newPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordInDto
     */
    'resetToken': string;
}
/**
 * 
 * @export
 * @interface SearchSongPacksDto
 */
export interface SearchSongPacksDto {
    /**
     * 
     * @type {BasicVariantPackDto}
     * @memberof SearchSongPacksDto
     */
    'original'?: BasicVariantPackDto;
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof SearchSongPacksDto
     */
    'found': Array<BasicVariantPackDto>;
    /**
     * 
     * @type {Array<BasicVariantPackDto>}
     * @memberof SearchSongPacksDto
     */
    'other'?: Array<BasicVariantPackDto>;
}
/**
 * 
 * @export
 * @interface SendErrorInDto
 */
export interface SendErrorInDto {
    /**
     * 
     * @type {string}
     * @memberof SendErrorInDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SendErrorInDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SetMemberRoleInDto
 */
export interface SetMemberRoleInDto {
    /**
     * 
     * @type {string}
     * @memberof SetMemberRoleInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SetMemberRoleInDto
     */
    'teamGuid': string;
    /**
     * 
     * @type {number}
     * @memberof SetMemberRoleInDto
     */
    'role': SetMemberRoleInDtoRoleEnum;
}

export const SetMemberRoleInDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SetMemberRoleInDtoRoleEnum = typeof SetMemberRoleInDtoRoleEnum[keyof typeof SetMemberRoleInDtoRoleEnum];

/**
 * 
 * @export
 * @interface SetPackTranslationTypeInDto
 */
export interface SetPackTranslationTypeInDto {
    /**
     * 
     * @type {string}
     * @memberof SetPackTranslationTypeInDto
     */
    'packGuid': string;
    /**
     * 
     * @type {number}
     * @memberof SetPackTranslationTypeInDto
     */
    'translationType': SetPackTranslationTypeInDtoTranslationTypeEnum;
}

export const SetPackTranslationTypeInDtoTranslationTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type SetPackTranslationTypeInDtoTranslationTypeEnum = typeof SetPackTranslationTypeInDtoTranslationTypeEnum[keyof typeof SetPackTranslationTypeInDtoTranslationTypeEnum];

/**
 * 
 * @export
 * @interface SignUpInDto
 */
export interface SignUpInDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    '_mainTitleGuid': string;
    /**
     * 
     * @type {SongTitle}
     * @memberof Song
     */
    'mainTitle': SongTitle;
    /**
     * 
     * @type {Array<SongVariantHistoryPack>}
     * @memberof Song
     */
    'variantPacks': Array<SongVariantHistoryPack>;
}
/**
 * 
 * @export
 * @interface SongDataCreator
 */
export interface SongDataCreator {
    /**
     * 
     * @type {string}
     * @memberof SongDataCreator
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SongDataCreator
     */
    'type': SongDataCreatorTypeEnum;
}

export const SongDataCreatorTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataCreatorTypeEnum = typeof SongDataCreatorTypeEnum[keyof typeof SongDataCreatorTypeEnum];

/**
 * 
 * @export
 * @interface SongDataMedia
 */
export interface SongDataMedia {
    /**
     * 
     * @type {number}
     * @memberof SongDataMedia
     */
    'type': SongDataMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataMedia
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataMedia
     */
    'guid': string;
}

export const SongDataMediaTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongDataMediaTypeEnum = typeof SongDataMediaTypeEnum[keyof typeof SongDataMediaTypeEnum];

/**
 * 
 * @export
 * @interface SongDataSource
 */
export interface SongDataSource {
    /**
     * 
     * @type {number}
     * @memberof SongDataSource
     */
    'type': SongDataSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataSource
     */
    'value': string;
}

export const SongDataSourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataSourceTypeEnum = typeof SongDataSourceTypeEnum[keyof typeof SongDataSourceTypeEnum];

/**
 * 
 * @export
 * @interface SongDataVariant
 */
export interface SongDataVariant {
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'songGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongDataVariant
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'createdByGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {Array<SourceDTO>}
     * @memberof SongDataVariant
     */
    'sources': Array<SourceDTO>;
    /**
     * 
     * @type {Array<CreatorDTO>}
     * @memberof SongDataVariant
     */
    'creators': Array<CreatorDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongDataVariant
     */
    'createdType': SongDataVariantCreatedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'alias': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'inFormat': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'public': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongDataVariant
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'createdForPlaylistGuid': string | null;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'packCreatedAt': string;
}

export const SongDataVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongDataVariantCreatedTypeEnum = typeof SongDataVariantCreatedTypeEnum[keyof typeof SongDataVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongTitle
 */
export interface SongTitle {
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'searchValue': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongTitle
     */
    'variant': SongVariant;
}
/**
 * 
 * @export
 * @interface SongVariant
 */
export interface SongVariant {
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'searchValue': string;
    /**
     * 
     * @type {object}
     * @memberof SongVariant
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'type'?: SongVariantTypeEnum;
    /**
     * 
     * @type {SongTitle}
     * @memberof SongVariant
     */
    'prefferedTitle': SongTitle;
    /**
     * 
     * @type {Array<SongTitle>}
     * @memberof SongVariant
     */
    'titles': Array<SongTitle>;
    /**
     * 
     * @type {User}
     * @memberof SongVariant
     */
    'createdBy': User;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof SongVariant
     */
    'links': Array<CSVLink>;
    /**
     * 
     * @type {Array<Source>}
     * @memberof SongVariant
     */
    'sources': Array<Source>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof SongVariant
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'tagsGenerated': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'createdType': SongVariantCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariant
     */
    'children': Array<SongVariant>;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariant
     */
    'parent': SongVariant;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof SongVariant
     */
    'historyPack': SongVariantHistoryPack;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'inFormat': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'hasChords': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'isLast': boolean;
}

export const SongVariantTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SongVariantTypeEnum = typeof SongVariantTypeEnum[keyof typeof SongVariantTypeEnum];
export const SongVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantCreatedTypeEnum = typeof SongVariantCreatedTypeEnum[keyof typeof SongVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongVariantHistoryPack
 */
export interface SongVariantHistoryPack {
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    'guid': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariantHistoryPack
     */
    'last': SongVariant;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariantHistoryPack
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    '_songGuid': string;
    /**
     * 
     * @type {Song}
     * @memberof SongVariantHistoryPack
     */
    'song': Song;
    /**
     * 
     * @type {Array<UrlAlias>}
     * @memberof SongVariantHistoryPack
     */
    'aliases': Array<UrlAlias>;
    /**
     * 
     * @type {UrlAlias}
     * @memberof SongVariantHistoryPack
     */
    'alias': UrlAlias;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantHistoryPack
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariantHistoryPack
     */
    'translationType': SongVariantHistoryPackTranslationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SongVariantHistoryPack
     */
    'ggFilter': SongVariantHistoryPackGgFilterEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantHistoryPack
     */
    'public': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariantHistoryPack
     */
    'publishApprovalStatus': SongVariantHistoryPackPublishApprovalStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    'publishedAt': string | null;
    /**
     * 
     * @type {Playlist}
     * @memberof SongVariantHistoryPack
     */
    'createdForPlaylist': Playlist;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof SongVariantHistoryPack
     */
    'playlistItems': Array<PlaylistItem>;
    /**
     * 
     * @type {Array<Media>}
     * @memberof SongVariantHistoryPack
     */
    'media': Array<Media>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    'updatedAt': string;
}

export const SongVariantHistoryPackTranslationTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type SongVariantHistoryPackTranslationTypeEnum = typeof SongVariantHistoryPackTranslationTypeEnum[keyof typeof SongVariantHistoryPackTranslationTypeEnum];
export const SongVariantHistoryPackGgFilterEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type SongVariantHistoryPackGgFilterEnum = typeof SongVariantHistoryPackGgFilterEnum[keyof typeof SongVariantHistoryPackGgFilterEnum];
export const SongVariantHistoryPackPublishApprovalStatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type SongVariantHistoryPackPublishApprovalStatusEnum = typeof SongVariantHistoryPackPublishApprovalStatusEnum[keyof typeof SongVariantHistoryPackPublishApprovalStatusEnum];

/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof Source
     */
    'type': SourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'value': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof Source
     */
    'variant': SongVariant;
}

export const SourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceTypeEnum = typeof SourceTypeEnum[keyof typeof SourceTypeEnum];

/**
 * 
 * @export
 * @interface SourceDTO
 */
export interface SourceDTO {
    /**
     * 
     * @type {number}
     * @memberof SourceDTO
     */
    'type': SourceDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDTO
     */
    'value': string;
}

export const SourceDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceDTOTypeEnum = typeof SourceDTOTypeEnum[keyof typeof SourceDTOTypeEnum];

/**
 * 
 * @export
 * @interface StatisticsSongData
 */
export interface StatisticsSongData {
    /**
     * 
     * @type {string}
     * @memberof StatisticsSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof StatisticsSongData
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'guid': string;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof Tag
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'joinCode': string;
    /**
     * 
     * @type {Playlist}
     * @memberof Team
     */
    'selection': Playlist;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof Team
     */
    'members': Array<TeamMember>;
    /**
     * 
     * @type {User}
     * @memberof Team
     */
    'createdBy': User;
    /**
     * 
     * @type {PermissionUserGroup}
     * @memberof Team
     */
    'managersPermissionGroup': PermissionUserGroup;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof Team
     */
    'playlists': Array<Playlist>;
    /**
     * 
     * @type {Image}
     * @memberof Team
     */
    'logo': Image;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof Team
     */
    'pinnedPlaylists': Array<Playlist>;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface TeamEvent
 */
export interface TeamEvent {
    /**
     * 
     * @type {string}
     * @memberof TeamEvent
     */
    'guid': string;
    /**
     * 
     * @type {Team}
     * @memberof TeamEvent
     */
    'team': Team;
    /**
     * 
     * @type {TeamMember}
     * @memberof TeamEvent
     */
    'leader': TeamMember;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof TeamEvent
     */
    'members': Array<TeamMember>;
    /**
     * 
     * @type {string}
     * @memberof TeamEvent
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEvent
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEvent
     */
    'eventDate': string;
    /**
     * 
     * @type {Playlist}
     * @memberof TeamEvent
     */
    'attachedPlaylist': Playlist;
    /**
     * 
     * @type {string}
     * @memberof TeamEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEvent
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface TeamEventData
 */
export interface TeamEventData {
    /**
     * 
     * @type {string}
     * @memberof TeamEventData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventData
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventData
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventData
     */
    'teamGuid': string;
    /**
     * 
     * @type {TeamEventMemberData}
     * @memberof TeamEventData
     */
    'leader': TeamEventMemberData;
    /**
     * 
     * @type {Array<TeamEventMemberData>}
     * @memberof TeamEventData
     */
    'members': Array<TeamEventMemberData>;
    /**
     * 
     * @type {TeamEventPlaylistData}
     * @memberof TeamEventData
     */
    'playlist': TeamEventPlaylistData;
}
/**
 * 
 * @export
 * @interface TeamEventMemberData
 */
export interface TeamEventMemberData {
    /**
     * 
     * @type {string}
     * @memberof TeamEventMemberData
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventMemberData
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventMemberData
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface TeamEventPlaylistData
 */
export interface TeamEventPlaylistData {
    /**
     * 
     * @type {string}
     * @memberof TeamEventPlaylistData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TeamEventPlaylistData
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'guid': string;
    /**
     * 
     * @type {Team}
     * @memberof TeamMember
     */
    'team': Team;
    /**
     * 
     * @type {User}
     * @memberof TeamMember
     */
    'user': User;
    /**
     * 
     * @type {number}
     * @memberof TeamMember
     */
    'role': TeamMemberRoleEnum;
}

export const TeamMemberRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type TeamMemberRoleEnum = typeof TeamMemberRoleEnum[keyof typeof TeamMemberRoleEnum];

/**
 * 
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'lastName': string;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDto
     */
    'role': TeamMemberDtoRoleEnum;
}

export const TeamMemberDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type TeamMemberDtoRoleEnum = typeof TeamMemberDtoRoleEnum[keyof typeof TeamMemberDtoRoleEnum];

/**
 * 
 * @export
 * @interface TeamOfUserDto
 */
export interface TeamOfUserDto {
    /**
     * 
     * @type {string}
     * @memberof TeamOfUserDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof TeamOfUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TeamOfUserDto
     */
    'logoGuid': string | null;
    /**
     * 
     * @type {string}
     * @memberof TeamOfUserDto
     */
    'selectionGuid': string;
}
/**
 * 
 * @export
 * @interface TeamPlaylistData
 */
export interface TeamPlaylistData {
    /**
     * 
     * @type {string}
     * @memberof TeamPlaylistData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TeamPlaylistData
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TranslationLikeItemOutDto
 */
export interface TranslationLikeItemOutDto {
    /**
     * 
     * @type {string}
     * @memberof TranslationLikeItemOutDto
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface TransposePlaylistItemInDto
 */
export interface TransposePlaylistItemInDto {
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface TrendingSong
 */
export interface TrendingSong {
    /**
     * 
     * @type {StatisticsSongData}
     * @memberof TrendingSong
     */
    'song': StatisticsSongData;
    /**
     * 
     * @type {number}
     * @memberof TrendingSong
     */
    'trending': number;
}
/**
 * 
 * @export
 * @interface UpdateNoteInDto
 */
export interface UpdateNoteInDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNoteInDto
     */
    'noteGuid': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNoteInDto
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface UpdateTeamNoteInDto
 */
export interface UpdateTeamNoteInDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamNoteInDto
     */
    'noteGuid': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamNoteInDto
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface UploadImageOutDto
 */
export interface UploadImageOutDto {
    /**
     * 
     * @type {string}
     * @memberof UploadImageOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UploadImageOutDto
     */
    'fileName': string;
}
/**
 * 
 * @export
 * @interface UrlAlias
 */
export interface UrlAlias {
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'alias': string;
    /**
     * 
     * @type {number}
     * @memberof UrlAlias
     */
    'type': UrlAliasTypeEnum;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof UrlAlias
     */
    'pack': SongVariantHistoryPack;
}

export const UrlAliasTypeEnum = {
    NUMBER_0: 0
} as const;

export type UrlAliasTypeEnum = typeof UrlAliasTypeEnum[keyof typeof UrlAliasTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof User
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof User
     */
    'playlists': Array<Playlist>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof User
     */
    'permissions': Array<Permission>;
    /**
     * 
     * @type {Array<UserToken>}
     * @memberof User
     */
    'tokens': Array<UserToken>;
    /**
     * 
     * @type {Array<UserToken>}
     * @memberof User
     */
    'resetTokens': Array<UserToken>;
    /**
     * 
     * @type {Image}
     * @memberof User
     */
    'picture': Image;
    /**
     * 
     * @type {Playlist}
     * @memberof User
     */
    'favourites': Playlist;
}

export const UserRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserToken
 */
export interface UserToken {
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'revokedAt': string;
    /**
     * 
     * @type {User}
     * @memberof UserToken
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface ValidationResult
 */
export interface ValidationResult {
    /**
     * 
     * @type {boolean}
     * @memberof ValidationResult
     */
    'success': boolean;
    /**
     * 
     * @type {object}
     * @memberof ValidationResult
     */
    'qualities': object;
    /**
     * 
     * @type {string}
     * @memberof ValidationResult
     */
    'message': string;
}

/**
 * AIApi - axios parameter creator
 * @export
 */
export const AIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostAiRequestInDto} postAiRequestInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeRequest: async (postAiRequestInDto: PostAiRequestInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAiRequestInDto' is not null or undefined
            assertParamExists('makeRequest', 'postAiRequestInDto', postAiRequestInDto)
            const localVarPath = `/ai/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAiRequestInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostAiRequestInDto} postAiRequestInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeRequest(postAiRequestInDto: PostAiRequestInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAiRequestOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeRequest(postAiRequestInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.makeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIApiFp(configuration)
    return {
        /**
         * 
         * @param {PostAiRequestInDto} postAiRequestInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeRequest(postAiRequestInDto: PostAiRequestInDto, options?: any): AxiosPromise<PostAiRequestOutDto> {
            return localVarFp.makeRequest(postAiRequestInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
    /**
     * 
     * @param {PostAiRequestInDto} postAiRequestInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public makeRequest(postAiRequestInDto: PostAiRequestInDto, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).makeRequest(postAiRequestInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangePasswordInDto} changePasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordInDto: ChangePasswordInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordInDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordInDto', changePasswordInDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProfilePhoto: async (changeProfilePhotoInDto: ChangeProfilePhotoInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeProfilePhotoInDto' is not null or undefined
            assertParamExists('changeProfilePhoto', 'changeProfilePhotoInDto', changeProfilePhotoInDto)
            const localVarPath = `/auth/change-profile-photo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeProfilePhotoInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeUserNameInDto} changeUserNameInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserName: async (changeUserNameInDto: ChangeUserNameInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeUserNameInDto' is not null or undefined
            assertParamExists('changeUserName', 'changeUserNameInDto', changeUserNameInDto)
            const localVarPath = `/auth/change-user-name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserNameInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTokenExpiration: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/checktokenexpiration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGuidFromEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getUserGuidFromEmail', 'email', email)
            const localVarPath = `/auth/guidfromemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInputData: LoginInputData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInputData' is not null or undefined
            assertParamExists('login', 'loginInputData', loginInputData)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('loginWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPasswordInDto} resetPasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordInDto: ResetPasswordInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordInDto' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordInDto', resetPasswordInDto)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResetToken: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('sendResetToken', 'email', email)
            const localVarPath = `/auth/send-reset-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInDto} signUpInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signUpInDto: SignUpInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpInDto' is not null or undefined
            assertParamExists('signup', 'signUpInDto', signUpInDto)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('signupWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/signup/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordInDto} changePasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordInDto: ChangePasswordInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeProfilePhoto(changeProfilePhotoInDto: ChangeProfilePhotoInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeProfilePhoto(changeProfilePhotoInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changeProfilePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChangeUserNameInDto} changeUserNameInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserName(changeUserNameInDto: ChangeUserNameInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserName(changeUserNameInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changeUserName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTokenExpiration(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTokenExpiration(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.checkTokenExpiration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGuidFromEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getUserGuidFromEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInputData: LoginInputData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInputData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithGoogle(postGoogleLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResetPasswordInDto} resetPasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordInDto: ResetPasswordInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendResetToken(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendResetToken(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.sendResetToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInDto} signUpInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signUpInDto: SignUpInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signUpInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupWithGoogle(postGoogleLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signupWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordInDto} changePasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordInDto: ChangePasswordInDto, options?: any): AxiosPromise<void> {
            return localVarFp.changePassword(changePasswordInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProfilePhoto(changeProfilePhotoInDto: ChangeProfilePhotoInDto, options?: any): AxiosPromise<void> {
            return localVarFp.changeProfilePhoto(changeProfilePhotoInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangeUserNameInDto} changeUserNameInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserName(changeUserNameInDto: ChangeUserNameInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeUserName(changeUserNameInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTokenExpiration(options?: any): AxiosPromise<boolean> {
            return localVarFp.checkTokenExpiration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGuidFromEmail(email: string, options?: any): AxiosPromise<string> {
            return localVarFp.getUserGuidFromEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInputData: LoginInputData, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.login(loginInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.loginWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetPasswordInDto} resetPasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordInDto: ResetPasswordInDto, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(resetPasswordInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResetToken(email: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendResetToken(email, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInDto} signUpInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpInDto: SignUpInDto, options?: any): AxiosPromise<void> {
            return localVarFp.signup(signUpInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.signupWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {ChangePasswordInDto} changePasswordInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePassword(changePasswordInDto: ChangePasswordInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePassword(changePasswordInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changeProfilePhoto(changeProfilePhotoInDto: ChangeProfilePhotoInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changeProfilePhoto(changeProfilePhotoInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangeUserNameInDto} changeUserNameInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changeUserName(changeUserNameInDto: ChangeUserNameInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changeUserName(changeUserNameInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public checkTokenExpiration(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).checkTokenExpiration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getUserGuidFromEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using email and password.
     * @summary Logs in the user using email and password.
     * @param {LoginInputData} loginInputData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginInputData: LoginInputData, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using Google.
     * @summary Logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetPasswordInDto} resetPasswordInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPassword(resetPasswordInDto: ResetPasswordInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPassword(resetPasswordInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public sendResetToken(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).sendResetToken(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up using email and password.
     * @summary Signs up the user using email and password.
     * @param {SignUpInDto} signUpInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signup(signUpInDto: SignUpInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signup(signUpInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
     * @summary Signs up or logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signupWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BridgeApi - axios parameter creator
 * @export
 */
export const BridgeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bridge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BridgeApi - functional programming interface
 * @export
 */
export const BridgeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BridgeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BridgeApi.getServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BridgeApi - factory interface
 * @export
 */
export const BridgeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BridgeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(options?: any): AxiosPromise<object> {
            return localVarFp.getServices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BridgeApi - object-oriented interface
 * @export
 * @class BridgeApi
 * @extends {BaseAPI}
 */
export class BridgeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BridgeApi
     */
    public getServices(options?: RawAxiosRequestConfig) {
        return BridgeApiFp(this.configuration).getServices(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monitor/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async root(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.root(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.root']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options?: any): AxiosPromise<void> {
            return localVarFp.root(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public root(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).root(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('getImage', 'guid', guid)
            const localVarPath = `/images/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.getImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadImageOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(guid: string, options?: any): AxiosPromise<object> {
            return localVarFp.getImage(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(options?: any): AxiosPromise<UploadImageOutDto> {
            return localVarFp.uploadFile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public getImage(guid: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).getImage(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public uploadFile(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).uploadFile(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MailApi - axios parameter creator
 * @export
 */
export const MailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFeedbackMail: async (postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendMailFeedbackInDto' is not null or undefined
            assertParamExists('sendFeedbackMail', 'postSendMailFeedbackInDto', postSendMailFeedbackInDto)
            const localVarPath = `/mail/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendMailFeedbackInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestMail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mail/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFeedbackMail(postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendFeedbackMail(postSendMailFeedbackInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.sendFeedbackMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestMail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestMail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.sendTestMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailApiFp(configuration)
    return {
        /**
         * 
         * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFeedbackMail(postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options?: any): AxiosPromise<void> {
            return localVarFp.sendFeedbackMail(postSendMailFeedbackInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestMail(options?: any): AxiosPromise<void> {
            return localVarFp.sendTestMail(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
    /**
     * 
     * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public sendFeedbackMail(postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).sendFeedbackMail(postSendMailFeedbackInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public sendTestMail(options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).sendTestMail(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessengerApi - axios parameter creator
 * @export
 */
export const MessengerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SendErrorInDto} sendErrorInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendError: async (sendErrorInDto: SendErrorInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendErrorInDto' is not null or undefined
            assertParamExists('sendError', 'sendErrorInDto', sendErrorInDto)
            const localVarPath = `/sendError`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendErrorInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessengerApi - functional programming interface
 * @export
 */
export const MessengerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessengerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SendErrorInDto} sendErrorInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendError(sendErrorInDto: SendErrorInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendError(sendErrorInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.sendError']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessengerApi - factory interface
 * @export
 */
export const MessengerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessengerApiFp(configuration)
    return {
        /**
         * 
         * @param {SendErrorInDto} sendErrorInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendError(sendErrorInDto: SendErrorInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.sendError(sendErrorInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessengerApi - object-oriented interface
 * @export
 * @class MessengerApi
 * @extends {BaseAPI}
 */
export class MessengerApi extends BaseAPI {
    /**
     * 
     * @param {SendErrorInDto} sendErrorInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public sendError(sendErrorInDto: SendErrorInDto, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).sendError(sendErrorInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PackEmbeddingApi - axios parameter creator
 * @export
 */
export const PackEmbeddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToGenerate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pack-embedding/addAllPacksToGenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToGenerate: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('addPackToGenerate', 'packGuid', packGuid)
            const localVarPath = `/pack-embedding/addpacktogenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comparePack: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('comparePack', 'packGuid', packGuid)
            const localVarPath = `/pack-embedding/getPackEmbedding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFamily: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('findFamily', 'packGuid', packGuid)
            const localVarPath = `/pack-embedding/findFamily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSimilarPacks: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('findSimilarPacks', 'packGuid', packGuid)
            const localVarPath = `/pack-embedding/findSimilarPacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (searchKey: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('search', 'searchKey', searchKey)
            const localVarPath = `/pack-embedding/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPackVectorize: async (packGuid: string, text: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('testPackVectorize', 'packGuid', packGuid)
            // verify required parameter 'text' is not null or undefined
            assertParamExists('testPackVectorize', 'text', text)
            const localVarPath = `/pack-embedding/testpack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} text1 
         * @param {string} text2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testVectorize: async (text1: string, text2: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text1' is not null or undefined
            assertParamExists('testVectorize', 'text1', text1)
            // verify required parameter 'text2' is not null or undefined
            assertParamExists('testVectorize', 'text2', text2)
            const localVarPath = `/pack-embedding/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (text1 !== undefined) {
                localVarQueryParameter['text1'] = text1;
            }

            if (text2 !== undefined) {
                localVarQueryParameter['text2'] = text2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackEmbeddingApi - functional programming interface
 * @export
 */
export const PackEmbeddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackEmbeddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllPacksToGenerate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllPacksToGenerate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.addAllPacksToGenerate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPackToGenerate(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPackToGenerate(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.addPackToGenerate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async comparePack(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.comparePack(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.comparePack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFamily(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicVariantPackDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFamily(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.findFamily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSimilarPacks(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicVariantPackDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSimilarPacks(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.findSimilarPacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(searchKey: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicVariantPackDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(searchKey, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPackVectorize(packGuid: string, text: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testPackVectorize(packGuid, text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.testPackVectorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} text1 
         * @param {string} text2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testVectorize(text1: string, text2: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testVectorize(text1, text2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackEmbeddingApi.testVectorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PackEmbeddingApi - factory interface
 * @export
 */
export const PackEmbeddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackEmbeddingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToGenerate(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.addAllPacksToGenerate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToGenerate(packGuid: string, options?: any): AxiosPromise<string> {
            return localVarFp.addPackToGenerate(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        comparePack(packGuid: string, options?: any): AxiosPromise<object> {
            return localVarFp.comparePack(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFamily(packGuid: string, options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
            return localVarFp.findFamily(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSimilarPacks(packGuid: string, options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
            return localVarFp.findSimilarPacks(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(searchKey: string, page?: number, options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
            return localVarFp.search(searchKey, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPackVectorize(packGuid: string, text: string, options?: any): AxiosPromise<void> {
            return localVarFp.testPackVectorize(packGuid, text, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} text1 
         * @param {string} text2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testVectorize(text1: string, text2: string, options?: any): AxiosPromise<void> {
            return localVarFp.testVectorize(text1, text2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackEmbeddingApi - object-oriented interface
 * @export
 * @class PackEmbeddingApi
 * @extends {BaseAPI}
 */
export class PackEmbeddingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public addAllPacksToGenerate(options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).addAllPacksToGenerate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public addPackToGenerate(packGuid: string, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).addPackToGenerate(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public comparePack(packGuid: string, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).comparePack(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public findFamily(packGuid: string, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).findFamily(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public findSimilarPacks(packGuid: string, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).findSimilarPacks(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchKey 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public search(searchKey: string, page?: number, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).search(searchKey, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {string} text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public testPackVectorize(packGuid: string, text: string, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).testPackVectorize(packGuid, text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} text1 
     * @param {string} text2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackEmbeddingApi
     */
    public testVectorize(text1: string, text2: string, options?: RawAxiosRequestConfig) {
        return PackEmbeddingApiFp(this.configuration).testVectorize(text1, text2, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParserApi - axios parameter creator
 * @export
 */
export const ParserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobResult: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJobResult', 'id', id)
            const localVarPath = `/parser/get-job-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJobStatus', 'id', id)
            const localVarPath = `/parser/get-job-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAvailable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/parser/is-available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/parser/parse-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParserApi - functional programming interface
 * @export
 */
export const ParserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobResult(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParserSongDataResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobResult(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParserApi.getJobResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParserApi.getJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAvailable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAvailable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParserApi.isAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddFileToParseQueueOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parse(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParserApi.parse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParserApi - factory interface
 * @export
 */
export const ParserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParserApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobResult(id: string, options?: any): AxiosPromise<ParserSongDataResult> {
            return localVarFp.getJobResult(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.getJobStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAvailable(options?: any): AxiosPromise<boolean> {
            return localVarFp.isAvailable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse(options?: any): AxiosPromise<AddFileToParseQueueOutDto> {
            return localVarFp.parse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParserApi - object-oriented interface
 * @export
 * @class ParserApi
 * @extends {BaseAPI}
 */
export class ParserApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public getJobResult(id: string, options?: RawAxiosRequestConfig) {
        return ParserApiFp(this.configuration).getJobResult(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public getJobStatus(id: string, options?: RawAxiosRequestConfig) {
        return ParserApiFp(this.configuration).getJobStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public isAvailable(options?: RawAxiosRequestConfig) {
        return ParserApiFp(this.configuration).isAvailable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public parse(options?: RawAxiosRequestConfig) {
        return ParserApiFp(this.configuration).parse(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToGroup: async (addPermissionToGroupInDto: AddPermissionToGroupInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToGroupInDto' is not null or undefined
            assertParamExists('addPermissionToGroup', 'addPermissionToGroupInDto', addPermissionToGroupInDto)
            const localVarPath = `/permissions/group/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToGroupInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('addPermissionToUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersWithPermission: async (type: string, payload?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getAllUsersWithPermission', 'type', type)
            const localVarPath = `/permissions/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (payload !== undefined) {
                localVarQueryParameter['payload'] = payload;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrAddPermission: async (getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOrCreatePermissionInDto' is not null or undefined
            assertParamExists('getOrAddPermission', 'getOrCreatePermissionInDto', getOrCreatePermissionInDto)
            const localVarPath = `/permissions/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrCreatePermissionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions: async (userGuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userGuid !== undefined) {
                localVarQueryParameter['userGuid'] = userGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromGroup: async (addPermissionToGroupInDto: AddPermissionToGroupInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToGroupInDto' is not null or undefined
            assertParamExists('removePermissionFromGroup', 'addPermissionToGroupInDto', addPermissionToGroupInDto)
            const localVarPath = `/permissions/group/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToGroupInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('removePermissionFromUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionToGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionUserGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionToGroup(addPermissionToGroupInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.addPermissionToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionToUser(addPermissionToUserInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.addPermissionToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionUserBaseOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersWithPermission(type, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getAllUsersWithPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrAddPermission(getOrCreatePermissionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getOrAddPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserPermissionOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPermissions(userGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePermissionFromGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionUserGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionFromGroup(addPermissionToGroupInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.removePermissionFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionFromUser(addPermissionToUserInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.removePermissionFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: any): AxiosPromise<PermissionUserGroup> {
            return localVarFp.addPermissionToGroup(addPermissionToGroupInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.addPermissionToUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersWithPermission(type: string, payload?: string, options?: any): AxiosPromise<Array<PermissionUserBaseOutDto>> {
            return localVarFp.getAllUsersWithPermission(type, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.getOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(userGuid?: string, options?: any): AxiosPromise<Array<GetUserPermissionOutDto>> {
            return localVarFp.getUserPermissions(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: any): AxiosPromise<PermissionUserGroup> {
            return localVarFp.removePermissionFromGroup(addPermissionToGroupInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.removePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public addPermissionToGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).addPermissionToGroup(addPermissionToGroupInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public addPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).addPermissionToUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} type 
     * @param {string} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getAllUsersWithPermission(type, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userGuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getUserPermissions(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public removePermissionFromGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).removePermissionFromGroup(addPermissionToGroupInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public removePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).removePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistEditingApi - axios parameter creator
 * @export
 */
export const PlaylistEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVariantToPlaylist: async (addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addVariantToPlaylistInDto' is not null or undefined
            assertParamExists('addVariantToPlaylist', 'addVariantToPlaylistInDto', addVariantToPlaylistInDto)
            const localVarPath = `/playlist/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVariantToPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('deletePlaylist', 'guid', guid)
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditItemInDto} editItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editItem: async (editItemInDto: EditItemInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editItemInDto' is not null or undefined
            assertParamExists('editItem', 'editItemInDto', editItemInDto)
            const localVarPath = `/playlist/edititem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editItemInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isItemEditable: async (itemGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemGuid' is not null or undefined
            assertParamExists('isItemEditable', 'itemGuid', itemGuid)
            const localVarPath = `/playlist/isitemeditable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemGuid !== undefined) {
                localVarQueryParameter['itemGuid'] = itemGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVariantFromPlaylistDelete: async (packGuid: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('removeVariantFromPlaylistDelete', 'packGuid', packGuid)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('removeVariantFromPlaylistDelete', 'playlist', playlist)
            const localVarPath = `/playlist/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renamePlaylist: async (renamePlaylistInDto: RenamePlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renamePlaylistInDto' is not null or undefined
            assertParamExists('renamePlaylist', 'renamePlaylistInDto', renamePlaylistInDto)
            const localVarPath = `/playlist/rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renamePlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderPlaylist: async (reorderPlaylistInDto: ReorderPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reorderPlaylistInDto' is not null or undefined
            assertParamExists('reorderPlaylist', 'reorderPlaylistInDto', reorderPlaylistInDto)
            const localVarPath = `/playlist/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequireItemEditInDto} requireItemEditInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requireItemEdit: async (requireItemEditInDto: RequireItemEditInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requireItemEditInDto' is not null or undefined
            assertParamExists('requireItemEdit', 'requireItemEditInDto', requireItemEditInDto)
            const localVarPath = `/playlist/requireItemEdit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requireItemEditInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transposePlaylistItem: async (transposePlaylistItemInDto: TransposePlaylistItemInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transposePlaylistItemInDto' is not null or undefined
            assertParamExists('transposePlaylistItem', 'transposePlaylistItemInDto', transposePlaylistItemInDto)
            const localVarPath = `/playlist/transpose`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transposePlaylistItemInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistEditingApi - functional programming interface
 * @export
 */
export const PlaylistEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItemOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVariantToPlaylist(addVariantToPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.addVariantToPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreatePlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.createPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylist(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.deletePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditItemInDto} editItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editItem(editItemInDto: EditItemInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editItem(editItemInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.editItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} itemGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isItemEditable(itemGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isItemEditable(itemGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.isItemEditable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVariantFromPlaylistDelete(packGuid: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeVariantFromPlaylistDelete(packGuid, playlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.removeVariantFromPlaylistDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renamePlaylist(renamePlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.renamePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderPlaylist(reorderPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.reorderPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RequireItemEditInDto} requireItemEditInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requireItemEdit(requireItemEditInDto: RequireItemEditInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequireItemEditOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requireItemEdit(requireItemEditInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.requireItemEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transposePlaylistItem(transposePlaylistItemInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.transposePlaylistItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistEditingApi - factory interface
 * @export
 */
export const PlaylistEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: any): AxiosPromise<PlaylistItemOutDto> {
            return localVarFp.addVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(options?: any): AxiosPromise<PostCreatePlaylistResult> {
            return localVarFp.createPlaylist(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deletePlaylist(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditItemInDto} editItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editItem(editItemInDto: EditItemInDto, options?: any): AxiosPromise<void> {
            return localVarFp.editItem(editItemInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isItemEditable(itemGuid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.isItemEditable(itemGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVariantFromPlaylistDelete(packGuid: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.removeVariantFromPlaylistDelete(packGuid, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.renamePlaylist(renamePlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.reorderPlaylist(reorderPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequireItemEditInDto} requireItemEditInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requireItemEdit(requireItemEditInDto: RequireItemEditInDto, options?: any): AxiosPromise<RequireItemEditOutDto> {
            return localVarFp.requireItemEdit(requireItemEditInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.transposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistEditingApi - object-oriented interface
 * @export
 * @class PlaylistEditingApi
 * @extends {BaseAPI}
 */
export class PlaylistEditingApi extends BaseAPI {
    /**
     * 
     * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public addVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).addVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public createPlaylist(options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).createPlaylist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public deletePlaylist(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).deletePlaylist(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditItemInDto} editItemInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public editItem(editItemInDto: EditItemInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).editItem(editItemInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public isItemEditable(itemGuid: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).isItemEditable(itemGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public removeVariantFromPlaylistDelete(packGuid: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).removeVariantFromPlaylistDelete(packGuid, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RenamePlaylistInDto} renamePlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public renamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).renamePlaylist(renamePlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public reorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).reorderPlaylist(reorderPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequireItemEditInDto} requireItemEditInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public requireItemEdit(requireItemEditInDto: RequireItemEditInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).requireItemEdit(requireItemEditInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public transposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).transposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistGettingApi - axios parameter creator
 * @export
 */
export const PlaylistGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistDataByGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('getPlaylistDataByGuid', 'guid', guid)
            const localVarPath = `/playlist/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistsOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist/ofuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isVariantInPlaylist: async (packGuid: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('isVariantInPlaylist', 'packGuid', packGuid)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('isVariantInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/contains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInPlaylist: async (searchKey: string, playlist: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchInPlaylist', 'searchKey', searchKey)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('searchInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playlistGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylistOpenDate: async (playlistGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistGuid' is not null or undefined
            assertParamExists('updatePlaylistOpenDate', 'playlistGuid', playlistGuid)
            const localVarPath = `/playlist/updateopendate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (playlistGuid !== undefined) {
                localVarQueryParameter['playlistGuid'] = playlistGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistGettingApi - functional programming interface
 * @export
 */
export const PlaylistGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylistDataByGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.getPlaylistDataByGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistsOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlaylistsResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylistsOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.getPlaylistsOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isVariantInPlaylist(packGuid: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isVariantInPlaylist(packGuid, playlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.isVariantInPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchInPlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInPlaylist(searchKey, playlist, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.searchInPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} playlistGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaylistOpenDate(playlistGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaylistOpenDate(playlistGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.updatePlaylistOpenDate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistGettingApi - factory interface
 * @export
 */
export const PlaylistGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistDataByGuid(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.getPlaylistDataByGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistsOfUser(options?: any): AxiosPromise<GetPlaylistsResult> {
            return localVarFp.getPlaylistsOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isVariantInPlaylist(packGuid: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.isVariantInPlaylist(packGuid, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInPlaylist(searchKey: string, playlist: string, page?: number, options?: any): AxiosPromise<GetSearchInPlaylistResult> {
            return localVarFp.searchInPlaylist(searchKey, playlist, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylistOpenDate(playlistGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.updatePlaylistOpenDate(playlistGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistGettingApi - object-oriented interface
 * @export
 * @class PlaylistGettingApi
 * @extends {BaseAPI}
 */
export class PlaylistGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public getPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).getPlaylistDataByGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public getPlaylistsOfUser(options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).getPlaylistsOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public isVariantInPlaylist(packGuid: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).isVariantInPlaylist(packGuid, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchKey 
     * @param {string} playlist 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public searchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).searchInPlaylist(searchKey, playlist, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} playlistGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public updatePlaylistOpenDate(playlistGuid: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).updatePlaylistOpenDate(playlistGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramSongAddingApi - axios parameter creator
 * @export
 */
export const ProgramSongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDataStream: async (programSongData: ProgramSongData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programSongData' is not null or undefined
            assertParamExists('processDataStream', 'programSongData', programSongData)
            const localVarPath = `/song/processdatastream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(programSongData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramSongAddingApi - functional programming interface
 * @export
 */
export const ProgramSongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramSongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processDataStream(programSongData: ProgramSongData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processDataStream(programSongData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramSongAddingApi.processDataStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramSongAddingApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramSongAddingApi - factory interface
 * @export
 */
export const ProgramSongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramSongAddingApiFp(configuration)
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDataStream(programSongData: ProgramSongData, options?: any): AxiosPromise<boolean> {
            return localVarFp.processDataStream(programSongData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: any): AxiosPromise<string> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramSongAddingApi - object-oriented interface
 * @export
 * @class ProgramSongAddingApi
 * @extends {BaseAPI}
 */
export class ProgramSongAddingApi extends BaseAPI {
    /**
     * This function process data stream from loader\'s program. Getter and so on.
     * @summary 
     * @param {ProgramSongData} programSongData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramSongAddingApi
     */
    public processDataStream(programSongData: ProgramSongData, options?: RawAxiosRequestConfig) {
        return ProgramSongAddingApiFp(this.configuration).processDataStream(programSongData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramSongAddingApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return ProgramSongAddingApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongAddingApi - axios parameter creator
 * @export
 */
export const SongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (postCreateVariantInDto: PostCreateVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateVariantInDto' is not null or undefined
            assertParamExists('create', 'postCreateVariantInDto', postCreateVariantInDto)
            const localVarPath = `/song`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCopy: async (postCreateCopyInDto: PostCreateCopyInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateCopyInDto' is not null or undefined
            assertParamExists('createCopy', 'postCreateCopyInDto', postCreateCopyInDto)
            const localVarPath = `/song/create/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateCopyInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongAddingApi - functional programming interface
 * @export
 */
export const SongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(postCreateVariantInDto: PostCreateVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(postCreateVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateCopyOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCopy(postCreateCopyInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.createCopy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongAddingApi - factory interface
 * @export
 */
export const SongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongAddingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(postCreateVariantInDto: PostCreateVariantInDto, options?: any): AxiosPromise<PostCreateVariantOutDto> {
            return localVarFp.create(postCreateVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: any): AxiosPromise<PostCreateCopyOutDto> {
            return localVarFp.createCopy(postCreateCopyInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongAddingApi - object-oriented interface
 * @export
 * @class SongAddingApi
 * @extends {BaseAPI}
 */
export class SongAddingApi extends BaseAPI {
    /**
     * 
     * @param {PostCreateVariantInDto} postCreateVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public create(postCreateVariantInDto: PostCreateVariantInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).create(postCreateVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostCreateCopyInDto} postCreateCopyInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public createCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).createCopy(postCreateCopyInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongDeletingApi - axios parameter creator
 * @export
 */
export const SongDeletingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('_delete', 'packGuid', packGuid)
            const localVarPath = `/song/variant/delete/{packGuid}`
                .replace(`{${"packGuid"}}`, encodeURIComponent(String(packGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('restore', 'packGuid', packGuid)
            const localVarPath = `/song/variant/restore/{packGuid}`
                .replace(`{${"packGuid"}}`, encodeURIComponent(String(packGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongDeletingApi - functional programming interface
 * @export
 */
export const SongDeletingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongDeletingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongDeletingApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restore(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restore(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongDeletingApi.restore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongDeletingApi - factory interface
 * @export
 */
export const SongDeletingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongDeletingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(packGuid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp._delete(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(packGuid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.restore(packGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongDeletingApi - object-oriented interface
 * @export
 * @class SongDeletingApi
 * @extends {BaseAPI}
 */
export class SongDeletingApi extends BaseAPI {
    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public _delete(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration)._delete(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public restore(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).restore(packGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongEditingApi - axios parameter creator
 * @export
 */
export const SongEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLanguage: async (postChangeLanguageInDto: PostChangeLanguageInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postChangeLanguageInDto' is not null or undefined
            assertParamExists('changeLanguage', 'postChangeLanguageInDto', postChangeLanguageInDto)
            const localVarPath = `/song/variant/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postChangeLanguageInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariant: async (postEditVariantInDto: PostEditVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postEditVariantInDto' is not null or undefined
            assertParamExists('editVariant', 'postEditVariantInDto', postEditVariantInDto)
            const localVarPath = `/song/variant/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postEditVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongEditingApi - functional programming interface
 * @export
 */
export const SongEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeLanguage(postChangeLanguageInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongEditingApi.changeLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editVariant(postEditVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongEditingApi.editVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongEditingApi - factory interface
 * @export
 */
export const SongEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: any): AxiosPromise<SongVariant> {
            return localVarFp.changeLanguage(postChangeLanguageInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariant(postEditVariantInDto: PostEditVariantInDto, options?: any): AxiosPromise<EditVariantOutDto> {
            return localVarFp.editVariant(postEditVariantInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongEditingApi - object-oriented interface
 * @export
 * @class SongEditingApi
 * @extends {BaseAPI}
 */
export class SongEditingApi extends BaseAPI {
    /**
     * 
     * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public changeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).changeLanguage(postChangeLanguageInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostEditVariantInDto} postEditVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public editVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).editVariant(postEditVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongFavouritesApi - axios parameter creator
 * @export
 */
export const SongFavouritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddFavouriteInDto} addFavouriteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavourite: async (addFavouriteInDto: AddFavouriteInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addFavouriteInDto' is not null or undefined
            assertParamExists('addFavourite', 'addFavouriteInDto', addFavouriteInDto)
            const localVarPath = `/song/favourites/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFavouriteInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavourites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/favourites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveFavouriteInDto} removeFavouriteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavourite: async (removeFavouriteInDto: RemoveFavouriteInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeFavouriteInDto' is not null or undefined
            assertParamExists('removeFavourite', 'removeFavouriteInDto', removeFavouriteInDto)
            const localVarPath = `/song/favourites/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeFavouriteInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongFavouritesApi - functional programming interface
 * @export
 */
export const SongFavouritesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongFavouritesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddFavouriteInDto} addFavouriteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFavourite(addFavouriteInDto: AddFavouriteInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFavourite(addFavouriteInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongFavouritesApi.addFavourite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavourites(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFavouritesOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavourites(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongFavouritesApi.getFavourites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveFavouriteInDto} removeFavouriteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFavourite(removeFavouriteInDto: RemoveFavouriteInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFavourite(removeFavouriteInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongFavouritesApi.removeFavourite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongFavouritesApi - factory interface
 * @export
 */
export const SongFavouritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongFavouritesApiFp(configuration)
    return {
        /**
         * 
         * @param {AddFavouriteInDto} addFavouriteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavourite(addFavouriteInDto: AddFavouriteInDto, options?: any): AxiosPromise<PlaylistItem> {
            return localVarFp.addFavourite(addFavouriteInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavourites(options?: any): AxiosPromise<GetFavouritesOutDto> {
            return localVarFp.getFavourites(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveFavouriteInDto} removeFavouriteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavourite(removeFavouriteInDto: RemoveFavouriteInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.removeFavourite(removeFavouriteInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongFavouritesApi - object-oriented interface
 * @export
 * @class SongFavouritesApi
 * @extends {BaseAPI}
 */
export class SongFavouritesApi extends BaseAPI {
    /**
     * 
     * @param {AddFavouriteInDto} addFavouriteInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongFavouritesApi
     */
    public addFavourite(addFavouriteInDto: AddFavouriteInDto, options?: RawAxiosRequestConfig) {
        return SongFavouritesApiFp(this.configuration).addFavourite(addFavouriteInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongFavouritesApi
     */
    public getFavourites(options?: RawAxiosRequestConfig) {
        return SongFavouritesApiFp(this.configuration).getFavourites(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveFavouriteInDto} removeFavouriteInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongFavouritesApi
     */
    public removeFavourite(removeFavouriteInDto: RemoveFavouriteInDto, options?: RawAxiosRequestConfig) {
        return SongFavouritesApiFp(this.configuration).removeFavourite(removeFavouriteInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongGettingApi - axios parameter creator
 * @export
 */
export const SongGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBySearch: async (searchKey: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('getBySearch', 'searchKey', searchKey)
            const localVarPath = `/song/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAdded: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/getlastadded`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListSongCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/listsongcount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSongBySource: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getPublicSongBySource', 'url', url)
            const localVarPath = `/song/publicsongbysource/{url}`
                .replace(`{${"url"}}`, encodeURIComponent(String(url)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSitemapList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/sitemapList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongDataByGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('getSongDataByGuid', 'guid', guid)
            const localVarPath = `/songDataByGuid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongDataByVariantGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('getSongDataByVariantGuid', 'guid', guid)
            const localVarPath = `/song/ofvariant/{guid}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongListOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantDataByAlias: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('getVariantDataByAlias', 'alias', alias)
            const localVarPath = `/variantdatabyalias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantFromAlias: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('getVariantFromAlias', 'alias', alias)
            const localVarPath = `/song/alias/variant/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGlobalSongsInPopup: async (searchString?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/teampopupglobalsongssearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMySongsInPopup: async (searchString?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/teampopupmysongssearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongGettingApi - functional programming interface
 * @export
 */
export const SongGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBySearch(searchKey: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicVariantPackDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBySearch(searchKey, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getBySearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastAdded(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicVariantPackDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastAdded(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getLastAdded']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetListSongData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListSongCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListSongCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getListSongCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicSongBySource(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPackAliasFromSourceUrlOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicSongBySource(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getPublicSongBySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandom(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRandomVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandom(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getRandom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecommendedSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedSongs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getRecommendedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSitemapList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetListSongData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSitemapList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getSitemapList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongDataByGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicSongDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSongDataByGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getSongDataByGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSongDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSongDataByVariantGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getSongDataByVariantGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongListOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVariantsOfUserOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSongListOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getSongListOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSongsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getSongsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantDataByAlias(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVariantDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariantDataByAlias(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getVariantDataByAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantFromAlias(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariantFromAlias(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.getVariantFromAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGlobalSongsInPopup(searchString?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGlobalSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGlobalSongsInPopup(searchString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.searchGlobalSongsInPopup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMySongsInPopup(searchString?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGlobalSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMySongsInPopup(searchString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.searchMySongsInPopup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongGettingApi - factory interface
 * @export
 */
export const SongGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBySearch(searchKey: string, page?: number, options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
            return localVarFp.getBySearch(searchKey, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAdded(options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
            return localVarFp.getLastAdded(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(page?: number, perPage?: number, options?: any): AxiosPromise<Array<GetListSongData>> {
            return localVarFp.getList(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListSongCount(options?: any): AxiosPromise<number> {
            return localVarFp.getListSongCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSongBySource(url: string, options?: any): AxiosPromise<GetPackAliasFromSourceUrlOutDto> {
            return localVarFp.getPublicSongBySource(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandom(options?: any): AxiosPromise<GetRandomVariantOutDto> {
            return localVarFp.getRandom(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedSongs(options?: any): AxiosPromise<GetRecommendedSongsOutDto> {
            return localVarFp.getRecommendedSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSitemapList(options?: any): AxiosPromise<Array<GetListSongData>> {
            return localVarFp.getSitemapList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongDataByGuid(guid: string, options?: any): AxiosPromise<BasicSongDto> {
            return localVarFp.getSongDataByGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongDataByVariantGuid(guid: string, options?: any): AxiosPromise<GetSongDataOutDto> {
            return localVarFp.getSongDataByVariantGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongListOfUser(options?: any): AxiosPromise<GetVariantsOfUserOutDto> {
            return localVarFp.getSongListOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongsCount(options?: any): AxiosPromise<number> {
            return localVarFp.getSongsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantDataByAlias(alias: string, options?: any): AxiosPromise<GetVariantDataOutDto> {
            return localVarFp.getVariantDataByAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantFromAlias(alias: string, options?: any): AxiosPromise<string> {
            return localVarFp.getVariantFromAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGlobalSongsInPopup(searchString?: string, options?: any): AxiosPromise<GetGlobalSongsOutDto> {
            return localVarFp.searchGlobalSongsInPopup(searchString, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMySongsInPopup(searchString?: string, options?: any): AxiosPromise<GetGlobalSongsOutDto> {
            return localVarFp.searchMySongsInPopup(searchString, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongGettingApi - object-oriented interface
 * @export
 * @class SongGettingApi
 * @extends {BaseAPI}
 */
export class SongGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} searchKey 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getBySearch(searchKey: string, page?: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getBySearch(searchKey, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getLastAdded(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getLastAdded(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getList(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getList(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getListSongCount(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getListSongCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} url 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getPublicSongBySource(url: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getPublicSongBySource(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getRandom(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getRandom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getRecommendedSongs(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getRecommendedSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getSitemapList(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getSitemapList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getSongDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getSongDataByGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getSongDataByVariantGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getSongListOfUser(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getSongListOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getSongsCount(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getSongsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getVariantDataByAlias(alias: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getVariantDataByAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public getVariantFromAlias(alias: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).getVariantFromAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
     * @summary 
     * @param {string} [searchString] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public searchGlobalSongsInPopup(searchString?: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).searchGlobalSongsInPopup(searchString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
     * @summary 
     * @param {string} [searchString] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public searchMySongsInPopup(searchString?: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).searchMySongsInPopup(searchString, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongManagementApi - axios parameter creator
 * @export
 */
export const SongManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add all packs without language to generate
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToGenerate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pack/language/queue/addAllPacksToGenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add all packs without language to generate
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToGenerate_1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pack/gg-filter/queue/addAllPacksToGenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddMediaToPackInDto} addMediaToPackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaToPack: async (addMediaToPackInDto: AddMediaToPackInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addMediaToPackInDto' is not null or undefined
            assertParamExists('addMediaToPack', 'addMediaToPackInDto', addMediaToPackInDto)
            const localVarPath = `/addMediaToPack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMediaToPackInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToGenerate: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('addPackToGenerate', 'packGuid', packGuid)
            const localVarPath = `/pack/language/queue/addpacktogenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToGenerate_2: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('addPackToGenerate_2', 'packGuid', packGuid)
            const localVarPath = `/pack/gg-filter/queue/addpacktogenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auto find family for pack and merge to family
         * @summary 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoFindFamily: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('autoFindFamily', 'packGuid', packGuid)
            const localVarPath = `/song-merging/autoFindFamily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MergeFamiliesInDto} mergeFamiliesInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFamilies: async (mergeFamiliesInDto: MergeFamiliesInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mergeFamiliesInDto' is not null or undefined
            assertParamExists('mergeFamilies', 'mergeFamiliesInDto', mergeFamiliesInDto)
            const localVarPath = `/song-merging/mergeFamilies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeFamiliesInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePacksToFamily: async (movePacksToFamilyInDto: MovePacksToFamilyInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movePacksToFamilyInDto' is not null or undefined
            assertParamExists('movePacksToFamily', 'movePacksToFamilyInDto', movePacksToFamilyInDto)
            const localVarPath = `/song-merging/movePacksToFamily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movePacksToFamilyInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveMediaToPackInDto} removeMediaToPackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaFromPack: async (removeMediaToPackInDto: RemoveMediaToPackInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeMediaToPackInDto' is not null or undefined
            assertParamExists('removeMediaFromPack', 'removeMediaToPackInDto', removeMediaToPackInDto)
            const localVarPath = `/removeMediaFromPack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeMediaToPackInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {boolean} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilterStatusForPack: async (packGuid: string, status: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('setFilterStatusForPack', 'packGuid', packGuid)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('setFilterStatusForPack', 'status', status)
            const localVarPath = `/songs/filter/setFilterStatusForPack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilterStatusToAutoForPack: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('setFilterStatusToAutoForPack', 'packGuid', packGuid)
            const localVarPath = `/songs/filter/setFilterStatusToAutoForPack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTranslationType: async (setPackTranslationTypeInDto: SetPackTranslationTypeInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setPackTranslationTypeInDto' is not null or undefined
            assertParamExists('setTranslationType', 'setPackTranslationTypeInDto', setPackTranslationTypeInDto)
            const localVarPath = `/song/pack-setting/setTranslationType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPackTranslationTypeInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongManagementApi - functional programming interface
 * @export
 */
export const SongManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Add all packs without language to generate
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllPacksToGenerate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllPacksToGenerate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.addAllPacksToGenerate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add all packs without language to generate
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllPacksToGenerate_1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllPacksToGenerate_1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.addAllPacksToGenerate_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddMediaToPackInDto} addMediaToPackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMediaToPack(addMediaToPackInDto: AddMediaToPackInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMediaToPack(addMediaToPackInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.addMediaToPack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPackToGenerate(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPackToGenerate(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.addPackToGenerate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPackToGenerate_2(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPackToGenerate_2(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.addPackToGenerate_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Auto find family for pack and merge to family
         * @summary 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoFindFamily(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoFindFamily(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.autoFindFamily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MergeFamiliesInDto} mergeFamiliesInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeFamilies(mergeFamiliesInDto: MergeFamiliesInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeFamilies(mergeFamiliesInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.mergeFamilies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async movePacksToFamily(movePacksToFamilyInDto: MovePacksToFamilyInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.movePacksToFamily(movePacksToFamilyInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.movePacksToFamily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveMediaToPackInDto} removeMediaToPackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMediaFromPack(removeMediaToPackInDto: RemoveMediaToPackInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMediaFromPack(removeMediaToPackInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.removeMediaFromPack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {boolean} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFilterStatusForPack(packGuid: string, status: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFilterStatusForPack(packGuid, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.setFilterStatusForPack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFilterStatusToAutoForPack(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFilterStatusToAutoForPack(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.setFilterStatusToAutoForPack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTranslationType(setPackTranslationTypeInDto: SetPackTranslationTypeInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTranslationType(setPackTranslationTypeInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongManagementApi.setTranslationType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongManagementApi - factory interface
 * @export
 */
export const SongManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongManagementApiFp(configuration)
    return {
        /**
         * Add all packs without language to generate
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToGenerate(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.addAllPacksToGenerate(options).then((request) => request(axios, basePath));
        },
        /**
         * Add all packs without language to generate
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToGenerate_1(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.addAllPacksToGenerate_1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddMediaToPackInDto} addMediaToPackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaToPack(addMediaToPackInDto: AddMediaToPackInDto, options?: any): AxiosPromise<void> {
            return localVarFp.addMediaToPack(addMediaToPackInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToGenerate(packGuid: string, options?: any): AxiosPromise<string> {
            return localVarFp.addPackToGenerate(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToGenerate_2(packGuid: string, options?: any): AxiosPromise<string> {
            return localVarFp.addPackToGenerate_2(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Auto find family for pack and merge to family
         * @summary 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoFindFamily(packGuid: string, options?: any): AxiosPromise<string> {
            return localVarFp.autoFindFamily(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MergeFamiliesInDto} mergeFamiliesInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFamilies(mergeFamiliesInDto: MergeFamiliesInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.mergeFamilies(mergeFamiliesInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePacksToFamily(movePacksToFamilyInDto: MovePacksToFamilyInDto, options?: any): AxiosPromise<object> {
            return localVarFp.movePacksToFamily(movePacksToFamilyInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveMediaToPackInDto} removeMediaToPackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaFromPack(removeMediaToPackInDto: RemoveMediaToPackInDto, options?: any): AxiosPromise<void> {
            return localVarFp.removeMediaFromPack(removeMediaToPackInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {boolean} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilterStatusForPack(packGuid: string, status: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.setFilterStatusForPack(packGuid, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFilterStatusToAutoForPack(packGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.setFilterStatusToAutoForPack(packGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTranslationType(setPackTranslationTypeInDto: SetPackTranslationTypeInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.setTranslationType(setPackTranslationTypeInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongManagementApi - object-oriented interface
 * @export
 * @class SongManagementApi
 * @extends {BaseAPI}
 */
export class SongManagementApi extends BaseAPI {
    /**
     * Add all packs without language to generate
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public addAllPacksToGenerate(options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).addAllPacksToGenerate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add all packs without language to generate
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public addAllPacksToGenerate_1(options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).addAllPacksToGenerate_1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddMediaToPackInDto} addMediaToPackInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public addMediaToPack(addMediaToPackInDto: AddMediaToPackInDto, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).addMediaToPack(addMediaToPackInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public addPackToGenerate(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).addPackToGenerate(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public addPackToGenerate_2(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).addPackToGenerate_2(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auto find family for pack and merge to family
     * @summary 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public autoFindFamily(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).autoFindFamily(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MergeFamiliesInDto} mergeFamiliesInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public mergeFamilies(mergeFamiliesInDto: MergeFamiliesInDto, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).mergeFamilies(mergeFamiliesInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public movePacksToFamily(movePacksToFamilyInDto: MovePacksToFamilyInDto, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).movePacksToFamily(movePacksToFamilyInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveMediaToPackInDto} removeMediaToPackInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public removeMediaFromPack(removeMediaToPackInDto: RemoveMediaToPackInDto, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).removeMediaFromPack(removeMediaToPackInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {boolean} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public setFilterStatusForPack(packGuid: string, status: boolean, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).setFilterStatusForPack(packGuid, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public setFilterStatusToAutoForPack(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).setFilterStatusToAutoForPack(packGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongManagementApi
     */
    public setTranslationType(setPackTranslationTypeInDto: SetPackTranslationTypeInDto, options?: RawAxiosRequestConfig) {
        return SongManagementApiFp(this.configuration).setTranslationType(setPackTranslationTypeInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongMergingApi - axios parameter creator
 * @export
 */
export const SongMergingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToFindFamily: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song-merging/addallpackstofindfamilyqueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToFindFamily: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('addPackToFindFamily', 'packGuid', packGuid)
            const localVarPath = `/song-merging/addpacktofindfamilyqueue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongMergingApi - functional programming interface
 * @export
 */
export const SongMergingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongMergingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllPacksToFindFamily(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllPacksToFindFamily(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongMergingApi.addAllPacksToFindFamily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPackToFindFamily(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPackToFindFamily(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongMergingApi.addPackToFindFamily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongMergingApi - factory interface
 * @export
 */
export const SongMergingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongMergingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllPacksToFindFamily(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.addAllPacksToFindFamily(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToFindFamily(packGuid: string, options?: any): AxiosPromise<string> {
            return localVarFp.addPackToFindFamily(packGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongMergingApi - object-oriented interface
 * @export
 * @class SongMergingApi
 * @extends {BaseAPI}
 */
export class SongMergingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongMergingApi
     */
    public addAllPacksToFindFamily(options?: RawAxiosRequestConfig) {
        return SongMergingApiFp(this.configuration).addAllPacksToFindFamily(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongMergingApi
     */
    public addPackToFindFamily(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongMergingApiFp(this.configuration).addPackToFindFamily(packGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongNotesApi - axios parameter creator
 * @export
 */
export const SongNotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddNoteToVariantInDto} addNoteToVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteToVariant: async (addNoteToVariantInDto: AddNoteToVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addNoteToVariantInDto' is not null or undefined
            assertParamExists('addNoteToVariant', 'addNoteToVariantInDto', addNoteToVariantInDto)
            const localVarPath = `/song/variant/notes/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addNoteToVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteNoteInDto} deleteNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote: async (deleteNoteInDto: DeleteNoteInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteNoteInDto' is not null or undefined
            assertParamExists('deleteNote', 'deleteNoteInDto', deleteNoteInDto)
            const localVarPath = `/song/variant/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNoteInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateNoteInDto} updateNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote: async (updateNoteInDto: UpdateNoteInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNoteInDto' is not null or undefined
            assertParamExists('editNote', 'updateNoteInDto', updateNoteInDto)
            const localVarPath = `/song/variant/notes/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNoteInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotesOfVariantAndUser: async (packGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('getNotesOfVariantAndUser', 'packGuid', packGuid)
            const localVarPath = `/song/variant/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongNotesApi - functional programming interface
 * @export
 */
export const SongNotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongNotesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddNoteToVariantInDto} addNoteToVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNoteToVariant(addNoteToVariantInDto: AddNoteToVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNoteToVariant(addNoteToVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongNotesApi.addNoteToVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteNoteInDto} deleteNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNote(deleteNoteInDto: DeleteNoteInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(deleteNoteInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongNotesApi.deleteNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateNoteInDto} updateNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNote(updateNoteInDto: UpdateNoteInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNote(updateNoteInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongNotesApi.editNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotesOfVariantAndUser(packGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNotesOfVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotesOfVariantAndUser(packGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongNotesApi.getNotesOfVariantAndUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongNotesApi - factory interface
 * @export
 */
export const SongNotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongNotesApiFp(configuration)
    return {
        /**
         * 
         * @param {AddNoteToVariantInDto} addNoteToVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteToVariant(addNoteToVariantInDto: AddNoteToVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.addNoteToVariant(addNoteToVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteNoteInDto} deleteNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(deleteNoteInDto: DeleteNoteInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteNote(deleteNoteInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateNoteInDto} updateNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote(updateNoteInDto: UpdateNoteInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.editNote(updateNoteInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotesOfVariantAndUser(packGuid: string, options?: any): AxiosPromise<GetNotesOfVariantOutDto> {
            return localVarFp.getNotesOfVariantAndUser(packGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongNotesApi - object-oriented interface
 * @export
 * @class SongNotesApi
 * @extends {BaseAPI}
 */
export class SongNotesApi extends BaseAPI {
    /**
     * 
     * @param {AddNoteToVariantInDto} addNoteToVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongNotesApi
     */
    public addNoteToVariant(addNoteToVariantInDto: AddNoteToVariantInDto, options?: RawAxiosRequestConfig) {
        return SongNotesApiFp(this.configuration).addNoteToVariant(addNoteToVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteNoteInDto} deleteNoteInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongNotesApi
     */
    public deleteNote(deleteNoteInDto: DeleteNoteInDto, options?: RawAxiosRequestConfig) {
        return SongNotesApiFp(this.configuration).deleteNote(deleteNoteInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateNoteInDto} updateNoteInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongNotesApi
     */
    public editNote(updateNoteInDto: UpdateNoteInDto, options?: RawAxiosRequestConfig) {
        return SongNotesApiFp(this.configuration).editNote(updateNoteInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongNotesApi
     */
    public getNotesOfVariantAndUser(packGuid: string, options?: RawAxiosRequestConfig) {
        return SongNotesApiFp(this.configuration).getNotesOfVariantAndUser(packGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongPublishingApi - axios parameter creator
 * @export
 */
export const SongPublishingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeywords: async (postGetKeywordsInDto: PostGetKeywordsInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGetKeywordsInDto' is not null or undefined
            assertParamExists('generateKeywords', 'postGetKeywordsInDto', postGetKeywordsInDto)
            const localVarPath = `/song/generatekeywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGetKeywordsInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalPacks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/getapprovalpacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeywords: async (postGetKeywordsInDto: PostGetKeywordsInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGetKeywordsInDto' is not null or undefined
            assertParamExists('getKeywords', 'postGetKeywordsInDto', postGetKeywordsInDto)
            const localVarPath = `/song/getkeywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGetKeywordsInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOfficialVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('publishOfficialVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/publish-official`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('publishVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectPublishApproval: async (postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendPackToApprovalInDto' is not null or undefined
            assertParamExists('rejectPublishApproval', 'postSendPackToApprovalInDto', postSendPackToApprovalInDto)
            const localVarPath = `/song/rejectPublishApproval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendPackToApprovalInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPackToApproval: async (postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendPackToApprovalInDto' is not null or undefined
            assertParamExists('sendPackToApproval', 'postSendPackToApprovalInDto', postSendPackToApprovalInDto)
            const localVarPath = `/song/sendpacktoapproval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendPackToApprovalInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('unpublishVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/unpublish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVariant: async (postVerifyVariantInDto: PostVerifyVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postVerifyVariantInDto' is not null or undefined
            assertParamExists('verifyVariant', 'postVerifyVariantInDto', postVerifyVariantInDto)
            const localVarPath = `/song/verifystatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postVerifyVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongPublishingApi - functional programming interface
 * @export
 */
export const SongPublishingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongPublishingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKeywords(postGetKeywordsInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.generateKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalPacks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicVariantPackDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalPacks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.getApprovalPacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywords(postGetKeywordsInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.getKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishOfficialVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishOfficialVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.publishOfficialVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.publishVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectPublishApproval(postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectPublishApproval(postSendPackToApprovalInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.rejectPublishApproval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPackToApproval(postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPackToApproval(postSendPackToApprovalInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.sendPackToApproval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.unpublishVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyVariant(postVerifyVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.verifyVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongPublishingApi - factory interface
 * @export
 */
export const SongPublishingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongPublishingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: any): AxiosPromise<void> {
            return localVarFp.generateKeywords(postGetKeywordsInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalPacks(options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
            return localVarFp.getApprovalPacks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: any): AxiosPromise<void> {
            return localVarFp.getKeywords(postGetKeywordsInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOfficialVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.publishOfficialVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.publishVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectPublishApproval(postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options?: any): AxiosPromise<void> {
            return localVarFp.rejectPublishApproval(postSendPackToApprovalInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPackToApproval(postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.sendPackToApproval(postSendPackToApprovalInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.unpublishVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: any): AxiosPromise<SongVariant> {
            return localVarFp.verifyVariant(postVerifyVariantInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongPublishingApi - object-oriented interface
 * @export
 * @class SongPublishingApi
 * @extends {BaseAPI}
 */
export class SongPublishingApi extends BaseAPI {
    /**
     * 
     * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public generateKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).generateKeywords(postGetKeywordsInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public getApprovalPacks(options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).getApprovalPacks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public getKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).getKeywords(postGetKeywordsInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public publishOfficialVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).publishOfficialVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public publishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).publishVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public rejectPublishApproval(postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).rejectPublishApproval(postSendPackToApprovalInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public sendPackToApproval(postSendPackToApprovalInDto: PostSendPackToApprovalInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).sendPackToApproval(postSendPackToApprovalInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public unpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).unpublishVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public verifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).verifyVariant(postVerifyVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongSearchingApi - axios parameter creator
 * @export
 */
export const SongSearchingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (searchKey: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('search', 'searchKey', searchKey)
            const localVarPath = `/song/searching/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongSearchingApi - functional programming interface
 * @export
 */
export const SongSearchingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongSearchingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(searchKey: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchSongPacksDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(searchKey, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongSearchingApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongSearchingApi - factory interface
 * @export
 */
export const SongSearchingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongSearchingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(searchKey: string, page?: number, options?: any): AxiosPromise<Array<SearchSongPacksDto>> {
            return localVarFp.search(searchKey, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongSearchingApi - object-oriented interface
 * @export
 * @class SongSearchingApi
 * @extends {BaseAPI}
 */
export class SongSearchingApi extends BaseAPI {
    /**
     * 
     * @param {string} searchKey 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongSearchingApi
     */
    public search(searchKey: string, page?: number, options?: RawAxiosRequestConfig) {
        return SongSearchingApiFp(this.configuration).search(searchKey, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongUserManagementApi - axios parameter creator
 * @export
 */
export const SongUserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserLikeToTranslation: async (addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addUserLikeToTranslationInDto' is not null or undefined
            assertParamExists('addUserLikeToTranslation', 'addUserLikeToTranslationInDto', addUserLikeToTranslationInDto)
            const localVarPath = `/song/translation-like/add-user-like-to-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserLikeToTranslationInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/translation-like/get-user-likes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserLikeFromTranslation: async (addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addUserLikeToTranslationInDto' is not null or undefined
            assertParamExists('removeUserLikeFromTranslation', 'addUserLikeToTranslationInDto', addUserLikeToTranslationInDto)
            const localVarPath = `/song/translation-like/remove-user-like-from-translation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserLikeToTranslationInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongUserManagementApi - functional programming interface
 * @export
 */
export const SongUserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongUserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserLikeToTranslation(addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTranslationLikesOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserLikeToTranslation(addUserLikeToTranslationInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongUserManagementApi.addUserLikeToTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserLikes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTranslationLikesOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLikes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongUserManagementApi.getUserLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserLikeFromTranslation(addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTranslationLikesOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserLikeFromTranslation(addUserLikeToTranslationInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongUserManagementApi.removeUserLikeFromTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongUserManagementApi - factory interface
 * @export
 */
export const SongUserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongUserManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserLikeToTranslation(addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options?: any): AxiosPromise<GetUserTranslationLikesOutDto> {
            return localVarFp.addUserLikeToTranslation(addUserLikeToTranslationInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikes(options?: any): AxiosPromise<GetUserTranslationLikesOutDto> {
            return localVarFp.getUserLikes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserLikeFromTranslation(addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options?: any): AxiosPromise<GetUserTranslationLikesOutDto> {
            return localVarFp.removeUserLikeFromTranslation(addUserLikeToTranslationInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongUserManagementApi - object-oriented interface
 * @export
 * @class SongUserManagementApi
 * @extends {BaseAPI}
 */
export class SongUserManagementApi extends BaseAPI {
    /**
     * 
     * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongUserManagementApi
     */
    public addUserLikeToTranslation(addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options?: RawAxiosRequestConfig) {
        return SongUserManagementApiFp(this.configuration).addUserLikeToTranslation(addUserLikeToTranslationInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongUserManagementApi
     */
    public getUserLikes(options?: RawAxiosRequestConfig) {
        return SongUserManagementApiFp(this.configuration).getUserLikes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongUserManagementApi
     */
    public removeUserLikeFromTranslation(addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto, options?: RawAxiosRequestConfig) {
        return SongUserManagementApiFp(this.configuration).removeUserLikeFromTranslation(addUserLikeToTranslationInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongValidationApi - axios parameter creator
 * @export
 */
export const SongValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSheetDataAndTitle: async (postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postValidateSheetDataAndTitleInDto' is not null or undefined
            assertParamExists('validateSheetDataAndTitle', 'postValidateSheetDataAndTitleInDto', postValidateSheetDataAndTitleInDto)
            const localVarPath = `/song/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postValidateSheetDataAndTitleInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongValidationApi - functional programming interface
 * @export
 */
export const SongValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongValidationApi.validateSheetDataAndTitle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongValidationApi - factory interface
 * @export
 */
export const SongValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongValidationApiFp(configuration)
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: any): AxiosPromise<ValidationResult> {
            return localVarFp.validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongValidationApi - object-oriented interface
 * @export
 * @class SongValidationApi
 * @extends {BaseAPI}
 */
export class SongValidationApi extends BaseAPI {
    /**
     * 
     * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongValidationApi
     */
    public validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: RawAxiosRequestConfig) {
        return SongValidationApiFp(this.configuration).validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamAddingApi - axios parameter creator
 * @export
 */
export const TeamAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTeamInDto} createTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTeam: async (createTeamInDto: CreateTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamInDto' is not null or undefined
            assertParamExists('createNewTeam', 'createTeamInDto', createTeamInDto)
            const localVarPath = `/submodules/teams/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamAddingApi - functional programming interface
 * @export
 */
export const TeamAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTeamInDto} createTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewTeam(createTeamInDto: CreateTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewTeam(createTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamAddingApi.createNewTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamAddingApi - factory interface
 * @export
 */
export const TeamAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamAddingApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTeamInDto} createTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTeam(createTeamInDto: CreateTeamInDto, options?: any): AxiosPromise<CreateTeamOutDto> {
            return localVarFp.createNewTeam(createTeamInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamAddingApi - object-oriented interface
 * @export
 * @class TeamAddingApi
 * @extends {BaseAPI}
 */
export class TeamAddingApi extends BaseAPI {
    /**
     * 
     * @param {CreateTeamInDto} createTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAddingApi
     */
    public createNewTeam(createTeamInDto: CreateTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamAddingApiFp(this.configuration).createNewTeam(createTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamEditingApi - axios parameter creator
 * @export
 */
export const TeamEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToTeam: async (addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPackToTeamSelectionInDto' is not null or undefined
            assertParamExists('addPackToTeam', 'addPackToTeamSelectionInDto', addPackToTeamSelectionInDto)
            const localVarPath = `/submodules/teams/selection/add/pack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPackToTeamSelectionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPlaylistToTeam: async (attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachPlaylistToTeamInDto' is not null or undefined
            assertParamExists('attachPlaylistToTeam', 'attachPlaylistToTeamInDto', attachPlaylistToTeamInDto)
            const localVarPath = `/submodules/teams/selection/attachPlaylistToTeam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachPlaylistToTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamInfo: async (changeTeamInfoInDto: ChangeTeamInfoInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeTeamInfoInDto' is not null or undefined
            assertParamExists('changeTeamInfo', 'changeTeamInfoInDto', changeTeamInfoInDto)
            const localVarPath = `/submodules/teams/changeteaminfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeTeamInfoInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamLogo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/submodules/teams/changelogo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteTeamInDto} deleteTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (deleteTeamInDto: DeleteTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTeamInDto' is not null or undefined
            assertParamExists('deleteTeam', 'deleteTeamInDto', deleteTeamInDto)
            const localVarPath = `/submodules/teams/deleteteam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditPayloadInDto} editPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPayload: async (editPayloadInDto: EditPayloadInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editPayloadInDto' is not null or undefined
            assertParamExists('editPayload', 'editPayloadInDto', editPayloadInDto)
            const localVarPath = `/submodules/teams/editpayload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPayloadInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePackFromTeam: async (addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPackToTeamSelectionInDto' is not null or undefined
            assertParamExists('removePackFromTeam', 'addPackToTeamSelectionInDto', addPackToTeamSelectionInDto)
            const localVarPath = `/submodules/teams/selection/remove/pack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPackToTeamSelectionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveTeamLogoInDto} removeTeamLogoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamLogo: async (removeTeamLogoInDto: RemoveTeamLogoInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeTeamLogoInDto' is not null or undefined
            assertParamExists('removeTeamLogo', 'removeTeamLogoInDto', removeTeamLogoInDto)
            const localVarPath = `/submodules/teams/removeLogo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeTeamLogoInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamEditingApi - functional programming interface
 * @export
 */
export const TeamEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPackToTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItemOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPackToTeam(addPackToTeamSelectionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.addPackToTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPlaylistToTeam(attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPlaylistToTeam(attachPlaylistToTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.attachPlaylistToTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTeamInfo(changeTeamInfoInDto: ChangeTeamInfoInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTeamInfo(changeTeamInfoInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.changeTeamInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTeamLogo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTeamLogo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.changeTeamLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteTeamInDto} deleteTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(deleteTeamInDto: DeleteTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(deleteTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.deleteTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditPayloadInDto} editPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPayload(editPayloadInDto: EditPayloadInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPayload(editPayloadInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.editPayload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePackFromTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePackFromTeam(addPackToTeamSelectionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.removePackFromTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveTeamLogoInDto} removeTeamLogoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamLogo(removeTeamLogoInDto: RemoveTeamLogoInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamLogo(removeTeamLogoInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.removeTeamLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamEditingApi - factory interface
 * @export
 */
export const TeamEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPackToTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: any): AxiosPromise<PlaylistItemOutDto> {
            return localVarFp.addPackToTeam(addPackToTeamSelectionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPlaylistToTeam(attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto, options?: any): AxiosPromise<void> {
            return localVarFp.attachPlaylistToTeam(attachPlaylistToTeamInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamInfo(changeTeamInfoInDto: ChangeTeamInfoInDto, options?: any): AxiosPromise<void> {
            return localVarFp.changeTeamInfo(changeTeamInfoInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTeamLogo(options?: any): AxiosPromise<void> {
            return localVarFp.changeTeamLogo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteTeamInDto} deleteTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(deleteTeamInDto: DeleteTeamInDto, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeam(deleteTeamInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditPayloadInDto} editPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPayload(editPayloadInDto: EditPayloadInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.editPayload(editPayloadInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePackFromTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.removePackFromTeam(addPackToTeamSelectionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveTeamLogoInDto} removeTeamLogoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamLogo(removeTeamLogoInDto: RemoveTeamLogoInDto, options?: any): AxiosPromise<void> {
            return localVarFp.removeTeamLogo(removeTeamLogoInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamEditingApi - object-oriented interface
 * @export
 * @class TeamEditingApi
 * @extends {BaseAPI}
 */
export class TeamEditingApi extends BaseAPI {
    /**
     * 
     * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public addPackToTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).addPackToTeam(addPackToTeamSelectionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public attachPlaylistToTeam(attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).attachPlaylistToTeam(attachPlaylistToTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public changeTeamInfo(changeTeamInfoInDto: ChangeTeamInfoInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).changeTeamInfo(changeTeamInfoInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public changeTeamLogo(options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).changeTeamLogo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteTeamInDto} deleteTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public deleteTeam(deleteTeamInDto: DeleteTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).deleteTeam(deleteTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditPayloadInDto} editPayloadInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public editPayload(editPayloadInDto: EditPayloadInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).editPayload(editPayloadInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public removePackFromTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).removePackFromTeam(addPackToTeamSelectionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveTeamLogoInDto} removeTeamLogoInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public removeTeamLogo(removeTeamLogoInDto: RemoveTeamLogoInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).removeTeamLogo(removeTeamLogoInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamEventsApi - axios parameter creator
 * @export
 */
export const TeamEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTeamEventInDto} createTeamEventInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (createTeamEventInDto: CreateTeamEventInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamEventInDto' is not null or undefined
            assertParamExists('createEvent', 'createTeamEventInDto', createTeamEventInDto)
            const localVarPath = `/teams/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamEventInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (eventGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventGuid' is not null or undefined
            assertParamExists('deleteEvent', 'eventGuid', eventGuid)
            const localVarPath = `/teams/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventGuid !== undefined) {
                localVarQueryParameter['eventGuid'] = eventGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditTeamEventInDto} editTeamEventInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEvent: async (editTeamEventInDto: EditTeamEventInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editTeamEventInDto' is not null or undefined
            assertParamExists('editEvent', 'editTeamEventInDto', editTeamEventInDto)
            const localVarPath = `/teams/events/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editTeamEventInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playlistGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByPlaylist: async (playlistGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistGuid' is not null or undefined
            assertParamExists('getEventByPlaylist', 'playlistGuid', playlistGuid)
            const localVarPath = `/teams/events/byplaylist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (playlistGuid !== undefined) {
                localVarQueryParameter['playlistGuid'] = playlistGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (teamGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamGuid' is not null or undefined
            assertParamExists('getEvents', 'teamGuid', teamGuid)
            const localVarPath = `/teams/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamGuid !== undefined) {
                localVarQueryParameter['teamGuid'] = teamGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamEventsApi - functional programming interface
 * @export
 */
export const TeamEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTeamEventInDto} createTeamEventInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(createTeamEventInDto: CreateTeamEventInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(createTeamEventInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEventsApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(eventGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(eventGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEventsApi.deleteEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditTeamEventInDto} editTeamEventInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEvent(editTeamEventInDto: EditTeamEventInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEvent(editTeamEventInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEventsApi.editEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} playlistGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventByPlaylist(playlistGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEventData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventByPlaylist(playlistGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEventsApi.getEventByPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(teamGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamEventsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(teamGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEventsApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamEventsApi - factory interface
 * @export
 */
export const TeamEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamEventsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTeamEventInDto} createTeamEventInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createTeamEventInDto: CreateTeamEventInDto, options?: any): AxiosPromise<TeamEvent> {
            return localVarFp.createEvent(createTeamEventInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventGuid: string, options?: any): AxiosPromise<TeamEvent> {
            return localVarFp.deleteEvent(eventGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditTeamEventInDto} editTeamEventInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEvent(editTeamEventInDto: EditTeamEventInDto, options?: any): AxiosPromise<TeamEvent> {
            return localVarFp.editEvent(editTeamEventInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByPlaylist(playlistGuid: string, options?: any): AxiosPromise<TeamEventData> {
            return localVarFp.getEventByPlaylist(playlistGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(teamGuid: string, options?: any): AxiosPromise<GetTeamEventsOutDto> {
            return localVarFp.getEvents(teamGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamEventsApi - object-oriented interface
 * @export
 * @class TeamEventsApi
 * @extends {BaseAPI}
 */
export class TeamEventsApi extends BaseAPI {
    /**
     * 
     * @param {CreateTeamEventInDto} createTeamEventInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEventsApi
     */
    public createEvent(createTeamEventInDto: CreateTeamEventInDto, options?: RawAxiosRequestConfig) {
        return TeamEventsApiFp(this.configuration).createEvent(createTeamEventInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEventsApi
     */
    public deleteEvent(eventGuid: string, options?: RawAxiosRequestConfig) {
        return TeamEventsApiFp(this.configuration).deleteEvent(eventGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditTeamEventInDto} editTeamEventInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEventsApi
     */
    public editEvent(editTeamEventInDto: EditTeamEventInDto, options?: RawAxiosRequestConfig) {
        return TeamEventsApiFp(this.configuration).editEvent(editTeamEventInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} playlistGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEventsApi
     */
    public getEventByPlaylist(playlistGuid: string, options?: RawAxiosRequestConfig) {
        return TeamEventsApiFp(this.configuration).getEventByPlaylist(playlistGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEventsApi
     */
    public getEvents(teamGuid: string, options?: RawAxiosRequestConfig) {
        return TeamEventsApiFp(this.configuration).getEvents(teamGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamGettingApi - axios parameter creator
 * @export
 */
export const TeamGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasBySubdomain: async (subdomain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subdomain' is not null or undefined
            assertParamExists('getAliasBySubdomain', 'subdomain', subdomain)
            const localVarPath = `/submodules/teams/aliasbysubdomain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (subdomain !== undefined) {
                localVarQueryParameter['subdomain'] = subdomain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubdomains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/submodules/teams/allsubdomains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamBasicInfo: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('getTeamBasicInfo', 'alias', alias)
            const localVarPath = `/submodules/teams/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamPayload: async (teamGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamGuid' is not null or undefined
            assertParamExists('getTeamPayload', 'teamGuid', teamGuid)
            const localVarPath = `/submodules/teams/teampayload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamGuid !== undefined) {
                localVarQueryParameter['teamGuid'] = teamGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamGettingApi - functional programming interface
 * @export
 */
export const TeamGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAliasBySubdomain(subdomain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamAliasFromSubdomainOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAliasBySubdomain(subdomain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamGettingApi.getAliasBySubdomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubdomains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllTeamSubdomainAliasesOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSubdomains(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamGettingApi.getAllSubdomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamBasicInfo(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamInfoOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamBasicInfo(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamGettingApi.getTeamBasicInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamPayload(teamGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamPayload(teamGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamGettingApi.getTeamPayload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamGettingApi - factory interface
 * @export
 */
export const TeamGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasBySubdomain(subdomain: string, options?: any): AxiosPromise<GetTeamAliasFromSubdomainOutDto> {
            return localVarFp.getAliasBySubdomain(subdomain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubdomains(options?: any): AxiosPromise<GetAllTeamSubdomainAliasesOutDto> {
            return localVarFp.getAllSubdomains(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamBasicInfo(alias: string, options?: any): AxiosPromise<GetTeamInfoOutDto> {
            return localVarFp.getTeamBasicInfo(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamPayload(teamGuid: string, options?: any): AxiosPromise<string> {
            return localVarFp.getTeamPayload(teamGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamGettingApi - object-oriented interface
 * @export
 * @class TeamGettingApi
 * @extends {BaseAPI}
 */
export class TeamGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} subdomain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamGettingApi
     */
    public getAliasBySubdomain(subdomain: string, options?: RawAxiosRequestConfig) {
        return TeamGettingApiFp(this.configuration).getAliasBySubdomain(subdomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamGettingApi
     */
    public getAllSubdomains(options?: RawAxiosRequestConfig) {
        return TeamGettingApiFp(this.configuration).getAllSubdomains(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamGettingApi
     */
    public getTeamBasicInfo(alias: string, options?: RawAxiosRequestConfig) {
        return TeamGettingApiFp(this.configuration).getTeamBasicInfo(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamGettingApi
     */
    public getTeamPayload(teamGuid: string, options?: RawAxiosRequestConfig) {
        return TeamGettingApiFp(this.configuration).getTeamPayload(teamGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamJoiningApi - axios parameter creator
 * @export
 */
export const TeamJoiningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addByEmail: async (addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addTeamMebmerByEmailInDto' is not null or undefined
            assertParamExists('addByEmail', 'addTeamMebmerByEmailInDto', addTeamMebmerByEmailInDto)
            const localVarPath = `/submodules/teams/addbyemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamMebmerByEmailInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoinCode: async (teamAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAlias' is not null or undefined
            assertParamExists('getJoinCode', 'teamAlias', teamAlias)
            const localVarPath = `/submodules/teams/joincode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamAlias !== undefined) {
                localVarQueryParameter['teamAlias'] = teamAlias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JoinTeamInDto} joinTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeam: async (joinTeamInDto: JoinTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'joinTeamInDto' is not null or undefined
            assertParamExists('joinTeam', 'joinTeamInDto', joinTeamInDto)
            const localVarPath = `/submodules/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamJoiningApi - functional programming interface
 * @export
 */
export const TeamJoiningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamJoiningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addByEmail(addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addByEmail(addTeamMebmerByEmailInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamJoiningApi.addByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJoinCode(teamAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJoinCodeOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJoinCode(teamAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamJoiningApi.getJoinCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {JoinTeamInDto} joinTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinTeam(joinTeamInDto: JoinTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JoinTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinTeam(joinTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamJoiningApi.joinTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamJoiningApi - factory interface
 * @export
 */
export const TeamJoiningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamJoiningApiFp(configuration)
    return {
        /**
         * 
         * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addByEmail(addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.addByEmail(addTeamMebmerByEmailInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJoinCode(teamAlias: string, options?: any): AxiosPromise<GetJoinCodeOutDto> {
            return localVarFp.getJoinCode(teamAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JoinTeamInDto} joinTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeam(joinTeamInDto: JoinTeamInDto, options?: any): AxiosPromise<JoinTeamOutDto> {
            return localVarFp.joinTeam(joinTeamInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamJoiningApi - object-oriented interface
 * @export
 * @class TeamJoiningApi
 * @extends {BaseAPI}
 */
export class TeamJoiningApi extends BaseAPI {
    /**
     * 
     * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamJoiningApi
     */
    public addByEmail(addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto, options?: RawAxiosRequestConfig) {
        return TeamJoiningApiFp(this.configuration).addByEmail(addTeamMebmerByEmailInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamAlias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamJoiningApi
     */
    public getJoinCode(teamAlias: string, options?: RawAxiosRequestConfig) {
        return TeamJoiningApiFp(this.configuration).getJoinCode(teamAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JoinTeamInDto} joinTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamJoiningApi
     */
    public joinTeam(joinTeamInDto: JoinTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamJoiningApiFp(this.configuration).joinTeam(joinTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamMembersApi - axios parameter creator
 * @export
 */
export const TeamMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers: async (teamAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAlias' is not null or undefined
            assertParamExists('getTeamMembers', 'teamAlias', teamAlias)
            const localVarPath = `/submodules/teams/ofteam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamAlias !== undefined) {
                localVarQueryParameter['teamAlias'] = teamAlias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/submodules/teams/ofuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserMemberOfTeam: async (teamAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAlias' is not null or undefined
            assertParamExists('isUserMemberOfTeam', 'teamAlias', teamAlias)
            const localVarPath = `/submodules/teams/isUserMemberOfTeam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamAlias !== undefined) {
                localVarQueryParameter['teamAlias'] = teamAlias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LeaveTeamInDto} leaveTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeam: async (leaveTeamInDto: LeaveTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaveTeamInDto' is not null or undefined
            assertParamExists('leaveTeam', 'leaveTeamInDto', leaveTeamInDto)
            const localVarPath = `/submodules/teams/leaveteam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetMemberRoleInDto} setMemberRoleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMemberRole: async (setMemberRoleInDto: SetMemberRoleInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setMemberRoleInDto' is not null or undefined
            assertParamExists('setMemberRole', 'setMemberRoleInDto', setMemberRoleInDto)
            const localVarPath = `/submodules/teams/setrole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setMemberRoleInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamMembersApi - functional programming interface
 * @export
 */
export const TeamMembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamMembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamMembers(teamAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamMembersOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamMembers(teamAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.getTeamMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamsOfUserOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.getTeamsOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserMemberOfTeam(teamAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsUserMemberOfTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isUserMemberOfTeam(teamAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.isUserMemberOfTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LeaveTeamInDto} leaveTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveTeam(leaveTeamInDto: LeaveTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveTeam(leaveTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.leaveTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetMemberRoleInDto} setMemberRoleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMemberRole(setMemberRoleInDto: SetMemberRoleInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMemberRole(setMemberRoleInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.setMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamMembersApi - factory interface
 * @export
 */
export const TeamMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamMembersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers(teamAlias: string, options?: any): AxiosPromise<GetTeamMembersOutDto> {
            return localVarFp.getTeamMembers(teamAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsOfUser(options?: any): AxiosPromise<GetTeamsOfUserOutDto> {
            return localVarFp.getTeamsOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserMemberOfTeam(teamAlias: string, options?: any): AxiosPromise<IsUserMemberOfTeamOutDto> {
            return localVarFp.isUserMemberOfTeam(teamAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LeaveTeamInDto} leaveTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeam(leaveTeamInDto: LeaveTeamInDto, options?: any): AxiosPromise<void> {
            return localVarFp.leaveTeam(leaveTeamInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetMemberRoleInDto} setMemberRoleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMemberRole(setMemberRoleInDto: SetMemberRoleInDto, options?: any): AxiosPromise<void> {
            return localVarFp.setMemberRole(setMemberRoleInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamMembersApi - object-oriented interface
 * @export
 * @class TeamMembersApi
 * @extends {BaseAPI}
 */
export class TeamMembersApi extends BaseAPI {
    /**
     * 
     * @param {string} teamAlias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public getTeamMembers(teamAlias: string, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).getTeamMembers(teamAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public getTeamsOfUser(options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).getTeamsOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamAlias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public isUserMemberOfTeam(teamAlias: string, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).isUserMemberOfTeam(teamAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LeaveTeamInDto} leaveTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public leaveTeam(leaveTeamInDto: LeaveTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).leaveTeam(leaveTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetMemberRoleInDto} setMemberRoleInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public setMemberRole(setMemberRoleInDto: SetMemberRoleInDto, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).setMemberRole(setMemberRoleInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamPlaylistsApi - axios parameter creator
 * @export
 */
export const TeamPlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedPlaylistsToTeam: async (teamGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamGuid' is not null or undefined
            assertParamExists('getPinnedPlaylistsToTeam', 'teamGuid', teamGuid)
            const localVarPath = `/submodules/teams/playlists/getpinnedplaylists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamGuid !== undefined) {
                localVarQueryParameter['teamGuid'] = teamGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinPlaylistToTeam: async (pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinPlaylistToTeamInDto' is not null or undefined
            assertParamExists('pinPlaylistToTeam', 'pinPlaylistToTeamInDto', pinPlaylistToTeamInDto)
            const localVarPath = `/submodules/teams/playlists/pinplaylist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pinPlaylistToTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinPlaylistFromTeam: async (pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinPlaylistToTeamInDto' is not null or undefined
            assertParamExists('unpinPlaylistFromTeam', 'pinPlaylistToTeamInDto', pinPlaylistToTeamInDto)
            const localVarPath = `/submodules/teams/playlists/unpinplaylist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pinPlaylistToTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamPlaylistsApi - functional programming interface
 * @export
 */
export const TeamPlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamPlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPinnedPlaylistsToTeam(teamGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPinnedPlaylistsToTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPinnedPlaylistsToTeam(teamGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamPlaylistsApi.getPinnedPlaylistsToTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinPlaylistToTeam(pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinPlaylistToTeam(pinPlaylistToTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamPlaylistsApi.pinPlaylistToTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpinPlaylistFromTeam(pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpinPlaylistFromTeam(pinPlaylistToTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamPlaylistsApi.unpinPlaylistFromTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamPlaylistsApi - factory interface
 * @export
 */
export const TeamPlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamPlaylistsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedPlaylistsToTeam(teamGuid: string, options?: any): AxiosPromise<GetPinnedPlaylistsToTeamOutDto> {
            return localVarFp.getPinnedPlaylistsToTeam(teamGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinPlaylistToTeam(pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options?: any): AxiosPromise<void> {
            return localVarFp.pinPlaylistToTeam(pinPlaylistToTeamInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinPlaylistFromTeam(pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options?: any): AxiosPromise<void> {
            return localVarFp.unpinPlaylistFromTeam(pinPlaylistToTeamInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamPlaylistsApi - object-oriented interface
 * @export
 * @class TeamPlaylistsApi
 * @extends {BaseAPI}
 */
export class TeamPlaylistsApi extends BaseAPI {
    /**
     * 
     * @param {string} teamGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamPlaylistsApi
     */
    public getPinnedPlaylistsToTeam(teamGuid: string, options?: RawAxiosRequestConfig) {
        return TeamPlaylistsApiFp(this.configuration).getPinnedPlaylistsToTeam(teamGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamPlaylistsApi
     */
    public pinPlaylistToTeam(pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamPlaylistsApiFp(this.configuration).pinPlaylistToTeam(pinPlaylistToTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamPlaylistsApi
     */
    public unpinPlaylistFromTeam(pinPlaylistToTeamInDto: PinPlaylistToTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamPlaylistsApiFp(this.configuration).unpinPlaylistFromTeam(pinPlaylistToTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamSongNotesApi - axios parameter creator
 * @export
 */
export const TeamSongNotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteToVariant: async (addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addTeamNoteToVariantInDto' is not null or undefined
            assertParamExists('addNoteToVariant', 'addTeamNoteToVariantInDto', addTeamNoteToVariantInDto)
            const localVarPath = `/team/song/notes/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamNoteToVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote: async (deleteTeamNoteInDto: DeleteTeamNoteInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTeamNoteInDto' is not null or undefined
            assertParamExists('deleteNote', 'deleteTeamNoteInDto', deleteTeamNoteInDto)
            const localVarPath = `/team/song/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTeamNoteInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateTeamNoteInDto} updateTeamNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote: async (updateTeamNoteInDto: UpdateTeamNoteInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTeamNoteInDto' is not null or undefined
            assertParamExists('editNote', 'updateTeamNoteInDto', updateTeamNoteInDto)
            const localVarPath = `/team/song/notes/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamNoteInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllNotesOfTeam: async (teamGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamGuid' is not null or undefined
            assertParamExists('getAllNotesOfTeam', 'teamGuid', teamGuid)
            const localVarPath = `/team/song/notes/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamGuid !== undefined) {
                localVarQueryParameter['teamGuid'] = teamGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotesOfVariantAndTeam: async (packGuid: string, teamGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('getNotesOfVariantAndTeam', 'packGuid', packGuid)
            // verify required parameter 'teamGuid' is not null or undefined
            assertParamExists('getNotesOfVariantAndTeam', 'teamGuid', teamGuid)
            const localVarPath = `/team/song/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (teamGuid !== undefined) {
                localVarQueryParameter['teamGuid'] = teamGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamSongNotesApi - functional programming interface
 * @export
 */
export const TeamSongNotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamSongNotesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNoteToVariant(addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNoteToVariant(addTeamNoteToVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamSongNotesApi.addNoteToVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNote(deleteTeamNoteInDto: DeleteTeamNoteInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(deleteTeamNoteInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamSongNotesApi.deleteNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateTeamNoteInDto} updateTeamNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNote(updateTeamNoteInDto: UpdateTeamNoteInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNote(updateTeamNoteInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamSongNotesApi.editNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllNotesOfTeam(teamGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllTeamNotesOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllNotesOfTeam(teamGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamSongNotesApi.getAllNotesOfTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotesOfVariantAndTeam(packGuid: string, teamGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNotesOfVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotesOfVariantAndTeam(packGuid, teamGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamSongNotesApi.getNotesOfVariantAndTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamSongNotesApi - factory interface
 * @export
 */
export const TeamSongNotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamSongNotesApiFp(configuration)
    return {
        /**
         * 
         * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteToVariant(addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.addNoteToVariant(addTeamNoteToVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(deleteTeamNoteInDto: DeleteTeamNoteInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteNote(deleteTeamNoteInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateTeamNoteInDto} updateTeamNoteInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote(updateTeamNoteInDto: UpdateTeamNoteInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.editNote(updateTeamNoteInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllNotesOfTeam(teamGuid: string, options?: any): AxiosPromise<GetAllTeamNotesOutDto> {
            return localVarFp.getAllNotesOfTeam(teamGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotesOfVariantAndTeam(packGuid: string, teamGuid: string, options?: any): AxiosPromise<GetNotesOfVariantOutDto> {
            return localVarFp.getNotesOfVariantAndTeam(packGuid, teamGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamSongNotesApi - object-oriented interface
 * @export
 * @class TeamSongNotesApi
 * @extends {BaseAPI}
 */
export class TeamSongNotesApi extends BaseAPI {
    /**
     * 
     * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSongNotesApi
     */
    public addNoteToVariant(addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto, options?: RawAxiosRequestConfig) {
        return TeamSongNotesApiFp(this.configuration).addNoteToVariant(addTeamNoteToVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSongNotesApi
     */
    public deleteNote(deleteTeamNoteInDto: DeleteTeamNoteInDto, options?: RawAxiosRequestConfig) {
        return TeamSongNotesApiFp(this.configuration).deleteNote(deleteTeamNoteInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateTeamNoteInDto} updateTeamNoteInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSongNotesApi
     */
    public editNote(updateTeamNoteInDto: UpdateTeamNoteInDto, options?: RawAxiosRequestConfig) {
        return TeamSongNotesApiFp(this.configuration).editNote(updateTeamNoteInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSongNotesApi
     */
    public getAllNotesOfTeam(teamGuid: string, options?: RawAxiosRequestConfig) {
        return TeamSongNotesApiFp(this.configuration).getAllNotesOfTeam(teamGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {string} teamGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSongNotesApi
     */
    public getNotesOfVariantAndTeam(packGuid: string, teamGuid: string, options?: RawAxiosRequestConfig) {
        return TeamSongNotesApiFp(this.configuration).getNotesOfVariantAndTeam(packGuid, teamGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamStatisticsApi - axios parameter creator
 * @export
 */
export const TeamStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamStatistics: async (teamGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamGuid' is not null or undefined
            assertParamExists('getTeamStatistics', 'teamGuid', teamGuid)
            const localVarPath = `/teams/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamGuid !== undefined) {
                localVarQueryParameter['teamGuid'] = teamGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamStatisticsApi - functional programming interface
 * @export
 */
export const TeamStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamStatistics(teamGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamStatisticsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamStatistics(teamGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamStatisticsApi.getTeamStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamStatisticsApi - factory interface
 * @export
 */
export const TeamStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} teamGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamStatistics(teamGuid: string, options?: any): AxiosPromise<GetTeamStatisticsOutDto> {
            return localVarFp.getTeamStatistics(teamGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamStatisticsApi - object-oriented interface
 * @export
 * @class TeamStatisticsApi
 * @extends {BaseAPI}
 */
export class TeamStatisticsApi extends BaseAPI {
    /**
     * 
     * @param {string} teamGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamStatisticsApi
     */
    public getTeamStatistics(teamGuid: string, options?: RawAxiosRequestConfig) {
        return TeamStatisticsApiFp(this.configuration).getTeamStatistics(teamGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook(options?: any): AxiosPromise<void> {
            return localVarFp.webhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookGet(options?: any): AxiosPromise<object> {
            return localVarFp.webhookGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhook(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookGet(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookGet(options).then((request) => request(this.axios, this.basePath));
    }
}



