/* tslint:disable */
/* eslint-disable */
/**
 * WorshipTool API
 * API for WorshipTool app
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig as RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddPermissionToUserInDto
 */
export interface AddPermissionToUserInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'permissionGuid': string;
}
/**
 * 
 * @export
 * @interface AddVariantToPlaylistInDto
 */
export interface AddVariantToPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'playlist': string;
}
/**
 * 
 * @export
 * @interface BaseUserInfoOutDto
 */
export interface BaseUserInfoOutDto {
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof BaseUserInfoOutDto
     */
    'role': BaseUserInfoOutDtoRoleEnum;
}

export const BaseUserInfoOutDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type BaseUserInfoOutDtoRoleEnum = typeof BaseUserInfoOutDtoRoleEnum[keyof typeof BaseUserInfoOutDtoRoleEnum];

/**
 * 
 * @export
 * @interface CSVLink
 */
export interface CSVLink {
    /**
     * 
     * @type {string}
     * @memberof CSVLink
     */
    'guid': string;
    /**
     * 
     * @type {Creator}
     * @memberof CSVLink
     */
    'creator': Creator;
    /**
     * 
     * @type {number}
     * @memberof CSVLink
     */
    'type': CSVLinkTypeEnum;
    /**
     * 
     * @type {SongVariant}
     * @memberof CSVLink
     */
    'variant': SongVariant;
}

export const CSVLinkTypeEnum = {
    NUMBER_0: 0
} as const;

export type CSVLinkTypeEnum = typeof CSVLinkTypeEnum[keyof typeof CSVLinkTypeEnum];

/**
 * 
 * @export
 * @interface CreatePlaylistInDto
 */
export interface CreatePlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface Creator
 */
export interface Creator {
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'name': string;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof Creator
     */
    'links': Array<CSVLink>;
}
/**
 * 
 * @export
 * @interface CreatorDTO
 */
export interface CreatorDTO {
    /**
     * 
     * @type {string}
     * @memberof CreatorDTO
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreatorDTO
     */
    'type': CreatorDTOTypeEnum;
}

export const CreatorDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type CreatorDTOTypeEnum = typeof CreatorDTOTypeEnum[keyof typeof CreatorDTOTypeEnum];

/**
 * 
 * @export
 * @interface EditVariantOutDto
 */
export interface EditVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof EditVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof EditVariantOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface GetGroupInfoResult
 */
export interface GetGroupInfoResult {
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'selection': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface GetGroupListItem
 */
export interface GetGroupListItem {
    /**
     * 
     * @type {string}
     * @memberof GetGroupListItem
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupListItem
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetGroupsCountResult
 */
export interface GetGroupsCountResult {
    /**
     * 
     * @type {number}
     * @memberof GetGroupsCountResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetOrCreatePermissionInDto
 */
export interface GetOrCreatePermissionInDto {
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetPlaylistsResult
 */
export interface GetPlaylistsResult {
    /**
     * 
     * @type {Array<PlaylistData>}
     * @memberof GetPlaylistsResult
     */
    'playlists': Array<PlaylistData>;
}
/**
 * 
 * @export
 * @interface GetRecommendedSongsOutDto
 */
export interface GetRecommendedSongsOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetRecommendedSongsOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface GetSearchInPlaylistResult
 */
export interface GetSearchInPlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof GetSearchInPlaylistResult
     */
    'guid': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof GetSearchInPlaylistResult
     */
    'items': Array<PlaylistItemOutDto>;
}
/**
 * 
 * @export
 * @interface GetSongDataOutDto
 */
export interface GetSongDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'mainTitle': string;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof GetSongDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {Array<SongDataVariant>}
     * @memberof GetSongDataOutDto
     */
    'variants': Array<SongDataVariant>;
    /**
     * 
     * @type {Array<SongDataMedia>}
     * @memberof GetSongDataOutDto
     */
    'media': Array<SongDataMedia>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSongDataOutDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetUserPermissionOutDto
 */
export interface GetUserPermissionOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetVariantsOfUserOutDto
 */
export interface GetVariantsOfUserOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetVariantsOfUserOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {Playlist}
     * @memberof Group
     */
    'selection': Playlist;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface JwtResult
 */
export interface JwtResult {
    /**
     * 
     * @type {LoginUserItemResult}
     * @memberof JwtResult
     */
    'user': LoginUserItemResult;
    /**
     * 
     * @type {string}
     * @memberof JwtResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ListSongData
 */
export interface ListSongData {
    /**
     * 
     * @type {string}
     * @memberof ListSongData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof ListSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ListSongData
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface LoginInputData
 */
export interface LoginInputData {
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {LoginUserItemResult}
     * @memberof LoginResult
     */
    'user': LoginUserItemResult;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LoginUserItemResult
 */
export interface LoginUserItemResult {
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof LoginUserItemResult
     */
    'role': LoginUserItemResultRoleEnum;
}

export const LoginUserItemResultRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type LoginUserItemResultRoleEnum = typeof LoginUserItemResultRoleEnum[keyof typeof LoginUserItemResultRoleEnum];

/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'guid': string;
    /**
     * 
     * @type {Song}
     * @memberof Media
     */
    'song': Song;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'type': MediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'url': string;
}

export const MediaTypeEnum = {
    NUMBER_0: 0
} as const;

export type MediaTypeEnum = typeof MediaTypeEnum[keyof typeof MediaTypeEnum];

/**
 * 
 * @export
 * @interface NewSongDataCreator
 */
export interface NewSongDataCreator {
    /**
     * 
     * @type {number}
     * @memberof NewSongDataCreator
     */
    'type': NewSongDataCreatorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NewSongDataCreator
     */
    'name': string;
}

export const NewSongDataCreatorTypeEnum = {
    NUMBER_0: 0
} as const;

export type NewSongDataCreatorTypeEnum = typeof NewSongDataCreatorTypeEnum[keyof typeof NewSongDataCreatorTypeEnum];

/**
 * 
 * @export
 * @interface NewSongDataProcessResult
 */
export interface NewSongDataProcessResult {
    /**
     * 
     * @type {string}
     * @memberof NewSongDataProcessResult
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NewSongDataProcessResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof NewSongDataProcessResult
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface ParserSongData
 */
export interface ParserSongData {
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ParserSongDataResult
 */
export interface ParserSongDataResult {
    /**
     * 
     * @type {Array<ParserSongData>}
     * @memberof ParserSongDataResult
     */
    'sheets': Array<ParserSongData>;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'payload'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Permission
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof Playlist
     */
    'items': Array<PlaylistItem>;
    /**
     * 
     * @type {User}
     * @memberof Playlist
     */
    'owner': User;
    /**
     * 
     * @type {boolean}
     * @memberof Playlist
     */
    'isSelection': boolean;
}
/**
 * 
 * @export
 * @interface PlaylistData
 */
export interface PlaylistData {
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PlaylistDataOutDto
 */
export interface PlaylistDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof PlaylistDataOutDto
     */
    'items': Array<PlaylistItemOutDto>;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'ownerGuid': string;
}
/**
 * 
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {object}
     * @memberof PlaylistItem
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'order': number;
    /**
     * 
     * @type {UrlAlias}
     * @memberof PlaylistItem
     */
    'alias': UrlAlias;
    /**
     * 
     * @type {Playlist}
     * @memberof PlaylistItem
     */
    'playlist': Playlist;
}
/**
 * 
 * @export
 * @interface PlaylistItemOutDto
 */
export interface PlaylistItemOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'toneKey': string;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItemOutDto
     */
    'order': number;
    /**
     * 
     * @type {SongVariantDataOutDto}
     * @memberof PlaylistItemOutDto
     */
    'variant': SongVariantDataOutDto;
}
/**
 * 
 * @export
 * @interface PostAddSongDataBody
 */
export interface PostAddSongDataBody {
    /**
     * 
     * @type {string}
     * @memberof PostAddSongDataBody
     */
    'songGuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAddSongDataBody
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAddSongDataBody
     */
    'sheetData'?: string;
    /**
     * 
     * @type {SongDataSource}
     * @memberof PostAddSongDataBody
     */
    'source'?: SongDataSource;
    /**
     * 
     * @type {Array<SongDataMedia>}
     * @memberof PostAddSongDataBody
     */
    'media'?: Array<SongDataMedia>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostAddSongDataBody
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<NewSongDataCreator>}
     * @memberof PostAddSongDataBody
     */
    'creators'?: Array<NewSongDataCreator>;
}
/**
 * 
 * @export
 * @interface PostAddSubUrlDomainDto
 */
export interface PostAddSubUrlDomainDto {
    /**
     * 
     * @type {string}
     * @memberof PostAddSubUrlDomainDto
     */
    'page': string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyInDto
 */
export interface PostCreateCopyInDto {
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyInDto
     */
    'variantGuid': string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyOutDto
 */
export interface PostCreateCopyOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateCopyOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface PostCreateGroupBody
 */
export interface PostCreateGroupBody {
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupBody
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface PostCreateGroupResult
 */
export interface PostCreateGroupResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'selection': string;
}
/**
 * 
 * @export
 * @interface PostCreatePlaylistResult
 */
export interface PostCreatePlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreatePlaylistResult
     */
    'guid': string;
}
/**
 * 
 * @export
 * @interface PostEditVariantInDto
 */
export interface PostEditVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'variantAlias': string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'sheetData'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface PostGoogleLoginBody
 */
export interface PostGoogleLoginBody {
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'userToken': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface PostProcessSourceLoopDto
 */
export interface PostProcessSourceLoopDto {
    /**
     * 
     * @type {number}
     * @memberof PostProcessSourceLoopDto
     */
    'time': number;
}
/**
 * 
 * @export
 * @interface PostProcessSubUrlDto
 */
export interface PostProcessSubUrlDto {
    /**
     * 
     * @type {string}
     * @memberof PostProcessSubUrlDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PostSendFeedbackBody
 */
export interface PostSendFeedbackBody {
    /**
     * 
     * @type {string}
     * @memberof PostSendFeedbackBody
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendFeedbackBody
     */
    'userName'?: string;
}
/**
 * 
 * @export
 * @interface PostSendMessageBody
 */
export interface PostSendMessageBody {
    /**
     * 
     * @type {string}
     * @memberof PostSendMessageBody
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostSubUrlLoopDto
 */
export interface PostSubUrlLoopDto {
    /**
     * 
     * @type {number}
     * @memberof PostSubUrlLoopDto
     */
    'time': number;
}
/**
 * 
 * @export
 * @interface RenamePlaylistInDto
 */
export interface RenamePlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistInDto
 */
export interface ReorderPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {Array<ReorderPlaylistItem>}
     * @memberof ReorderPlaylistInDto
     */
    'items': Array<ReorderPlaylistItem>;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistItem
 */
export interface ReorderPlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof ReorderPlaylistItem
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface SetGroupPayloadInDto
 */
export interface SetGroupPayloadInDto {
    /**
     * 
     * @type {string}
     * @memberof SetGroupPayloadInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SetGroupPayloadInDto
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface SignUpInputData
 */
export interface SignUpInputData {
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'guid': string;
    /**
     * 
     * @type {SongTitle}
     * @memberof Song
     */
    'mainTitle': SongTitle;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof Song
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Array<Media>}
     * @memberof Song
     */
    'media': Array<Media>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Song
     */
    'tags': Array<Tag>;
}
/**
 * 
 * @export
 * @interface SongDataCreator
 */
export interface SongDataCreator {
    /**
     * 
     * @type {string}
     * @memberof SongDataCreator
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SongDataCreator
     */
    'type': SongDataCreatorTypeEnum;
}

export const SongDataCreatorTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataCreatorTypeEnum = typeof SongDataCreatorTypeEnum[keyof typeof SongDataCreatorTypeEnum];

/**
 * 
 * @export
 * @interface SongDataMedia
 */
export interface SongDataMedia {
    /**
     * 
     * @type {number}
     * @memberof SongDataMedia
     */
    'type': SongDataMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataMedia
     */
    'url': string;
}

export const SongDataMediaTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataMediaTypeEnum = typeof SongDataMediaTypeEnum[keyof typeof SongDataMediaTypeEnum];

/**
 * 
 * @export
 * @interface SongDataSource
 */
export interface SongDataSource {
    /**
     * 
     * @type {number}
     * @memberof SongDataSource
     */
    'type': SongDataSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataSource
     */
    'value': string;
}

export const SongDataSourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataSourceTypeEnum = typeof SongDataSourceTypeEnum[keyof typeof SongDataSourceTypeEnum];

/**
 * 
 * @export
 * @interface SongDataVariant
 */
export interface SongDataVariant {
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'songGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongDataVariant
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'createdByGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {Array<SourceDTO>}
     * @memberof SongDataVariant
     */
    'sources': Array<SourceDTO>;
    /**
     * 
     * @type {Array<CreatorDTO>}
     * @memberof SongDataVariant
     */
    'creators': Array<CreatorDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongDataVariant
     */
    'createdType': SongDataVariantCreatedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'alias': string;
}

export const SongDataVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongDataVariantCreatedTypeEnum = typeof SongDataVariantCreatedTypeEnum[keyof typeof SongDataVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongTitle
 */
export interface SongTitle {
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'searchValue': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongTitle
     */
    'variant': SongVariant;
}
/**
 * 
 * @export
 * @interface SongVariant
 */
export interface SongVariant {
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'searchValue': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {object}
     * @memberof SongVariant
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'type'?: SongVariantTypeEnum;
    /**
     * 
     * @type {SongTitle}
     * @memberof SongVariant
     */
    'prefferedTitle': SongTitle;
    /**
     * 
     * @type {Array<SongTitle>}
     * @memberof SongVariant
     */
    'titles': Array<SongTitle>;
    /**
     * 
     * @type {Song}
     * @memberof SongVariant
     */
    'song': Song;
    /**
     * 
     * @type {User}
     * @memberof SongVariant
     */
    'createdBy': User;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof SongVariant
     */
    'links': Array<CSVLink>;
    /**
     * 
     * @type {Array<Source>}
     * @memberof SongVariant
     */
    'sources': Array<Source>;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'createdType': SongVariantCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariant
     */
    'children': Array<SongVariant>;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariant
     */
    'parent': SongVariant;
}

export const SongVariantTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SongVariantTypeEnum = typeof SongVariantTypeEnum[keyof typeof SongVariantTypeEnum];
export const SongVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantCreatedTypeEnum = typeof SongVariantCreatedTypeEnum[keyof typeof SongVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongVariantDataOutDto
 */
export interface SongVariantDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongVariantDataOutDto
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'createdBy': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariantDataOutDto
     */
    'createdType': SongVariantDataOutDtoCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongDataSource>}
     * @memberof SongVariantDataOutDto
     */
    'sources': Array<SongDataSource>;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof SongVariantDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'alias': string;
}

export const SongVariantDataOutDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantDataOutDtoCreatedTypeEnum = typeof SongVariantDataOutDtoCreatedTypeEnum[keyof typeof SongVariantDataOutDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof Source
     */
    'type': SourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'value': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof Source
     */
    'variant': SongVariant;
}

export const SourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceTypeEnum = typeof SourceTypeEnum[keyof typeof SourceTypeEnum];

/**
 * 
 * @export
 * @interface SourceDTO
 */
export interface SourceDTO {
    /**
     * 
     * @type {number}
     * @memberof SourceDTO
     */
    'type': SourceDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDTO
     */
    'value': string;
}

export const SourceDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceDTOTypeEnum = typeof SourceDTOTypeEnum[keyof typeof SourceDTOTypeEnum];

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'guid': string;
    /**
     * 
     * @type {Array<Song>}
     * @memberof Tag
     */
    'songs': Array<Song>;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TransposePlaylistItemInDto
 */
export interface TransposePlaylistItemInDto {
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UrlAlias
 */
export interface UrlAlias {
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof UrlAlias
     */
    'type': UrlAliasTypeEnum;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof UrlAlias
     */
    'playlistItems': Array<PlaylistItem>;
}

export const UrlAliasTypeEnum = {
    NUMBER_0: 0
} as const;

export type UrlAliasTypeEnum = typeof UrlAliasTypeEnum[keyof typeof UrlAliasTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'loginType': UserLoginTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googleId': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof User
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof User
     */
    'playlists': Array<Playlist>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof User
     */
    'permissions': Array<Permission>;
}

export const UserLoginTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UserLoginTypeEnum = typeof UserLoginTypeEnum[keyof typeof UserLoginTypeEnum];
export const UserRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetUserGuidFromEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authControllerGetUserGuidFromEmail', 'email', email)
            const localVarPath = `/auth/guidfromemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginInputData: LoginInputData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInputData' is not null or undefined
            assertParamExists('authControllerLogin', 'loginInputData', loginInputData)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('authControllerLoginWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInputData} signUpInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signUpInputData: SignUpInputData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpInputData' is not null or undefined
            assertParamExists('authControllerSignup', 'signUpInputData', signUpInputData)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignupWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('authControllerSignupWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/signup/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetUserGuidFromEmail(email, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerGetUserGuidFromEmail']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginInputData: LoginInputData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginInputData, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerLogin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithGoogle(postGoogleLoginBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerLoginWithGoogle']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInputData} signUpInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signUpInputData: SignUpInputData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signUpInputData, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerSignup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignupWithGoogle(postGoogleLoginBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerSignupWithGoogle']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetUserGuidFromEmail(email: string, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerGetUserGuidFromEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginInputData: LoginInputData, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.authControllerLogin(loginInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerLoginWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInputData} signUpInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signUpInputData: SignUpInputData, options?: any): AxiosPromise<boolean> {
            return localVarFp.authControllerSignup(signUpInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerSignupWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetUserGuidFromEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using email and password.
     * @summary Logs in the user using email and password.
     * @param {LoginInputData} loginInputData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginInputData: LoginInputData, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using Google.
     * @summary Logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLoginWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up using email and password.
     * @summary Signs up the user using email and password.
     * @param {SignUpInputData} signUpInputData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignup(signUpInputData: SignUpInputData, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(signUpInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
     * @summary Signs up or logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignupWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMonitorControllerRoot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monitor/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusMonitorControllerRoot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusMonitorControllerRoot(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.statusMonitorControllerRoot']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMonitorControllerRoot(options?: any): AxiosPromise<void> {
            return localVarFp.statusMonitorControllerRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statusMonitorControllerRoot(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statusMonitorControllerRoot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainApprovalApi - axios parameter creator
 * @export
 */
export const DomainApprovalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainApprovalControllerSendNextApproval: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/approval/sendApproval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainApprovalApi - functional programming interface
 * @export
 */
export const DomainApprovalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainApprovalApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainApprovalControllerSendNextApproval(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainApprovalControllerSendNextApproval(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainApprovalApi.domainApprovalControllerSendNextApproval']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DomainApprovalApi - factory interface
 * @export
 */
export const DomainApprovalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainApprovalApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainApprovalControllerSendNextApproval(options?: any): AxiosPromise<boolean> {
            return localVarFp.domainApprovalControllerSendNextApproval(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainApprovalApi - object-oriented interface
 * @export
 * @class DomainApprovalApi
 * @extends {BaseAPI}
 */
export class DomainApprovalApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApprovalApi
     */
    public domainApprovalControllerSendNextApproval(options?: RawAxiosRequestConfig) {
        return DomainApprovalApiFp(this.configuration).domainApprovalControllerSendNextApproval(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GetterApi - axios parameter creator
 * @export
 */
export const GetterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostAddSubUrlDomainDto} postAddSubUrlDomainDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerAddSubUrlPage: async (postAddSubUrlDomainDto: PostAddSubUrlDomainDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAddSubUrlDomainDto' is not null or undefined
            assertParamExists('domainExploreControllerAddSubUrlPage', 'postAddSubUrlDomainDto', postAddSubUrlDomainDto)
            const localVarPath = `/getter/explore/suburl/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAddSubUrlDomainDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerGetDomainCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/explore/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerGetDomainExplore: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('domainExploreControllerGetDomainExplore', 'url', url)
            const localVarPath = `/getter/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostProcessSubUrlDto} postProcessSubUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerProcess: async (postProcessSubUrlDto: PostProcessSubUrlDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postProcessSubUrlDto' is not null or undefined
            assertParamExists('domainExploreControllerProcess', 'postProcessSubUrlDto', postProcessSubUrlDto)
            const localVarPath = `/getter/explore/suburl/process`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postProcessSubUrlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostSubUrlLoopDto} postSubUrlLoopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerSubUrlLoop: async (postSubUrlLoopDto: PostSubUrlLoopDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSubUrlLoopDto' is not null or undefined
            assertParamExists('domainExploreControllerSubUrlLoop', 'postSubUrlLoopDto', postSubUrlLoopDto)
            const localVarPath = `/getter/explore/suburl/loop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSubUrlLoopDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainSearchControllerSearch: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterControllerActivate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterControllerDeactivate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterControllerIsActive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/isactive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostProcessSourceLoopDto} postProcessSourceLoopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourceProcessControllerProcessLoop: async (postProcessSourceLoopDto: PostProcessSourceLoopDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postProcessSourceLoopDto' is not null or undefined
            assertParamExists('sourceProcessControllerProcessLoop', 'postProcessSourceLoopDto', postProcessSourceLoopDto)
            const localVarPath = `/getter/source/process-loop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postProcessSourceLoopDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourceProcessControllerProcessNextSource: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getter/source/process-next`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetterApi - functional programming interface
 * @export
 */
export const GetterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostAddSubUrlDomainDto} postAddSubUrlDomainDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainExploreControllerAddSubUrlPage(postAddSubUrlDomainDto: PostAddSubUrlDomainDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainExploreControllerAddSubUrlPage(postAddSubUrlDomainDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.domainExploreControllerAddSubUrlPage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainExploreControllerGetDomainCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainExploreControllerGetDomainCheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.domainExploreControllerGetDomainCheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainExploreControllerGetDomainExplore(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainExploreControllerGetDomainExplore(url, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.domainExploreControllerGetDomainExplore']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {PostProcessSubUrlDto} postProcessSubUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainExploreControllerProcess(postProcessSubUrlDto: PostProcessSubUrlDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainExploreControllerProcess(postProcessSubUrlDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.domainExploreControllerProcess']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {PostSubUrlLoopDto} postSubUrlLoopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainExploreControllerSubUrlLoop(postSubUrlLoopDto: PostSubUrlLoopDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainExploreControllerSubUrlLoop(postSubUrlLoopDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.domainExploreControllerSubUrlLoop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainSearchControllerSearch(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainSearchControllerSearch(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.domainSearchControllerSearch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getterControllerActivate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getterControllerActivate(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.getterControllerActivate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getterControllerDeactivate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getterControllerDeactivate(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.getterControllerDeactivate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getterControllerIsActive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getterControllerIsActive(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.getterControllerIsActive']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {PostProcessSourceLoopDto} postProcessSourceLoopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sourceProcessControllerProcessLoop(postProcessSourceLoopDto: PostProcessSourceLoopDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sourceProcessControllerProcessLoop(postProcessSourceLoopDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.sourceProcessControllerProcessLoop']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sourceProcessControllerProcessNextSource(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sourceProcessControllerProcessNextSource(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GetterApi.sourceProcessControllerProcessNextSource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GetterApi - factory interface
 * @export
 */
export const GetterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetterApiFp(configuration)
    return {
        /**
         * 
         * @param {PostAddSubUrlDomainDto} postAddSubUrlDomainDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerAddSubUrlPage(postAddSubUrlDomainDto: PostAddSubUrlDomainDto, options?: any): AxiosPromise<object> {
            return localVarFp.domainExploreControllerAddSubUrlPage(postAddSubUrlDomainDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerGetDomainCheck(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.domainExploreControllerGetDomainCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerGetDomainExplore(url: string, options?: any): AxiosPromise<object> {
            return localVarFp.domainExploreControllerGetDomainExplore(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostProcessSubUrlDto} postProcessSubUrlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerProcess(postProcessSubUrlDto: PostProcessSubUrlDto, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.domainExploreControllerProcess(postProcessSubUrlDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostSubUrlLoopDto} postSubUrlLoopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainExploreControllerSubUrlLoop(postSubUrlLoopDto: PostSubUrlLoopDto, options?: any): AxiosPromise<string> {
            return localVarFp.domainExploreControllerSubUrlLoop(postSubUrlLoopDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainSearchControllerSearch(options?: any): AxiosPromise<void> {
            return localVarFp.domainSearchControllerSearch(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterControllerActivate(options?: any): AxiosPromise<boolean> {
            return localVarFp.getterControllerActivate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterControllerDeactivate(options?: any): AxiosPromise<boolean> {
            return localVarFp.getterControllerDeactivate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterControllerIsActive(options?: any): AxiosPromise<boolean> {
            return localVarFp.getterControllerIsActive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostProcessSourceLoopDto} postProcessSourceLoopDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourceProcessControllerProcessLoop(postProcessSourceLoopDto: PostProcessSourceLoopDto, options?: any): AxiosPromise<void> {
            return localVarFp.sourceProcessControllerProcessLoop(postProcessSourceLoopDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourceProcessControllerProcessNextSource(options?: any): AxiosPromise<boolean> {
            return localVarFp.sourceProcessControllerProcessNextSource(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetterApi - object-oriented interface
 * @export
 * @class GetterApi
 * @extends {BaseAPI}
 */
export class GetterApi extends BaseAPI {
    /**
     * 
     * @param {PostAddSubUrlDomainDto} postAddSubUrlDomainDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public domainExploreControllerAddSubUrlPage(postAddSubUrlDomainDto: PostAddSubUrlDomainDto, options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).domainExploreControllerAddSubUrlPage(postAddSubUrlDomainDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public domainExploreControllerGetDomainCheck(options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).domainExploreControllerGetDomainCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} url 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public domainExploreControllerGetDomainExplore(url: string, options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).domainExploreControllerGetDomainExplore(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostProcessSubUrlDto} postProcessSubUrlDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public domainExploreControllerProcess(postProcessSubUrlDto: PostProcessSubUrlDto, options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).domainExploreControllerProcess(postProcessSubUrlDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostSubUrlLoopDto} postSubUrlLoopDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public domainExploreControllerSubUrlLoop(postSubUrlLoopDto: PostSubUrlLoopDto, options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).domainExploreControllerSubUrlLoop(postSubUrlLoopDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public domainSearchControllerSearch(options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).domainSearchControllerSearch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public getterControllerActivate(options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).getterControllerActivate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public getterControllerDeactivate(options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).getterControllerDeactivate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public getterControllerIsActive(options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).getterControllerIsActive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostProcessSourceLoopDto} postProcessSourceLoopDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public sourceProcessControllerProcessLoop(postProcessSourceLoopDto: PostProcessSourceLoopDto, options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).sourceProcessControllerProcessLoop(postProcessSourceLoopDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetterApi
     */
    public sourceProcessControllerProcessNextSource(options?: RawAxiosRequestConfig) {
        return GetterApiFp(this.configuration).sourceProcessControllerProcessNextSource(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup: async (postCreateGroupBody: PostCreateGroupBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateGroupBody' is not null or undefined
            assertParamExists('groupControllerCreateGroup', 'postCreateGroupBody', postCreateGroupBody)
            const localVarPath = `/group/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateGroupBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup: async (guid?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupInfo: async (guid?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupSelection: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('groupControllerGetGroupSelection', 'guid', guid)
            const localVarPath = `/group/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerSearchGroups: async (searchString: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchString' is not null or undefined
            assertParamExists('groupControllerSearchGroups', 'searchString', searchString)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroupPayload: async (setGroupPayloadInDto: SetGroupPayloadInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setGroupPayloadInDto' is not null or undefined
            assertParamExists('groupControllerUpdateGroupPayload', 'setGroupPayloadInDto', setGroupPayloadInDto)
            const localVarPath = `/payload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGroupPayloadInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateGroupResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerCreateGroup(postCreateGroupBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerCreateGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerDeleteGroup(guid?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerDeleteGroup(guid, name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerDeleteGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupsCountResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetCount(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerGetCount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupInfo(guid?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupInfoResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupInfo(guid, name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerGetGroupInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupSelection(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupSelection(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerGetGroupSelection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGroupListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupsList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerGetGroupsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerSearchGroups(searchString: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerSearchGroups(searchString, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerSearchGroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerUpdateGroupPayload(setGroupPayloadInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupApi.groupControllerUpdateGroupPayload']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: any): AxiosPromise<PostCreateGroupResult> {
            return localVarFp.groupControllerCreateGroup(postCreateGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup(guid?: string, name?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.groupControllerDeleteGroup(guid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetCount(options?: any): AxiosPromise<GetGroupsCountResult> {
            return localVarFp.groupControllerGetCount(options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupInfo(guid?: string, name?: string, options?: any): AxiosPromise<GetGroupInfoResult> {
            return localVarFp.groupControllerGetGroupInfo(guid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupSelection(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.groupControllerGetGroupSelection(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupsList(options?: any): AxiosPromise<Array<GetGroupListItem>> {
            return localVarFp.groupControllerGetGroupsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerSearchGroups(searchString: string, options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.groupControllerSearchGroups(searchString, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: any): AxiosPromise<void> {
            return localVarFp.groupControllerUpdateGroupPayload(setGroupPayloadInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * The function creates a new group. Only admin users can access this endpoint.
     * @summary Creates a new group.
     * @param {PostCreateGroupBody} postCreateGroupBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerCreateGroup(postCreateGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function deletes a group. Only admin users can access this endpoint.
     * @summary Deletes a group.
     * @param {string} [guid] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerDeleteGroup(guid?: string, name?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerDeleteGroup(guid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns number of all groups.
     * @summary Returns number of all groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetCount(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns information about a group.
     * @summary Returns information about a group.
     * @param {string} [guid] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupInfo(guid?: string, name?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupInfo(guid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns the selection of a group.
     * @summary Returns the selection of a group.
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupSelection(guid: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupSelection(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns a list of all groups. Only admin users can access this endpoint.
     * @summary Returns a list of all groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupsList(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchString 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerSearchGroups(searchString: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerSearchGroups(searchString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerUpdateGroupPayload(setGroupPayloadInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessengerApi - axios parameter creator
 * @export
 */
export const MessengerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostFeedback: async (postSendFeedbackBody: PostSendFeedbackBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendFeedbackBody' is not null or undefined
            assertParamExists('messengerControllerPostFeedback', 'postSendFeedbackBody', postSendFeedbackBody)
            const localVarPath = `/sendfeedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendFeedbackBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.   message has been sent.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostMessage: async (postSendMessageBody: PostSendMessageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendMessageBody' is not null or undefined
            assertParamExists('messengerControllerPostMessage', 'postSendMessageBody', postSendMessageBody)
            const localVarPath = `/sendmessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendMessageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessengerApi - functional programming interface
 * @export
 */
export const MessengerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessengerApiAxiosParamCreator(configuration)
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerPostFeedback(postSendFeedbackBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MessengerApi.messengerControllerPostFeedback']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.   message has been sent.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerPostMessage(postSendMessageBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MessengerApi.messengerControllerPostMessage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MessengerApi - factory interface
 * @export
 */
export const MessengerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessengerApiFp(configuration)
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerPostFeedback(postSendFeedbackBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.   message has been sent.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerPostMessage(postSendMessageBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessengerApi - object-oriented interface
 * @export
 * @class MessengerApi
 * @extends {BaseAPI}
 */
export class MessengerApi extends BaseAPI {
    /**
     * Handles the HTTP POST request for sending feedback.
     * @summary Sends a feedback to the messenger.
     * @param {PostSendFeedbackBody} postSendFeedbackBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerPostFeedback(postSendFeedbackBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function sends a message using the messenger service and returns a success message if the message is not empty.   message has been sent.
     * @summary Sends a message to the messenger.
     * @param {PostSendMessageBody} postSendMessageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerPostMessage(postSendMessageBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('permissionControllerAddPermissionToUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetAllUsersWithPermission: async (type: string, payload?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('permissionControllerGetAllUsersWithPermission', 'type', type)
            const localVarPath = `/permissions/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (payload !== undefined) {
                localVarQueryParameter['payload'] = payload;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetOrAddPermission: async (getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOrCreatePermissionInDto' is not null or undefined
            assertParamExists('permissionControllerGetOrAddPermission', 'getOrCreatePermissionInDto', getOrCreatePermissionInDto)
            const localVarPath = `/permissions/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrCreatePermissionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetUserPermissions: async (userGuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userGuid !== undefined) {
                localVarQueryParameter['userGuid'] = userGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('permissionControllerRemovePermissionFromUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerAddPermissionToUser(addPermissionToUserInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PermissionsApi.permissionControllerAddPermissionToUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseUserInfoOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetAllUsersWithPermission(type, payload, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PermissionsApi.permissionControllerGetAllUsersWithPermission']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PermissionsApi.permissionControllerGetOrAddPermission']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserPermissionOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetUserPermissions(userGuid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PermissionsApi.permissionControllerGetUserPermissions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PermissionsApi.permissionControllerRemovePermissionFromUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerAddPermissionToUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: any): AxiosPromise<Array<BaseUserInfoOutDto>> {
            return localVarFp.permissionControllerGetAllUsersWithPermission(type, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetUserPermissions(userGuid?: string, options?: any): AxiosPromise<Array<GetUserPermissionOutDto>> {
            return localVarFp.permissionControllerGetUserPermissions(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerAddPermissionToUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} type 
     * @param {string} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetAllUsersWithPermission(type, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userGuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetUserPermissions(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistEditingApi - axios parameter creator
 * @export
 */
export const PlaylistEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerAddVariantToPlaylist: async (addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addVariantToPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerAddVariantToPlaylist', 'addVariantToPlaylistInDto', addVariantToPlaylistInDto)
            const localVarPath = `/playlist/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVariantToPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePlaylistInDto} createPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerCreatePlaylist: async (createPlaylistInDto: CreatePlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerCreatePlaylist', 'createPlaylistInDto', createPlaylistInDto)
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerDeletePlaylist: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('playlistEditingControllerDeletePlaylist', 'guid', guid)
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRemoveVariantFromPlaylistDelete: async (alias: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('playlistEditingControllerRemoveVariantFromPlaylistDelete', 'alias', alias)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistEditingControllerRemoveVariantFromPlaylistDelete', 'playlist', playlist)
            const localVarPath = `/playlist/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRenamePlaylist: async (renamePlaylistInDto: RenamePlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renamePlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerRenamePlaylist', 'renamePlaylistInDto', renamePlaylistInDto)
            const localVarPath = `/playlist/rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renamePlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerReorderPlaylist: async (reorderPlaylistInDto: ReorderPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reorderPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerReorderPlaylist', 'reorderPlaylistInDto', reorderPlaylistInDto)
            const localVarPath = `/playlist/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerTransposePlaylistItem: async (transposePlaylistItemInDto: TransposePlaylistItemInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transposePlaylistItemInDto' is not null or undefined
            assertParamExists('playlistEditingControllerTransposePlaylistItem', 'transposePlaylistItemInDto', transposePlaylistItemInDto)
            const localVarPath = `/playlist/transpose`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transposePlaylistItemInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistEditingApi - functional programming interface
 * @export
 */
export const PlaylistEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerAddVariantToPlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {CreatePlaylistInDto} createPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerCreatePlaylist(createPlaylistInDto: CreatePlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreatePlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerCreatePlaylist(createPlaylistInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerCreatePlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerDeletePlaylist(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerDeletePlaylist(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerDeletePlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRemoveVariantFromPlaylistDelete(alias: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRemoveVariantFromPlaylistDelete(alias, playlist, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRemoveVariantFromPlaylistDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRenamePlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerReorderPlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerTransposePlaylistItem']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PlaylistEditingApi - factory interface
 * @export
 */
export const PlaylistEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: any): AxiosPromise<PlaylistItem> {
            return localVarFp.playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePlaylistInDto} createPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerCreatePlaylist(createPlaylistInDto: CreatePlaylistInDto, options?: any): AxiosPromise<PostCreatePlaylistResult> {
            return localVarFp.playlistEditingControllerCreatePlaylist(createPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerDeletePlaylist(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerDeletePlaylist(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRemoveVariantFromPlaylistDelete(alias: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRemoveVariantFromPlaylistDelete(alias, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistEditingApi - object-oriented interface
 * @export
 * @class PlaylistEditingApi
 * @extends {BaseAPI}
 */
export class PlaylistEditingApi extends BaseAPI {
    /**
     * 
     * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePlaylistInDto} createPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerCreatePlaylist(createPlaylistInDto: CreatePlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerCreatePlaylist(createPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerDeletePlaylist(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerDeletePlaylist(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRemoveVariantFromPlaylistDelete(alias: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRemoveVariantFromPlaylistDelete(alias, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RenamePlaylistInDto} renamePlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistGettingApi - axios parameter creator
 * @export
 */
export const PlaylistGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistDataByGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('playlistGettingControllerGetPlaylistDataByGuid', 'guid', guid)
            const localVarPath = `/playlist/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistsOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist/ofuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variantAlias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerIsVariantInPlaylist: async (variantAlias: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantAlias' is not null or undefined
            assertParamExists('playlistGettingControllerIsVariantInPlaylist', 'variantAlias', variantAlias)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistGettingControllerIsVariantInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/contains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (variantAlias !== undefined) {
                localVarQueryParameter['variantAlias'] = variantAlias;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerSearchInPlaylist: async (searchKey: string, playlist: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('playlistGettingControllerSearchInPlaylist', 'searchKey', searchKey)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistGettingControllerSearchInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistGettingApi - functional programming interface
 * @export
 */
export const PlaylistGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerGetPlaylistDataByGuid(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerGetPlaylistDataByGuid']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerGetPlaylistsOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlaylistsResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerGetPlaylistsOfUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerGetPlaylistsOfUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} variantAlias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerIsVariantInPlaylist(variantAlias: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerIsVariantInPlaylist(variantAlias, playlist, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerIsVariantInPlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchInPlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerSearchInPlaylist']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PlaylistGettingApi - factory interface
 * @export
 */
export const PlaylistGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.playlistGettingControllerGetPlaylistDataByGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistsOfUser(options?: any): AxiosPromise<GetPlaylistsResult> {
            return localVarFp.playlistGettingControllerGetPlaylistsOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variantAlias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerIsVariantInPlaylist(variantAlias: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistGettingControllerIsVariantInPlaylist(variantAlias, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: any): AxiosPromise<GetSearchInPlaylistResult> {
            return localVarFp.playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistGettingApi - object-oriented interface
 * @export
 * @class PlaylistGettingApi
 * @extends {BaseAPI}
 */
export class PlaylistGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerGetPlaylistDataByGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerGetPlaylistsOfUser(options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerGetPlaylistsOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variantAlias 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerIsVariantInPlaylist(variantAlias: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerIsVariantInPlaylist(variantAlias, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchKey 
     * @param {string} playlist 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongAddingApi - axios parameter creator
 * @export
 */
export const SongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostAddSongDataBody} postAddSongDataBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreate: async (postAddSongDataBody: PostAddSongDataBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAddSongDataBody' is not null or undefined
            assertParamExists('songAddingControllerCreate', 'postAddSongDataBody', postAddSongDataBody)
            const localVarPath = `/song`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAddSongDataBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreateCopy: async (postCreateCopyInDto: PostCreateCopyInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateCopyInDto' is not null or undefined
            assertParamExists('songAddingControllerCreateCopy', 'postCreateCopyInDto', postCreateCopyInDto)
            const localVarPath = `/song/create/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateCopyInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerIsParserAvailable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/parser/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerParse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongAddingApi - functional programming interface
 * @export
 */
export const SongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostAddSongDataBody} postAddSongDataBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerCreate(postAddSongDataBody: PostAddSongDataBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewSongDataProcessResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerCreate(postAddSongDataBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongAddingApi.songAddingControllerCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateCopyOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerCreateCopy(postCreateCopyInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongAddingApi.songAddingControllerCreateCopy']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerIsParserAvailable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerIsParserAvailable(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongAddingApi.songAddingControllerIsParserAvailable']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerParse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParserSongDataResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerParse(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongAddingApi.songAddingControllerParse']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SongAddingApi - factory interface
 * @export
 */
export const SongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongAddingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostAddSongDataBody} postAddSongDataBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreate(postAddSongDataBody: PostAddSongDataBody, options?: any): AxiosPromise<NewSongDataProcessResult> {
            return localVarFp.songAddingControllerCreate(postAddSongDataBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: any): AxiosPromise<PostCreateCopyOutDto> {
            return localVarFp.songAddingControllerCreateCopy(postCreateCopyInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerIsParserAvailable(options?: any): AxiosPromise<boolean> {
            return localVarFp.songAddingControllerIsParserAvailable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerParse(options?: any): AxiosPromise<ParserSongDataResult> {
            return localVarFp.songAddingControllerParse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongAddingApi - object-oriented interface
 * @export
 * @class SongAddingApi
 * @extends {BaseAPI}
 */
export class SongAddingApi extends BaseAPI {
    /**
     * 
     * @param {PostAddSongDataBody} postAddSongDataBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerCreate(postAddSongDataBody: PostAddSongDataBody, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerCreate(postAddSongDataBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostCreateCopyInDto} postCreateCopyInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerCreateCopy(postCreateCopyInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerIsParserAvailable(options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerIsParserAvailable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerParse(options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerParse(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongDeletingApi - axios parameter creator
 * @export
 */
export const SongDeletingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerDelete: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songDeletingControllerDelete', 'guid', guid)
            const localVarPath = `/song/variant/delete/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerRestore: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songDeletingControllerRestore', 'guid', guid)
            const localVarPath = `/song/variant/restore/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongDeletingApi - functional programming interface
 * @export
 */
export const SongDeletingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongDeletingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songDeletingControllerDelete(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songDeletingControllerDelete(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongDeletingApi.songDeletingControllerDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songDeletingControllerRestore(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songDeletingControllerRestore(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongDeletingApi.songDeletingControllerRestore']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SongDeletingApi - factory interface
 * @export
 */
export const SongDeletingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongDeletingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerDelete(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.songDeletingControllerDelete(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerRestore(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.songDeletingControllerRestore(guid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongDeletingApi - object-oriented interface
 * @export
 * @class SongDeletingApi
 * @extends {BaseAPI}
 */
export class SongDeletingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public songDeletingControllerDelete(guid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).songDeletingControllerDelete(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public songDeletingControllerRestore(guid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).songDeletingControllerRestore(guid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongEditingApi - axios parameter creator
 * @export
 */
export const SongEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerEditVariant: async (postEditVariantInDto: PostEditVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postEditVariantInDto' is not null or undefined
            assertParamExists('songEditingControllerEditVariant', 'postEditVariantInDto', postEditVariantInDto)
            const localVarPath = `/song/variant/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postEditVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerUnverify: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songEditingControllerUnverify', 'guid', guid)
            const localVarPath = `/song/variant/unverify/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerVerify: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songEditingControllerVerify', 'guid', guid)
            const localVarPath = `/song/variant/verify/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongEditingApi - functional programming interface
 * @export
 */
export const SongEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerEditVariant(postEditVariantInDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongEditingApi.songEditingControllerEditVariant']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerUnverify(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerUnverify(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongEditingApi.songEditingControllerUnverify']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerVerify(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerVerify(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongEditingApi.songEditingControllerVerify']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SongEditingApi - factory interface
 * @export
 */
export const SongEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: any): AxiosPromise<EditVariantOutDto> {
            return localVarFp.songEditingControllerEditVariant(postEditVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerUnverify(guid: string, options?: any): AxiosPromise<void> {
            return localVarFp.songEditingControllerUnverify(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerVerify(guid: string, options?: any): AxiosPromise<void> {
            return localVarFp.songEditingControllerVerify(guid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongEditingApi - object-oriented interface
 * @export
 * @class SongEditingApi
 * @extends {BaseAPI}
 */
export class SongEditingApi extends BaseAPI {
    /**
     * 
     * @param {PostEditVariantInDto} postEditVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerEditVariant(postEditVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerUnverify(guid: string, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerUnverify(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerVerify(guid: string, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerVerify(guid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongGettingApi - axios parameter creator
 * @export
 */
export const SongGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetBySearch: async (searchKey: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('songGettingControllerGetBySearch', 'searchKey', searchKey)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('songGettingControllerGetBySearch', 'page', page)
            const localVarPath = `/song/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetList: async (page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('songGettingControllerGetList', 'page', page)
            const localVarPath = `/song/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRecommendedSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongDataByVariantGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songGettingControllerGetSongDataByVariantGuid', 'guid', guid)
            const localVarPath = `/song/ofvariant/{guid}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongListOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongGettingApi - functional programming interface
 * @export
 */
export const SongGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetBySearch(searchKey: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SongVariantDataOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetBySearch(searchKey, page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongGettingApi.songGettingControllerGetBySearch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetList(page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListSongData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetList(page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongGettingApi.songGettingControllerGetList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetRecommendedSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecommendedSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetRecommendedSongs(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongGettingApi.songGettingControllerGetRecommendedSongs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSongDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongDataByVariantGuid(guid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongDataByVariantGuid']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongListOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVariantsOfUserOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongListOfUser(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongListOfUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongsCount(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongsCount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SongGettingApi - factory interface
 * @export
 */
export const SongGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetBySearch(searchKey: string, page: number, options?: any): AxiosPromise<Array<SongVariantDataOutDto>> {
            return localVarFp.songGettingControllerGetBySearch(searchKey, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetList(page: number, options?: any): AxiosPromise<Array<ListSongData>> {
            return localVarFp.songGettingControllerGetList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRecommendedSongs(options?: any): AxiosPromise<GetRecommendedSongsOutDto> {
            return localVarFp.songGettingControllerGetRecommendedSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongDataByVariantGuid(guid: string, options?: any): AxiosPromise<GetSongDataOutDto> {
            return localVarFp.songGettingControllerGetSongDataByVariantGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongListOfUser(options?: any): AxiosPromise<GetVariantsOfUserOutDto> {
            return localVarFp.songGettingControllerGetSongListOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongsCount(options?: any): AxiosPromise<number> {
            return localVarFp.songGettingControllerGetSongsCount(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongGettingApi - object-oriented interface
 * @export
 * @class SongGettingApi
 * @extends {BaseAPI}
 */
export class SongGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} searchKey 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetBySearch(searchKey: string, page: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetBySearch(searchKey, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetList(page: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetRecommendedSongs(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetRecommendedSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongDataByVariantGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongListOfUser(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongListOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongsCount(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongsCount(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UrlAliasApi - axios parameter creator
 * @export
 */
export const UrlAliasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        urlAliasControllerGetVariantFromAlias: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('urlAliasControllerGetVariantFromAlias', 'alias', alias)
            const localVarPath = `/alias/variant/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UrlAliasApi - functional programming interface
 * @export
 */
export const UrlAliasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UrlAliasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async urlAliasControllerGetVariantFromAlias(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.urlAliasControllerGetVariantFromAlias(alias, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UrlAliasApi.urlAliasControllerGetVariantFromAlias']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UrlAliasApi - factory interface
 * @export
 */
export const UrlAliasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UrlAliasApiFp(configuration)
    return {
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        urlAliasControllerGetVariantFromAlias(alias: string, options?: any): AxiosPromise<string> {
            return localVarFp.urlAliasControllerGetVariantFromAlias(alias, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UrlAliasApi - object-oriented interface
 * @export
 * @class UrlAliasApi
 * @extends {BaseAPI}
 */
export class UrlAliasApi extends BaseAPI {
    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlAliasApi
     */
    public urlAliasControllerGetVariantFromAlias(alias: string, options?: RawAxiosRequestConfig) {
        return UrlAliasApiFp(this.configuration).urlAliasControllerGetVariantFromAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhookGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerWebhook(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.webhookControllerWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerWebhookGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerWebhookGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.webhookControllerWebhookGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhook(options?: any): AxiosPromise<string> {
            return localVarFp.webhookControllerWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhookGet(options?: any): AxiosPromise<object> {
            return localVarFp.webhookControllerWebhookGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerWebhook(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerWebhookGet(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerWebhookGet(options).then((request) => request(this.axios, this.basePath));
    }
}



