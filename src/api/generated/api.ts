/* tslint:disable */
/* eslint-disable */
/**
 * WorshipTool API
 * API for WorshipTool app
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig as RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddPackToTeamSelectionInDto
 */
export interface AddPackToTeamSelectionInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPackToTeamSelectionInDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPackToTeamSelectionInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface AddPermissionToGroupInDto
 */
export interface AddPermissionToGroupInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToGroupInDto
     */
    'groupGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToGroupInDto
     */
    'permissionGuid': string;
}
/**
 * 
 * @export
 * @interface AddPermissionToUserInDto
 */
export interface AddPermissionToUserInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'permissionGuid': string;
}
/**
 * 
 * @export
 * @interface AddVariantToPlaylistInDto
 */
export interface AddVariantToPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'playlist': string;
}
/**
 * 
 * @export
 * @interface BaseUserInfoOutDto
 */
export interface BaseUserInfoOutDto {
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof BaseUserInfoOutDto
     */
    'role': BaseUserInfoOutDtoRoleEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof BaseUserInfoOutDto
     */
    'loginMethods': Array<BaseUserInfoOutDtoLoginMethodsEnum>;
}

export const BaseUserInfoOutDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type BaseUserInfoOutDtoRoleEnum = typeof BaseUserInfoOutDtoRoleEnum[keyof typeof BaseUserInfoOutDtoRoleEnum];
export const BaseUserInfoOutDtoLoginMethodsEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type BaseUserInfoOutDtoLoginMethodsEnum = typeof BaseUserInfoOutDtoLoginMethodsEnum[keyof typeof BaseUserInfoOutDtoLoginMethodsEnum];

/**
 * 
 * @export
 * @interface CSVLink
 */
export interface CSVLink {
    /**
     * 
     * @type {string}
     * @memberof CSVLink
     */
    'guid': string;
    /**
     * 
     * @type {Creator}
     * @memberof CSVLink
     */
    'creator': Creator;
    /**
     * 
     * @type {number}
     * @memberof CSVLink
     */
    'type': CSVLinkTypeEnum;
    /**
     * 
     * @type {SongVariant}
     * @memberof CSVLink
     */
    'variant': SongVariant;
}

export const CSVLinkTypeEnum = {
    NUMBER_0: 0
} as const;

export type CSVLinkTypeEnum = typeof CSVLinkTypeEnum[keyof typeof CSVLinkTypeEnum];

/**
 * 
 * @export
 * @interface ChangePasswordInDto
 */
export interface ChangePasswordInDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordInDto
     */
    'oldPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordInDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface ChangeTeamInfoInDto
 */
export interface ChangeTeamInfoInDto {
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamInfoInDto
     */
    'teamGuid': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamInfoInDto
     */
    'teamName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeTeamInfoInDto
     */
    'joinCode'?: string;
}
/**
 * 
 * @export
 * @interface CreateTeamInDto
 */
export interface CreateTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamInDto
     */
    'teamName': string;
}
/**
 * 
 * @export
 * @interface CreateTeamOutDto
 */
export interface CreateTeamOutDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface Creator
 */
export interface Creator {
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'name': string;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof Creator
     */
    'links': Array<CSVLink>;
}
/**
 * 
 * @export
 * @interface CreatorDTO
 */
export interface CreatorDTO {
    /**
     * 
     * @type {string}
     * @memberof CreatorDTO
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreatorDTO
     */
    'type': CreatorDTOTypeEnum;
}

export const CreatorDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type CreatorDTOTypeEnum = typeof CreatorDTOTypeEnum[keyof typeof CreatorDTOTypeEnum];

/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'name': string;
    /**
     * 
     * @type {Array<RecordItem>}
     * @memberof Domain
     */
    'data': Array<RecordItem>;
}
/**
 * 
 * @export
 * @interface EditItemInDto
 */
export interface EditItemInDto {
    /**
     * 
     * @type {string}
     * @memberof EditItemInDto
     */
    'itemGuid': string;
    /**
     * 
     * @type {string}
     * @memberof EditItemInDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditItemInDto
     */
    'sheetData'?: string;
}
/**
 * 
 * @export
 * @interface EditVariantOutDto
 */
export interface EditVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof EditVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof EditVariantOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface GetAnalyticsOutDto
 */
export interface GetAnalyticsOutDto {
    /**
     * 
     * @type {Array<Graph>}
     * @memberof GetAnalyticsOutDto
     */
    'graphs': Array<Graph>;
    /**
     * 
     * @type {number}
     * @memberof GetAnalyticsOutDto
     */
    'days': number;
}
/**
 * 
 * @export
 * @interface GetGlobalSongsOutDto
 */
export interface GetGlobalSongsOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetGlobalSongsOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface GetGroupInfoResult
 */
export interface GetGroupInfoResult {
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'selection': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface GetGroupListItem
 */
export interface GetGroupListItem {
    /**
     * 
     * @type {string}
     * @memberof GetGroupListItem
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupListItem
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetGroupsCountResult
 */
export interface GetGroupsCountResult {
    /**
     * 
     * @type {number}
     * @memberof GetGroupsCountResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetJoinCodeOutDto
 */
export interface GetJoinCodeOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetJoinCodeOutDto
     */
    'joinCode': string;
}
/**
 * 
 * @export
 * @interface GetListSongData
 */
export interface GetListSongData {
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'packGuid': string;
}
/**
 * 
 * @export
 * @interface GetOrCreatePermissionInDto
 */
export interface GetOrCreatePermissionInDto {
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetPackAliasFromSourceUrlOutDto
 */
export interface GetPackAliasFromSourceUrlOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetPackAliasFromSourceUrlOutDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof GetPackAliasFromSourceUrlOutDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetPackAliasFromSourceUrlOutDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface GetPlaylistsResult
 */
export interface GetPlaylistsResult {
    /**
     * 
     * @type {Array<PlaylistData>}
     * @memberof GetPlaylistsResult
     */
    'playlists': Array<PlaylistData>;
}
/**
 * 
 * @export
 * @interface GetRandomVariantOutDto
 */
export interface GetRandomVariantOutDto {
    /**
     * 
     * @type {SongVariantDataOutDto}
     * @memberof GetRandomVariantOutDto
     */
    'variant': SongVariantDataOutDto;
}
/**
 * 
 * @export
 * @interface GetRecommendedSongsOutDto
 */
export interface GetRecommendedSongsOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetRecommendedSongsOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface GetSearchInPlaylistResult
 */
export interface GetSearchInPlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof GetSearchInPlaylistResult
     */
    'guid': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof GetSearchInPlaylistResult
     */
    'items': Array<PlaylistItemOutDto>;
}
/**
 * 
 * @export
 * @interface GetSongDataOutDto
 */
export interface GetSongDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'mainTitle': string;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof GetSongDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {Array<SongDataVariant>}
     * @memberof GetSongDataOutDto
     */
    'variants': Array<SongDataVariant>;
    /**
     * 
     * @type {Array<SongDataMedia>}
     * @memberof GetSongDataOutDto
     */
    'media': Array<SongDataMedia>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSongDataOutDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetTeamAliasFromSubdomainOutDto
 */
export interface GetTeamAliasFromSubdomainOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetTeamAliasFromSubdomainOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface GetTeamInfoOutDto
 */
export interface GetTeamInfoOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'selectionGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'createdByGuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetTeamInfoOutDto
     */
    'joinCode': string;
}
/**
 * 
 * @export
 * @interface GetTeamMembersOutDto
 */
export interface GetTeamMembersOutDto {
    /**
     * 
     * @type {Array<TeamMemberDto>}
     * @memberof GetTeamMembersOutDto
     */
    'members': Array<TeamMemberDto>;
}
/**
 * 
 * @export
 * @interface GetUserPermissionOutDto
 */
export interface GetUserPermissionOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetVariantsOfUserOutDto
 */
export interface GetVariantsOfUserOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetVariantsOfUserOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface Graph
 */
export interface Graph {
    /**
     * 
     * @type {string}
     * @memberof Graph
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Graph
     */
    'subtitle'?: string;
    /**
     * 
     * @type {Array<LineData>}
     * @memberof Graph
     */
    'lines': Array<LineData>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {Playlist}
     * @memberof Group
     */
    'selection': Playlist;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface IsUserMemberOfTeamOutDto
 */
export interface IsUserMemberOfTeamOutDto {
    /**
     * 
     * @type {boolean}
     * @memberof IsUserMemberOfTeamOutDto
     */
    'isMember': boolean;
}
/**
 * 
 * @export
 * @interface JoinTeamInDto
 */
export interface JoinTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof JoinTeamInDto
     */
    'joinCode': string;
}
/**
 * 
 * @export
 * @interface JoinTeamOutDto
 */
export interface JoinTeamOutDto {
    /**
     * 
     * @type {string}
     * @memberof JoinTeamOutDto
     */
    'teamAlias': string;
    /**
     * 
     * @type {boolean}
     * @memberof JoinTeamOutDto
     */
    'newMember': boolean;
}
/**
 * 
 * @export
 * @interface JwtResult
 */
export interface JwtResult {
    /**
     * 
     * @type {BaseUserInfoOutDto}
     * @memberof JwtResult
     */
    'user': BaseUserInfoOutDto;
    /**
     * 
     * @type {string}
     * @memberof JwtResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LeaveTeamInDto
 */
export interface LeaveTeamInDto {
    /**
     * 
     * @type {string}
     * @memberof LeaveTeamInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof LeaveTeamInDto
     */
    'teamAlias': string;
}
/**
 * 
 * @export
 * @interface LineData
 */
export interface LineData {
    /**
     * 
     * @type {string}
     * @memberof LineData
     */
    'name': string;
    /**
     * 
     * @type {Array<LineValueData>}
     * @memberof LineData
     */
    'values': Array<LineValueData>;
}
/**
 * 
 * @export
 * @interface LineValueData
 */
export interface LineValueData {
    /**
     * 
     * @type {number}
     * @memberof LineValueData
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof LineValueData
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface LoginInputData
 */
export interface LoginInputData {
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'guid': string;
    /**
     * 
     * @type {Song}
     * @memberof Media
     */
    'song': Song;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'type': MediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'url': string;
}

export const MediaTypeEnum = {
    NUMBER_0: 0
} as const;

export type MediaTypeEnum = typeof MediaTypeEnum[keyof typeof MediaTypeEnum];

/**
 * 
 * @export
 * @interface MessengerResponseInDto
 */
export interface MessengerResponseInDto {
    /**
     * 
     * @type {string}
     * @memberof MessengerResponseInDto
     */
    'object': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof MessengerResponseInDto
     */
    'entry': Array<object>;
}
/**
 * 
 * @export
 * @interface ParserSongData
 */
export interface ParserSongData {
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ParserSongDataResult
 */
export interface ParserSongDataResult {
    /**
     * 
     * @type {Array<ParserSongData>}
     * @memberof ParserSongDataResult
     */
    'sheets': Array<ParserSongData>;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'payload'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Permission
     */
    'users': Array<User>;
    /**
     * 
     * @type {Array<PermissionUserGroup>}
     * @memberof Permission
     */
    'groups': Array<PermissionUserGroup>;
}
/**
 * 
 * @export
 * @interface PermissionUserBaseOutDto
 */
export interface PermissionUserBaseOutDto {
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionUserBaseOutDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof PermissionUserBaseOutDto
     */
    'role': PermissionUserBaseOutDtoRoleEnum;
}

export const PermissionUserBaseOutDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type PermissionUserBaseOutDtoRoleEnum = typeof PermissionUserBaseOutDtoRoleEnum[keyof typeof PermissionUserBaseOutDtoRoleEnum];

/**
 * 
 * @export
 * @interface PermissionUserGroup
 */
export interface PermissionUserGroup {
    /**
     * 
     * @type {string}
     * @memberof PermissionUserGroup
     */
    'guid': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PermissionUserGroup
     */
    'users': Array<User>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PermissionUserGroup
     */
    'permissions': Array<Permission>;
}
/**
 * 
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof Playlist
     */
    'items': Array<PlaylistItem>;
    /**
     * 
     * @type {User}
     * @memberof Playlist
     */
    'owner': User;
    /**
     * 
     * @type {boolean}
     * @memberof Playlist
     */
    'isSelection': boolean;
}
/**
 * 
 * @export
 * @interface PlaylistData
 */
export interface PlaylistData {
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PlaylistDataOutDto
 */
export interface PlaylistDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof PlaylistDataOutDto
     */
    'items': Array<PlaylistItemOutDto>;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'ownerGuid': string;
}
/**
 * 
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {object}
     * @memberof PlaylistItem
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'order': number;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof PlaylistItem
     */
    'variantPack': SongVariantHistoryPack;
    /**
     * 
     * @type {Playlist}
     * @memberof PlaylistItem
     */
    'playlist': Playlist;
}
/**
 * 
 * @export
 * @interface PlaylistItemOutDto
 */
export interface PlaylistItemOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'toneKey': string;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItemOutDto
     */
    'order': number;
    /**
     * 
     * @type {SongVariantDataOutDto}
     * @memberof PlaylistItemOutDto
     */
    'variant': SongVariantDataOutDto;
}
/**
 * 
 * @export
 * @interface PostAiRequestInDto
 */
export interface PostAiRequestInDto {
    /**
     * 
     * @type {string}
     * @memberof PostAiRequestInDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PostAiRequestOutDto
 */
export interface PostAiRequestOutDto {
    /**
     * 
     * @type {string}
     * @memberof PostAiRequestOutDto
     */
    'outputString': string;
}
/**
 * 
 * @export
 * @interface PostChangeLanguageInDto
 */
export interface PostChangeLanguageInDto {
    /**
     * 
     * @type {string}
     * @memberof PostChangeLanguageInDto
     */
    'variantGuid': string;
    /**
     * 
     * @type {string}
     * @memberof PostChangeLanguageInDto
     */
    'languageString'?: string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyInDto
 */
export interface PostCreateCopyInDto {
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyInDto
     */
    'variantGuid': string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyOutDto
 */
export interface PostCreateCopyOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateCopyOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface PostCreateGroupBody
 */
export interface PostCreateGroupBody {
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupBody
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface PostCreateGroupResult
 */
export interface PostCreateGroupResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'selection': string;
}
/**
 * 
 * @export
 * @interface PostCreatePlaylistResult
 */
export interface PostCreatePlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreatePlaylistResult
     */
    'guid': string;
}
/**
 * 
 * @export
 * @interface PostCreateVariantInDto
 */
export interface PostCreateVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'sheetData': string;
    /**
     * 
     * @type {SongDataSource}
     * @memberof PostCreateVariantInDto
     */
    'source'?: SongDataSource;
    /**
     * 
     * @type {number}
     * @memberof PostCreateVariantInDto
     */
    'createdType': PostCreateVariantInDtoCreatedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'language'?: string;
}

export const PostCreateVariantInDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostCreateVariantInDtoCreatedTypeEnum = typeof PostCreateVariantInDtoCreatedTypeEnum[keyof typeof PostCreateVariantInDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface PostCreateVariantOutDto
 */
export interface PostCreateVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface PostEditVariantInDto
 */
export interface PostEditVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'variantAlias': string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'sheetData'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostEditVariantInDto
     */
    'createdType': PostEditVariantInDtoCreatedTypeEnum;
}

export const PostEditVariantInDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostEditVariantInDtoCreatedTypeEnum = typeof PostEditVariantInDtoCreatedTypeEnum[keyof typeof PostEditVariantInDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface PostGetKeywordsInDto
 */
export interface PostGetKeywordsInDto {
    /**
     * 
     * @type {string}
     * @memberof PostGetKeywordsInDto
     */
    'variantGuid': string;
}
/**
 * 
 * @export
 * @interface PostGoogleLoginBody
 */
export interface PostGoogleLoginBody {
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'userToken': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface PostPublishVariantInDto
 */
export interface PostPublishVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostPublishVariantInDto
     */
    'variantGuid': string;
}
/**
 * 
 * @export
 * @interface PostSendCustomMessageBody
 */
export interface PostSendCustomMessageBody {
    /**
     * 
     * @type {object}
     * @memberof PostSendCustomMessageBody
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface PostSendFeedbackBody
 */
export interface PostSendFeedbackBody {
    /**
     * 
     * @type {string}
     * @memberof PostSendFeedbackBody
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendFeedbackBody
     */
    'userName'?: string;
}
/**
 * 
 * @export
 * @interface PostSendMailFeedbackInDto
 */
export interface PostSendMailFeedbackInDto {
    /**
     * 
     * @type {string}
     * @memberof PostSendMailFeedbackInDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendMailFeedbackInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendMailFeedbackInDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostSendMessageBody
 */
export interface PostSendMessageBody {
    /**
     * 
     * @type {string}
     * @memberof PostSendMessageBody
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostValidateSheetDataAndTitleInDto
 */
export interface PostValidateSheetDataAndTitleInDto {
    /**
     * 
     * @type {string}
     * @memberof PostValidateSheetDataAndTitleInDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof PostValidateSheetDataAndTitleInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PostVerifyVariantInDto
 */
export interface PostVerifyVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostVerifyVariantInDto
     */
    'variantGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostVerifyVariantInDto
     */
    'verify': boolean | null;
}
/**
 * 
 * @export
 * @interface ProgramSongData
 */
export interface ProgramSongData {
    /**
     * 
     * @type {number}
     * @memberof ProgramSongData
     */
    'confidence': number;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof ProgramSongData
     */
    'createdType': ProgramSongDataCreatedTypeEnum;
}

export const ProgramSongDataCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type ProgramSongDataCreatedTypeEnum = typeof ProgramSongDataCreatedTypeEnum[keyof typeof ProgramSongDataCreatedTypeEnum];

/**
 * 
 * @export
 * @interface RecordItem
 */
export interface RecordItem {
    /**
     * 
     * @type {string}
     * @memberof RecordItem
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof RecordItem
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface RegisterWebhookExtensionBody
 */
export interface RegisterWebhookExtensionBody {
    /**
     * 
     * @type {string}
     * @memberof RegisterWebhookExtensionBody
     */
    'extensionName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterWebhookExtensionBody
     */
    'extensionPublicUrl': string;
}
/**
 * 
 * @export
 * @interface RenamePlaylistInDto
 */
export interface RenamePlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistInDto
 */
export interface ReorderPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {Array<ReorderPlaylistItem>}
     * @memberof ReorderPlaylistInDto
     */
    'items': Array<ReorderPlaylistItem>;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistItem
 */
export interface ReorderPlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof ReorderPlaylistItem
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface ReplaceWithCopyInDto
 */
export interface ReplaceWithCopyInDto {
    /**
     * 
     * @type {string}
     * @memberof ReplaceWithCopyInDto
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof ReplaceWithCopyInDto
     */
    'teamGuid': string;
}
/**
 * 
 * @export
 * @interface ReplaceWithCopyOutDto
 */
export interface ReplaceWithCopyOutDto {
    /**
     * 
     * @type {string}
     * @memberof ReplaceWithCopyOutDto
     */
    'packAlias': string;
}
/**
 * 
 * @export
 * @interface RequireItemEditInDto
 */
export interface RequireItemEditInDto {
    /**
     * 
     * @type {string}
     * @memberof RequireItemEditInDto
     */
    'itemGuid': string;
}
/**
 * 
 * @export
 * @interface ResetPasswordInDto
 */
export interface ResetPasswordInDto {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordInDto
     */
    'newPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordInDto
     */
    'resetToken': string;
}
/**
 * 
 * @export
 * @interface SetGroupPayloadInDto
 */
export interface SetGroupPayloadInDto {
    /**
     * 
     * @type {string}
     * @memberof SetGroupPayloadInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SetGroupPayloadInDto
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface SetMemberRoleInDto
 */
export interface SetMemberRoleInDto {
    /**
     * 
     * @type {string}
     * @memberof SetMemberRoleInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SetMemberRoleInDto
     */
    'teamGuid': string;
    /**
     * 
     * @type {number}
     * @memberof SetMemberRoleInDto
     */
    'role': SetMemberRoleInDtoRoleEnum;
}

export const SetMemberRoleInDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SetMemberRoleInDtoRoleEnum = typeof SetMemberRoleInDtoRoleEnum[keyof typeof SetMemberRoleInDtoRoleEnum];

/**
 * 
 * @export
 * @interface SignUpInDto
 */
export interface SignUpInDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'guid': string;
    /**
     * 
     * @type {SongTitle}
     * @memberof Song
     */
    'mainTitle': SongTitle;
    /**
     * 
     * @type {Array<SongVariantHistoryPack>}
     * @memberof Song
     */
    'variantPacks': Array<SongVariantHistoryPack>;
    /**
     * 
     * @type {Array<Media>}
     * @memberof Song
     */
    'media': Array<Media>;
}
/**
 * 
 * @export
 * @interface SongDataCreator
 */
export interface SongDataCreator {
    /**
     * 
     * @type {string}
     * @memberof SongDataCreator
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SongDataCreator
     */
    'type': SongDataCreatorTypeEnum;
}

export const SongDataCreatorTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataCreatorTypeEnum = typeof SongDataCreatorTypeEnum[keyof typeof SongDataCreatorTypeEnum];

/**
 * 
 * @export
 * @interface SongDataMedia
 */
export interface SongDataMedia {
    /**
     * 
     * @type {number}
     * @memberof SongDataMedia
     */
    'type': SongDataMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataMedia
     */
    'url': string;
}

export const SongDataMediaTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataMediaTypeEnum = typeof SongDataMediaTypeEnum[keyof typeof SongDataMediaTypeEnum];

/**
 * 
 * @export
 * @interface SongDataSource
 */
export interface SongDataSource {
    /**
     * 
     * @type {number}
     * @memberof SongDataSource
     */
    'type': SongDataSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataSource
     */
    'value': string;
}

export const SongDataSourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataSourceTypeEnum = typeof SongDataSourceTypeEnum[keyof typeof SongDataSourceTypeEnum];

/**
 * 
 * @export
 * @interface SongDataVariant
 */
export interface SongDataVariant {
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'songGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongDataVariant
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'createdByGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {Array<SourceDTO>}
     * @memberof SongDataVariant
     */
    'sources': Array<SourceDTO>;
    /**
     * 
     * @type {Array<CreatorDTO>}
     * @memberof SongDataVariant
     */
    'creators': Array<CreatorDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongDataVariant
     */
    'createdType': SongDataVariantCreatedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'alias': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'inFormat': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'public': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongDataVariant
     */
    'tags': Array<string>;
}

export const SongDataVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongDataVariantCreatedTypeEnum = typeof SongDataVariantCreatedTypeEnum[keyof typeof SongDataVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongTitle
 */
export interface SongTitle {
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'searchValue': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongTitle
     */
    'variant': SongVariant;
}
/**
 * 
 * @export
 * @interface SongVariant
 */
export interface SongVariant {
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'searchValue': string;
    /**
     * 
     * @type {object}
     * @memberof SongVariant
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'type'?: SongVariantTypeEnum;
    /**
     * 
     * @type {SongTitle}
     * @memberof SongVariant
     */
    'prefferedTitle': SongTitle;
    /**
     * 
     * @type {Array<SongTitle>}
     * @memberof SongVariant
     */
    'titles': Array<SongTitle>;
    /**
     * 
     * @type {User}
     * @memberof SongVariant
     */
    'createdBy': User;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof SongVariant
     */
    'links': Array<CSVLink>;
    /**
     * 
     * @type {Array<Source>}
     * @memberof SongVariant
     */
    'sources': Array<Source>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof SongVariant
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'tagsGenerated': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'createdType': SongVariantCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariant
     */
    'children': Array<SongVariant>;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariant
     */
    'parent': SongVariant;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof SongVariant
     */
    'historyPack': SongVariantHistoryPack;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'inFormat': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'hasChords': boolean;
}

export const SongVariantTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SongVariantTypeEnum = typeof SongVariantTypeEnum[keyof typeof SongVariantTypeEnum];
export const SongVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantCreatedTypeEnum = typeof SongVariantCreatedTypeEnum[keyof typeof SongVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongVariantDataOutDto
 */
export interface SongVariantDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongVariantDataOutDto
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'createdBy': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariantDataOutDto
     */
    'createdType': SongVariantDataOutDtoCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongDataSource>}
     * @memberof SongVariantDataOutDto
     */
    'sources': Array<SongDataSource>;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof SongVariantDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'packGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'inFormat': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'deleted': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongVariantDataOutDto
     */
    'tags': Array<string>;
}

export const SongVariantDataOutDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantDataOutDtoCreatedTypeEnum = typeof SongVariantDataOutDtoCreatedTypeEnum[keyof typeof SongVariantDataOutDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongVariantHistoryPack
 */
export interface SongVariantHistoryPack {
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    'guid': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariantHistoryPack
     */
    'last': SongVariant;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariantHistoryPack
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Song}
     * @memberof SongVariantHistoryPack
     */
    'song': Song;
    /**
     * 
     * @type {Array<UrlAlias>}
     * @memberof SongVariantHistoryPack
     */
    'aliases': Array<UrlAlias>;
    /**
     * 
     * @type {UrlAlias}
     * @memberof SongVariantHistoryPack
     */
    'alias': UrlAlias;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof SongVariantHistoryPack
     */
    'playlistItems': Array<PlaylistItem>;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantHistoryPack
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantHistoryPack
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof Source
     */
    'type': SourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'value': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof Source
     */
    'variant': SongVariant;
}

export const SourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceTypeEnum = typeof SourceTypeEnum[keyof typeof SourceTypeEnum];

/**
 * 
 * @export
 * @interface SourceDTO
 */
export interface SourceDTO {
    /**
     * 
     * @type {number}
     * @memberof SourceDTO
     */
    'type': SourceDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDTO
     */
    'value': string;
}

export const SourceDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceDTOTypeEnum = typeof SourceDTOTypeEnum[keyof typeof SourceDTOTypeEnum];

/**
 * 
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * 
     * @type {Array<Domain>}
     * @memberof Statistics
     */
    'domains': Array<Domain>;
    /**
     * 
     * @type {Array<RecordItem>}
     * @memberof Statistics
     */
    'all': Array<RecordItem>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'guid': string;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof Tag
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'lastName': string;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDto
     */
    'role': TeamMemberDtoRoleEnum;
}

export const TeamMemberDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type TeamMemberDtoRoleEnum = typeof TeamMemberDtoRoleEnum[keyof typeof TeamMemberDtoRoleEnum];

/**
 * 
 * @export
 * @interface TransposePlaylistItemInDto
 */
export interface TransposePlaylistItemInDto {
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UrlAlias
 */
export interface UrlAlias {
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'alias': string;
    /**
     * 
     * @type {number}
     * @memberof UrlAlias
     */
    'type': UrlAliasTypeEnum;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof UrlAlias
     */
    'pack': SongVariantHistoryPack;
}

export const UrlAliasTypeEnum = {
    NUMBER_0: 0
} as const;

export type UrlAliasTypeEnum = typeof UrlAliasTypeEnum[keyof typeof UrlAliasTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof User
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof User
     */
    'playlists': Array<Playlist>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof User
     */
    'permissions': Array<Permission>;
    /**
     * 
     * @type {Array<UserToken>}
     * @memberof User
     */
    'tokens': Array<UserToken>;
    /**
     * 
     * @type {Array<UserToken>}
     * @memberof User
     */
    'resetTokens': Array<UserToken>;
}

export const UserRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserToken
 */
export interface UserToken {
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'revokedAt': string;
    /**
     * 
     * @type {User}
     * @memberof UserToken
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface ValidationResult
 */
export interface ValidationResult {
    /**
     * 
     * @type {boolean}
     * @memberof ValidationResult
     */
    'success': boolean;
    /**
     * 
     * @type {object}
     * @memberof ValidationResult
     */
    'qualities': object;
    /**
     * 
     * @type {string}
     * @memberof ValidationResult
     */
    'message': string;
}

/**
 * AIApi - axios parameter creator
 * @export
 */
export const AIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostAiRequestInDto} postAiRequestInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiControllerMakeRequest: async (postAiRequestInDto: PostAiRequestInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAiRequestInDto' is not null or undefined
            assertParamExists('aiControllerMakeRequest', 'postAiRequestInDto', postAiRequestInDto)
            const localVarPath = `/ai/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAiRequestInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostAiRequestInDto} postAiRequestInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiControllerMakeRequest(postAiRequestInDto: PostAiRequestInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAiRequestOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiControllerMakeRequest(postAiRequestInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiControllerMakeRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIApiFp(configuration)
    return {
        /**
         * 
         * @param {PostAiRequestInDto} postAiRequestInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiControllerMakeRequest(postAiRequestInDto: PostAiRequestInDto, options?: any): AxiosPromise<PostAiRequestOutDto> {
            return localVarFp.aiControllerMakeRequest(postAiRequestInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
    /**
     * 
     * @param {PostAiRequestInDto} postAiRequestInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiControllerMakeRequest(postAiRequestInDto: PostAiRequestInDto, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiControllerMakeRequest(postAiRequestInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetAnalytics: async (days: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'days' is not null or undefined
            assertParamExists('analyticsControllerGetAnalytics', 'days', days)
            const localVarPath = `/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerGetAnalytics(days: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAnalyticsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerGetAnalytics(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerGetAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetAnalytics(days: number, options?: any): AxiosPromise<GetAnalyticsOutDto> {
            return localVarFp.analyticsControllerGetAnalytics(days, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @param {number} days 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerGetAnalytics(days: number, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerGetAnalytics(days, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangePasswordInDto} changePasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (changePasswordInDto: ChangePasswordInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordInDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'changePasswordInDto', changePasswordInDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCheckTokenExpiration: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/checktokenexpiration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetUserGuidFromEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authControllerGetUserGuidFromEmail', 'email', email)
            const localVarPath = `/auth/guidfromemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginInputData: LoginInputData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInputData' is not null or undefined
            assertParamExists('authControllerLogin', 'loginInputData', loginInputData)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('authControllerLoginWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPasswordInDto} resetPasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordInDto: ResetPasswordInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordInDto' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordInDto', resetPasswordInDto)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSendResetToken: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authControllerSendResetToken', 'email', email)
            const localVarPath = `/auth/send-reset-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInDto} signUpInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signUpInDto: SignUpInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpInDto' is not null or undefined
            assertParamExists('authControllerSignup', 'signUpInDto', signUpInDto)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignupWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('authControllerSignupWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/signup/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordInDto} changePasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(changePasswordInDto: ChangePasswordInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(changePasswordInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCheckTokenExpiration(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCheckTokenExpiration(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerCheckTokenExpiration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetUserGuidFromEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetUserGuidFromEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginInputData: LoginInputData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginInputData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithGoogle(postGoogleLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLoginWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResetPasswordInDto} resetPasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordInDto: ResetPasswordInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSendResetToken(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSendResetToken(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSendResetToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInDto} signUpInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signUpInDto: SignUpInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signUpInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignupWithGoogle(postGoogleLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignupWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordInDto} changePasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(changePasswordInDto: ChangePasswordInDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerChangePassword(changePasswordInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCheckTokenExpiration(options?: any): AxiosPromise<boolean> {
            return localVarFp.authControllerCheckTokenExpiration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetUserGuidFromEmail(email: string, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerGetUserGuidFromEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginInputData: LoginInputData, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerLogin(loginInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerLoginWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetPasswordInDto} resetPasswordInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordInDto: ResetPasswordInDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerResetPassword(resetPasswordInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSendResetToken(email: string, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSendResetToken(email, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInDto} signUpInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signUpInDto: SignUpInDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignup(signUpInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerSignupWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {ChangePasswordInDto} changePasswordInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerChangePassword(changePasswordInDto: ChangePasswordInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerChangePassword(changePasswordInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCheckTokenExpiration(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCheckTokenExpiration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetUserGuidFromEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using email and password.
     * @summary Logs in the user using email and password.
     * @param {LoginInputData} loginInputData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginInputData: LoginInputData, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using Google.
     * @summary Logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLoginWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetPasswordInDto} resetPasswordInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPassword(resetPasswordInDto: ResetPasswordInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(resetPasswordInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSendResetToken(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSendResetToken(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up using email and password.
     * @summary Signs up the user using email and password.
     * @param {SignUpInDto} signUpInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignup(signUpInDto: SignUpInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(signUpInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
     * @summary Signs up or logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignupWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMonitorControllerRoot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monitor/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusMonitorControllerRoot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusMonitorControllerRoot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.statusMonitorControllerRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMonitorControllerRoot(options?: any): AxiosPromise<void> {
            return localVarFp.statusMonitorControllerRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statusMonitorControllerRoot(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statusMonitorControllerRoot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup: async (postCreateGroupBody: PostCreateGroupBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateGroupBody' is not null or undefined
            assertParamExists('groupControllerCreateGroup', 'postCreateGroupBody', postCreateGroupBody)
            const localVarPath = `/group/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateGroupBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup: async (guid?: string, code?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupInfo: async (guid?: string, code?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupSelection: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('groupControllerGetGroupSelection', 'guid', guid)
            const localVarPath = `/group/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerSearchGroups: async (searchString: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchString' is not null or undefined
            assertParamExists('groupControllerSearchGroups', 'searchString', searchString)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroupPayload: async (setGroupPayloadInDto: SetGroupPayloadInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setGroupPayloadInDto' is not null or undefined
            assertParamExists('groupControllerUpdateGroupPayload', 'setGroupPayloadInDto', setGroupPayloadInDto)
            const localVarPath = `/payload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGroupPayloadInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateGroupResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerCreateGroup(postCreateGroupBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerCreateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerDeleteGroup(guid?: string, code?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerDeleteGroup(guid, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupsCountResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupInfo(guid?: string, code?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupInfoResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupInfo(guid, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetGroupInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupSelection(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupSelection(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetGroupSelection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGroupListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetGroupsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerSearchGroups(searchString: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerSearchGroups(searchString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerSearchGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerUpdateGroupPayload(setGroupPayloadInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerUpdateGroupPayload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: any): AxiosPromise<PostCreateGroupResult> {
            return localVarFp.groupControllerCreateGroup(postCreateGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup(guid?: string, code?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.groupControllerDeleteGroup(guid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetCount(options?: any): AxiosPromise<GetGroupsCountResult> {
            return localVarFp.groupControllerGetCount(options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupInfo(guid?: string, code?: string, options?: any): AxiosPromise<GetGroupInfoResult> {
            return localVarFp.groupControllerGetGroupInfo(guid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupSelection(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.groupControllerGetGroupSelection(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupsList(options?: any): AxiosPromise<Array<GetGroupListItem>> {
            return localVarFp.groupControllerGetGroupsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerSearchGroups(searchString: string, options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.groupControllerSearchGroups(searchString, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: any): AxiosPromise<void> {
            return localVarFp.groupControllerUpdateGroupPayload(setGroupPayloadInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * The function creates a new group. Only admin users can access this endpoint.
     * @summary Creates a new group.
     * @param {PostCreateGroupBody} postCreateGroupBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerCreateGroup(postCreateGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function deletes a group. Only admin users can access this endpoint.
     * @summary Deletes a group.
     * @param {string} [guid] 
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerDeleteGroup(guid?: string, code?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerDeleteGroup(guid, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns number of all groups.
     * @summary Returns number of all groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetCount(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns information about a group.
     * @summary Returns information about a group.
     * @param {string} [guid] 
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupInfo(guid?: string, code?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupInfo(guid, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns the selection of a group.
     * @summary Returns the selection of a group.
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupSelection(guid: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupSelection(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns a list of all groups. Only admin users can access this endpoint.
     * @summary Returns a list of all groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupsList(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchString 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerSearchGroups(searchString: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerSearchGroups(searchString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerUpdateGroupPayload(setGroupPayloadInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MailApi - axios parameter creator
 * @export
 */
export const MailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailControllerSendFeedbackMail: async (postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendMailFeedbackInDto' is not null or undefined
            assertParamExists('mailControllerSendFeedbackMail', 'postSendMailFeedbackInDto', postSendMailFeedbackInDto)
            const localVarPath = `/mail/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendMailFeedbackInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailControllerSendTestMail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mail/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mailControllerSendFeedbackMail(postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mailControllerSendFeedbackMail(postSendMailFeedbackInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.mailControllerSendFeedbackMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mailControllerSendTestMail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mailControllerSendTestMail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.mailControllerSendTestMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailApiFp(configuration)
    return {
        /**
         * 
         * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailControllerSendFeedbackMail(postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options?: any): AxiosPromise<void> {
            return localVarFp.mailControllerSendFeedbackMail(postSendMailFeedbackInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailControllerSendTestMail(options?: any): AxiosPromise<void> {
            return localVarFp.mailControllerSendTestMail(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
    /**
     * 
     * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public mailControllerSendFeedbackMail(postSendMailFeedbackInDto: PostSendMailFeedbackInDto, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).mailControllerSendFeedbackMail(postSendMailFeedbackInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public mailControllerSendTestMail(options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).mailControllerSendTestMail(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessengerApi - axios parameter creator
 * @export
 */
export const MessengerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostFeedback: async (postSendFeedbackBody: PostSendFeedbackBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendFeedbackBody' is not null or undefined
            assertParamExists('messengerControllerPostFeedback', 'postSendFeedbackBody', postSendFeedbackBody)
            const localVarPath = `/sendfeedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendFeedbackBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostMessage: async (postSendMessageBody: PostSendMessageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendMessageBody' is not null or undefined
            assertParamExists('messengerControllerPostMessage', 'postSendMessageBody', postSendMessageBody)
            const localVarPath = `/sendmessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendMessageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends a formatted message to the messenger.
         * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerSendCustomMessage: async (postSendCustomMessageBody: PostSendCustomMessageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendCustomMessageBody' is not null or undefined
            assertParamExists('messengerControllerSendCustomMessage', 'postSendCustomMessageBody', postSendCustomMessageBody)
            const localVarPath = `/sendCustomMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendCustomMessageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessengerApi - functional programming interface
 * @export
 */
export const MessengerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessengerApiAxiosParamCreator(configuration)
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerPostFeedback(postSendFeedbackBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.messengerControllerPostFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerPostMessage(postSendMessageBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.messengerControllerPostMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sends a formatted message to the messenger.
         * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerSendCustomMessage(postSendCustomMessageBody: PostSendCustomMessageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerSendCustomMessage(postSendCustomMessageBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.messengerControllerSendCustomMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessengerApi - factory interface
 * @export
 */
export const MessengerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessengerApiFp(configuration)
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerPostFeedback(postSendFeedbackBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerPostMessage(postSendMessageBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends a formatted message to the messenger.
         * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerSendCustomMessage(postSendCustomMessageBody: PostSendCustomMessageBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerSendCustomMessage(postSendCustomMessageBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessengerApi - object-oriented interface
 * @export
 * @class MessengerApi
 * @extends {BaseAPI}
 */
export class MessengerApi extends BaseAPI {
    /**
     * Handles the HTTP POST request for sending feedback.
     * @summary Sends a feedback to the messenger.
     * @param {PostSendFeedbackBody} postSendFeedbackBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerPostFeedback(postSendFeedbackBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function sends a message using the messenger service and returns a success message if the message is not empty.
     * @summary Sends a message to the messenger.
     * @param {PostSendMessageBody} postSendMessageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerPostMessage(postSendMessageBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends a formatted message to the messenger.
     * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerSendCustomMessage(postSendCustomMessageBody: PostSendCustomMessageBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerSendCustomMessage(postSendCustomMessageBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToGroup: async (addPermissionToGroupInDto: AddPermissionToGroupInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToGroupInDto' is not null or undefined
            assertParamExists('permissionControllerAddPermissionToGroup', 'addPermissionToGroupInDto', addPermissionToGroupInDto)
            const localVarPath = `/permissions/group/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToGroupInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('permissionControllerAddPermissionToUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetAllUsersWithPermission: async (type: string, payload?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('permissionControllerGetAllUsersWithPermission', 'type', type)
            const localVarPath = `/permissions/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (payload !== undefined) {
                localVarQueryParameter['payload'] = payload;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetOrAddPermission: async (getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOrCreatePermissionInDto' is not null or undefined
            assertParamExists('permissionControllerGetOrAddPermission', 'getOrCreatePermissionInDto', getOrCreatePermissionInDto)
            const localVarPath = `/permissions/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrCreatePermissionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetUserPermissions: async (userGuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userGuid !== undefined) {
                localVarQueryParameter['userGuid'] = userGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromGroup: async (addPermissionToGroupInDto: AddPermissionToGroupInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToGroupInDto' is not null or undefined
            assertParamExists('permissionControllerRemovePermissionFromGroup', 'addPermissionToGroupInDto', addPermissionToGroupInDto)
            const localVarPath = `/permissions/group/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToGroupInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('permissionControllerRemovePermissionFromUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerAddPermissionToGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionUserGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerAddPermissionToGroup(addPermissionToGroupInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerAddPermissionToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerAddPermissionToUser(addPermissionToUserInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerAddPermissionToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionUserBaseOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetAllUsersWithPermission(type, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerGetAllUsersWithPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerGetOrAddPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserPermissionOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetUserPermissions(userGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerGetUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerRemovePermissionFromGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionUserGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerRemovePermissionFromGroup(addPermissionToGroupInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerRemovePermissionFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerRemovePermissionFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: any): AxiosPromise<PermissionUserGroup> {
            return localVarFp.permissionControllerAddPermissionToGroup(addPermissionToGroupInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerAddPermissionToUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: any): AxiosPromise<Array<PermissionUserBaseOutDto>> {
            return localVarFp.permissionControllerGetAllUsersWithPermission(type, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetUserPermissions(userGuid?: string, options?: any): AxiosPromise<Array<GetUserPermissionOutDto>> {
            return localVarFp.permissionControllerGetUserPermissions(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: any): AxiosPromise<PermissionUserGroup> {
            return localVarFp.permissionControllerRemovePermissionFromGroup(addPermissionToGroupInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerAddPermissionToGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerAddPermissionToGroup(addPermissionToGroupInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerAddPermissionToUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} type 
     * @param {string} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetAllUsersWithPermission(type, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userGuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetUserPermissions(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerRemovePermissionFromGroup(addPermissionToGroupInDto: AddPermissionToGroupInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerRemovePermissionFromGroup(addPermissionToGroupInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistEditingApi - axios parameter creator
 * @export
 */
export const PlaylistEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerAddVariantToPlaylist: async (addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addVariantToPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerAddVariantToPlaylist', 'addVariantToPlaylistInDto', addVariantToPlaylistInDto)
            const localVarPath = `/playlist/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVariantToPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerCreatePlaylist: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerDeletePlaylist: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('playlistEditingControllerDeletePlaylist', 'guid', guid)
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EditItemInDto} editItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerEditItem: async (editItemInDto: EditItemInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editItemInDto' is not null or undefined
            assertParamExists('playlistEditingControllerEditItem', 'editItemInDto', editItemInDto)
            const localVarPath = `/playlist/edititem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editItemInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerIsItemEditable: async (itemGuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemGuid' is not null or undefined
            assertParamExists('playlistEditingControllerIsItemEditable', 'itemGuid', itemGuid)
            const localVarPath = `/playlist/isitemeditable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemGuid !== undefined) {
                localVarQueryParameter['itemGuid'] = itemGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRemoveVariantFromPlaylistDelete: async (packGuid: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('playlistEditingControllerRemoveVariantFromPlaylistDelete', 'packGuid', packGuid)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistEditingControllerRemoveVariantFromPlaylistDelete', 'playlist', playlist)
            const localVarPath = `/playlist/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRenamePlaylist: async (renamePlaylistInDto: RenamePlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renamePlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerRenamePlaylist', 'renamePlaylistInDto', renamePlaylistInDto)
            const localVarPath = `/playlist/rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renamePlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerReorderPlaylist: async (reorderPlaylistInDto: ReorderPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reorderPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerReorderPlaylist', 'reorderPlaylistInDto', reorderPlaylistInDto)
            const localVarPath = `/playlist/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequireItemEditInDto} requireItemEditInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRequireItemEdit: async (requireItemEditInDto: RequireItemEditInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requireItemEditInDto' is not null or undefined
            assertParamExists('playlistEditingControllerRequireItemEdit', 'requireItemEditInDto', requireItemEditInDto)
            const localVarPath = `/playlist/requireItemEdit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requireItemEditInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerTransposePlaylistItem: async (transposePlaylistItemInDto: TransposePlaylistItemInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transposePlaylistItemInDto' is not null or undefined
            assertParamExists('playlistEditingControllerTransposePlaylistItem', 'transposePlaylistItemInDto', transposePlaylistItemInDto)
            const localVarPath = `/playlist/transpose`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transposePlaylistItemInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistEditingApi - functional programming interface
 * @export
 */
export const PlaylistEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItemOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerAddVariantToPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerCreatePlaylist(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreatePlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerCreatePlaylist(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerCreatePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerDeletePlaylist(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerDeletePlaylist(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerDeletePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EditItemInDto} editItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerEditItem(editItemInDto: EditItemInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerEditItem(editItemInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerEditItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} itemGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerIsItemEditable(itemGuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerIsItemEditable(itemGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerIsItemEditable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRemoveVariantFromPlaylistDelete(packGuid: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRemoveVariantFromPlaylistDelete(packGuid, playlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRemoveVariantFromPlaylistDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRenamePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerReorderPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RequireItemEditInDto} requireItemEditInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRequireItemEdit(requireItemEditInDto: RequireItemEditInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRequireItemEdit(requireItemEditInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRequireItemEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerTransposePlaylistItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistEditingApi - factory interface
 * @export
 */
export const PlaylistEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: any): AxiosPromise<PlaylistItemOutDto> {
            return localVarFp.playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerCreatePlaylist(options?: any): AxiosPromise<PostCreatePlaylistResult> {
            return localVarFp.playlistEditingControllerCreatePlaylist(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerDeletePlaylist(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerDeletePlaylist(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EditItemInDto} editItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerEditItem(editItemInDto: EditItemInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerEditItem(editItemInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemGuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerIsItemEditable(itemGuid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerIsItemEditable(itemGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRemoveVariantFromPlaylistDelete(packGuid: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRemoveVariantFromPlaylistDelete(packGuid, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequireItemEditInDto} requireItemEditInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRequireItemEdit(requireItemEditInDto: RequireItemEditInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRequireItemEdit(requireItemEditInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistEditingApi - object-oriented interface
 * @export
 * @class PlaylistEditingApi
 * @extends {BaseAPI}
 */
export class PlaylistEditingApi extends BaseAPI {
    /**
     * 
     * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerCreatePlaylist(options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerCreatePlaylist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerDeletePlaylist(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerDeletePlaylist(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EditItemInDto} editItemInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerEditItem(editItemInDto: EditItemInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerEditItem(editItemInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemGuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerIsItemEditable(itemGuid: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerIsItemEditable(itemGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRemoveVariantFromPlaylistDelete(packGuid: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRemoveVariantFromPlaylistDelete(packGuid, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RenamePlaylistInDto} renamePlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequireItemEditInDto} requireItemEditInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRequireItemEdit(requireItemEditInDto: RequireItemEditInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRequireItemEdit(requireItemEditInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistGettingApi - axios parameter creator
 * @export
 */
export const PlaylistGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistDataByGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('playlistGettingControllerGetPlaylistDataByGuid', 'guid', guid)
            const localVarPath = `/playlist/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistsOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist/ofuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerIsVariantInPlaylist: async (packGuid: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packGuid' is not null or undefined
            assertParamExists('playlistGettingControllerIsVariantInPlaylist', 'packGuid', packGuid)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistGettingControllerIsVariantInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/contains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (packGuid !== undefined) {
                localVarQueryParameter['packGuid'] = packGuid;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerSearchInPlaylist: async (searchKey: string, playlist: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('playlistGettingControllerSearchInPlaylist', 'searchKey', searchKey)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistGettingControllerSearchInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistGettingApi - functional programming interface
 * @export
 */
export const PlaylistGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerGetPlaylistDataByGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerGetPlaylistDataByGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerGetPlaylistsOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlaylistsResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerGetPlaylistsOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerGetPlaylistsOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerIsVariantInPlaylist(packGuid: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerIsVariantInPlaylist(packGuid, playlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerIsVariantInPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchInPlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerSearchInPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistGettingApi - factory interface
 * @export
 */
export const PlaylistGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.playlistGettingControllerGetPlaylistDataByGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistsOfUser(options?: any): AxiosPromise<GetPlaylistsResult> {
            return localVarFp.playlistGettingControllerGetPlaylistsOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} packGuid 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerIsVariantInPlaylist(packGuid: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistGettingControllerIsVariantInPlaylist(packGuid, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: any): AxiosPromise<GetSearchInPlaylistResult> {
            return localVarFp.playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistGettingApi - object-oriented interface
 * @export
 * @class PlaylistGettingApi
 * @extends {BaseAPI}
 */
export class PlaylistGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerGetPlaylistDataByGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerGetPlaylistsOfUser(options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerGetPlaylistsOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} packGuid 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerIsVariantInPlaylist(packGuid: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerIsVariantInPlaylist(packGuid, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchKey 
     * @param {string} playlist 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramSongAddingApi - axios parameter creator
 * @export
 */
export const ProgramSongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programSongAddingControllerProcessDataStream: async (programSongData: ProgramSongData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programSongData' is not null or undefined
            assertParamExists('programSongAddingControllerProcessDataStream', 'programSongData', programSongData)
            const localVarPath = `/song/processdatastream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(programSongData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramSongAddingApi - functional programming interface
 * @export
 */
export const ProgramSongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramSongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programSongAddingControllerProcessDataStream(programSongData: ProgramSongData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programSongAddingControllerProcessDataStream(programSongData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramSongAddingApi.programSongAddingControllerProcessDataStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramSongAddingApi - factory interface
 * @export
 */
export const ProgramSongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramSongAddingApiFp(configuration)
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programSongAddingControllerProcessDataStream(programSongData: ProgramSongData, options?: any): AxiosPromise<boolean> {
            return localVarFp.programSongAddingControllerProcessDataStream(programSongData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramSongAddingApi - object-oriented interface
 * @export
 * @class ProgramSongAddingApi
 * @extends {BaseAPI}
 */
export class ProgramSongAddingApi extends BaseAPI {
    /**
     * This function process data stream from loader\'s program. Getter and so on.
     * @summary 
     * @param {ProgramSongData} programSongData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramSongAddingApi
     */
    public programSongAddingControllerProcessDataStream(programSongData: ProgramSongData, options?: RawAxiosRequestConfig) {
        return ProgramSongAddingApiFp(this.configuration).programSongAddingControllerProcessDataStream(programSongData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongAddingApi - axios parameter creator
 * @export
 */
export const SongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterAddingControllerGetStatistics: async (days: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'days' is not null or undefined
            assertParamExists('getterAddingControllerGetStatistics', 'days', days)
            const localVarPath = `/getter/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreate: async (postCreateVariantInDto: PostCreateVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateVariantInDto' is not null or undefined
            assertParamExists('songAddingControllerCreate', 'postCreateVariantInDto', postCreateVariantInDto)
            const localVarPath = `/song`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreateCopy: async (postCreateCopyInDto: PostCreateCopyInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateCopyInDto' is not null or undefined
            assertParamExists('songAddingControllerCreateCopy', 'postCreateCopyInDto', postCreateCopyInDto)
            const localVarPath = `/song/create/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateCopyInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerIsParserAvailable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/parser/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerParse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongAddingApi - functional programming interface
 * @export
 */
export const SongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getterAddingControllerGetStatistics(days: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getterAddingControllerGetStatistics(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.getterAddingControllerGetStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerCreate(postCreateVariantInDto: PostCreateVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerCreate(postCreateVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateCopyOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerCreateCopy(postCreateCopyInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerCreateCopy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerIsParserAvailable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerIsParserAvailable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerIsParserAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerParse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParserSongDataResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerParse(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerParse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongAddingApi - factory interface
 * @export
 */
export const SongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongAddingApiFp(configuration)
    return {
        /**
         * 
         * @param {number} days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getterAddingControllerGetStatistics(days: number, options?: any): AxiosPromise<Statistics> {
            return localVarFp.getterAddingControllerGetStatistics(days, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreate(postCreateVariantInDto: PostCreateVariantInDto, options?: any): AxiosPromise<PostCreateVariantOutDto> {
            return localVarFp.songAddingControllerCreate(postCreateVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: any): AxiosPromise<PostCreateCopyOutDto> {
            return localVarFp.songAddingControllerCreateCopy(postCreateCopyInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerIsParserAvailable(options?: any): AxiosPromise<boolean> {
            return localVarFp.songAddingControllerIsParserAvailable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerParse(options?: any): AxiosPromise<ParserSongDataResult> {
            return localVarFp.songAddingControllerParse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongAddingApi - object-oriented interface
 * @export
 * @class SongAddingApi
 * @extends {BaseAPI}
 */
export class SongAddingApi extends BaseAPI {
    /**
     * 
     * @param {number} days 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public getterAddingControllerGetStatistics(days: number, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).getterAddingControllerGetStatistics(days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostCreateVariantInDto} postCreateVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerCreate(postCreateVariantInDto: PostCreateVariantInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerCreate(postCreateVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostCreateCopyInDto} postCreateCopyInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerCreateCopy(postCreateCopyInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerIsParserAvailable(options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerIsParserAvailable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerParse(options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerParse(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongDeletingApi - axios parameter creator
 * @export
 */
export const SongDeletingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerDelete: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songDeletingControllerDelete', 'guid', guid)
            const localVarPath = `/song/variant/delete/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerRestore: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songDeletingControllerRestore', 'guid', guid)
            const localVarPath = `/song/variant/restore/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongDeletingApi - functional programming interface
 * @export
 */
export const SongDeletingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongDeletingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songDeletingControllerDelete(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songDeletingControllerDelete(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongDeletingApi.songDeletingControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songDeletingControllerRestore(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songDeletingControllerRestore(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongDeletingApi.songDeletingControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongDeletingApi - factory interface
 * @export
 */
export const SongDeletingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongDeletingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerDelete(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.songDeletingControllerDelete(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerRestore(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.songDeletingControllerRestore(guid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongDeletingApi - object-oriented interface
 * @export
 * @class SongDeletingApi
 * @extends {BaseAPI}
 */
export class SongDeletingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public songDeletingControllerDelete(guid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).songDeletingControllerDelete(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public songDeletingControllerRestore(guid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).songDeletingControllerRestore(guid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongEditingApi - axios parameter creator
 * @export
 */
export const SongEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerChangeLanguage: async (postChangeLanguageInDto: PostChangeLanguageInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postChangeLanguageInDto' is not null or undefined
            assertParamExists('songEditingControllerChangeLanguage', 'postChangeLanguageInDto', postChangeLanguageInDto)
            const localVarPath = `/song/variant/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postChangeLanguageInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerEditVariant: async (postEditVariantInDto: PostEditVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postEditVariantInDto' is not null or undefined
            assertParamExists('songEditingControllerEditVariant', 'postEditVariantInDto', postEditVariantInDto)
            const localVarPath = `/song/variant/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postEditVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongEditingApi - functional programming interface
 * @export
 */
export const SongEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerChangeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerChangeLanguage(postChangeLanguageInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongEditingApi.songEditingControllerChangeLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerEditVariant(postEditVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongEditingApi.songEditingControllerEditVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongEditingApi - factory interface
 * @export
 */
export const SongEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerChangeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: any): AxiosPromise<SongVariant> {
            return localVarFp.songEditingControllerChangeLanguage(postChangeLanguageInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: any): AxiosPromise<EditVariantOutDto> {
            return localVarFp.songEditingControllerEditVariant(postEditVariantInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongEditingApi - object-oriented interface
 * @export
 * @class SongEditingApi
 * @extends {BaseAPI}
 */
export class SongEditingApi extends BaseAPI {
    /**
     * 
     * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerChangeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerChangeLanguage(postChangeLanguageInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostEditVariantInDto} postEditVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerEditVariant(postEditVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongGettingApi - axios parameter creator
 * @export
 */
export const SongGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetBySearch: async (searchKey: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('songGettingControllerGetBySearch', 'searchKey', searchKey)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('songGettingControllerGetBySearch', 'page', page)
            const localVarPath = `/song/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetList: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetPublicSongBySource: async (url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('songGettingControllerGetPublicSongBySource', 'url', url)
            const localVarPath = `/song/publicsongbysource/{url}`
                .replace(`{${"url"}}`, encodeURIComponent(String(url)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRandom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRecommendedSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongDataByVariantGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songGettingControllerGetSongDataByVariantGuid', 'guid', guid)
            const localVarPath = `/song/ofvariant/{guid}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongListOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetVariantFromAlias: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('songGettingControllerGetVariantFromAlias', 'alias', alias)
            const localVarPath = `/song/alias/variant/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerSearchGlobalSongsInPopup: async (searchString?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/teampopupglobalsongssearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerSearchMySongsInPopup: async (searchString?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/teampopupmysongssearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongGettingApi - functional programming interface
 * @export
 */
export const SongGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetBySearch(searchKey: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SongVariantDataOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetBySearch(searchKey, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetBySearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetList(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetListSongData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetList(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetPublicSongBySource(url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPackAliasFromSourceUrlOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetPublicSongBySource(url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetPublicSongBySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetRandom(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRandomVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetRandom(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetRandom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetRecommendedSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecommendedSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetRecommendedSongs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetRecommendedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSongDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongDataByVariantGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongDataByVariantGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongListOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVariantsOfUserOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongListOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongListOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetVariantFromAlias(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetVariantFromAlias(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetVariantFromAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerSearchGlobalSongsInPopup(searchString?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGlobalSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerSearchGlobalSongsInPopup(searchString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerSearchGlobalSongsInPopup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerSearchMySongsInPopup(searchString?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGlobalSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerSearchMySongsInPopup(searchString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerSearchMySongsInPopup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongGettingApi - factory interface
 * @export
 */
export const SongGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetBySearch(searchKey: string, page: number, options?: any): AxiosPromise<Array<SongVariantDataOutDto>> {
            return localVarFp.songGettingControllerGetBySearch(searchKey, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetList(page?: number, options?: any): AxiosPromise<Array<GetListSongData>> {
            return localVarFp.songGettingControllerGetList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetPublicSongBySource(url: string, options?: any): AxiosPromise<GetPackAliasFromSourceUrlOutDto> {
            return localVarFp.songGettingControllerGetPublicSongBySource(url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRandom(options?: any): AxiosPromise<GetRandomVariantOutDto> {
            return localVarFp.songGettingControllerGetRandom(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRecommendedSongs(options?: any): AxiosPromise<GetRecommendedSongsOutDto> {
            return localVarFp.songGettingControllerGetRecommendedSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongDataByVariantGuid(guid: string, options?: any): AxiosPromise<GetSongDataOutDto> {
            return localVarFp.songGettingControllerGetSongDataByVariantGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongListOfUser(options?: any): AxiosPromise<GetVariantsOfUserOutDto> {
            return localVarFp.songGettingControllerGetSongListOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongsCount(options?: any): AxiosPromise<number> {
            return localVarFp.songGettingControllerGetSongsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetVariantFromAlias(alias: string, options?: any): AxiosPromise<string> {
            return localVarFp.songGettingControllerGetVariantFromAlias(alias, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerSearchGlobalSongsInPopup(searchString?: string, options?: any): AxiosPromise<GetGlobalSongsOutDto> {
            return localVarFp.songGettingControllerSearchGlobalSongsInPopup(searchString, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
         * @summary 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerSearchMySongsInPopup(searchString?: string, options?: any): AxiosPromise<GetGlobalSongsOutDto> {
            return localVarFp.songGettingControllerSearchMySongsInPopup(searchString, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongGettingApi - object-oriented interface
 * @export
 * @class SongGettingApi
 * @extends {BaseAPI}
 */
export class SongGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} searchKey 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetBySearch(searchKey: string, page: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetBySearch(searchKey, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetList(page?: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} url 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetPublicSongBySource(url: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetPublicSongBySource(url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetRandom(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetRandom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetRecommendedSongs(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetRecommendedSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongDataByVariantGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongListOfUser(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongListOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongsCount(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetVariantFromAlias(alias: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetVariantFromAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
     * @summary 
     * @param {string} [searchString] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerSearchGlobalSongsInPopup(searchString?: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerSearchGlobalSongsInPopup(searchString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
     * @summary 
     * @param {string} [searchString] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerSearchMySongsInPopup(searchString?: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerSearchMySongsInPopup(searchString, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongPublishingApi - axios parameter creator
 * @export
 */
export const SongPublishingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerGenerateKeywords: async (postGetKeywordsInDto: PostGetKeywordsInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGetKeywordsInDto' is not null or undefined
            assertParamExists('songPublishingControllerGenerateKeywords', 'postGetKeywordsInDto', postGetKeywordsInDto)
            const localVarPath = `/song/generatekeywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGetKeywordsInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerGetKeywords: async (postGetKeywordsInDto: PostGetKeywordsInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGetKeywordsInDto' is not null or undefined
            assertParamExists('songPublishingControllerGetKeywords', 'postGetKeywordsInDto', postGetKeywordsInDto)
            const localVarPath = `/song/getkeywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGetKeywordsInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerPublishVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('songPublishingControllerPublishVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerUnpublishVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('songPublishingControllerUnpublishVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/unpublish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerVerifyVariant: async (postVerifyVariantInDto: PostVerifyVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postVerifyVariantInDto' is not null or undefined
            assertParamExists('songPublishingControllerVerifyVariant', 'postVerifyVariantInDto', postVerifyVariantInDto)
            const localVarPath = `/song/verifystatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postVerifyVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongPublishingApi - functional programming interface
 * @export
 */
export const SongPublishingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongPublishingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerGenerateKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerGenerateKeywords(postGetKeywordsInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerGenerateKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerGetKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerGetKeywords(postGetKeywordsInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerGetKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerPublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerPublishVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerPublishVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerUnpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerUnpublishVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerUnpublishVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerVerifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerVerifyVariant(postVerifyVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerVerifyVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongPublishingApi - factory interface
 * @export
 */
export const SongPublishingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongPublishingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerGenerateKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: any): AxiosPromise<void> {
            return localVarFp.songPublishingControllerGenerateKeywords(postGetKeywordsInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerGetKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: any): AxiosPromise<void> {
            return localVarFp.songPublishingControllerGetKeywords(postGetKeywordsInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerPublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.songPublishingControllerPublishVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerUnpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.songPublishingControllerUnpublishVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerVerifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: any): AxiosPromise<SongVariant> {
            return localVarFp.songPublishingControllerVerifyVariant(postVerifyVariantInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongPublishingApi - object-oriented interface
 * @export
 * @class SongPublishingApi
 * @extends {BaseAPI}
 */
export class SongPublishingApi extends BaseAPI {
    /**
     * 
     * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerGenerateKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerGenerateKeywords(postGetKeywordsInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostGetKeywordsInDto} postGetKeywordsInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerGetKeywords(postGetKeywordsInDto: PostGetKeywordsInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerGetKeywords(postGetKeywordsInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerPublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerPublishVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerUnpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerUnpublishVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerVerifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerVerifyVariant(postVerifyVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongValidationApi - axios parameter creator
 * @export
 */
export const SongValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songValidationControllerValidateSheetDataAndTitle: async (postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postValidateSheetDataAndTitleInDto' is not null or undefined
            assertParamExists('songValidationControllerValidateSheetDataAndTitle', 'postValidateSheetDataAndTitleInDto', postValidateSheetDataAndTitleInDto)
            const localVarPath = `/song/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postValidateSheetDataAndTitleInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongValidationApi - functional programming interface
 * @export
 */
export const SongValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongValidationApi.songValidationControllerValidateSheetDataAndTitle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongValidationApi - factory interface
 * @export
 */
export const SongValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongValidationApiFp(configuration)
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: any): AxiosPromise<ValidationResult> {
            return localVarFp.songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongValidationApi - object-oriented interface
 * @export
 * @class SongValidationApi
 * @extends {BaseAPI}
 */
export class SongValidationApi extends BaseAPI {
    /**
     * 
     * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongValidationApi
     */
    public songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: RawAxiosRequestConfig) {
        return SongValidationApiFp(this.configuration).songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamAddingApi - axios parameter creator
 * @export
 */
export const TeamAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTeamInDto} createTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAddingControllerCreateNewTeam: async (createTeamInDto: CreateTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamInDto' is not null or undefined
            assertParamExists('teamAddingControllerCreateNewTeam', 'createTeamInDto', createTeamInDto)
            const localVarPath = `/submodules/teams/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamAddingApi - functional programming interface
 * @export
 */
export const TeamAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTeamInDto} createTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAddingControllerCreateNewTeam(createTeamInDto: CreateTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAddingControllerCreateNewTeam(createTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamAddingApi.teamAddingControllerCreateNewTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamAddingApi - factory interface
 * @export
 */
export const TeamAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamAddingApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTeamInDto} createTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAddingControllerCreateNewTeam(createTeamInDto: CreateTeamInDto, options?: any): AxiosPromise<CreateTeamOutDto> {
            return localVarFp.teamAddingControllerCreateNewTeam(createTeamInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamAddingApi - object-oriented interface
 * @export
 * @class TeamAddingApi
 * @extends {BaseAPI}
 */
export class TeamAddingApi extends BaseAPI {
    /**
     * 
     * @param {CreateTeamInDto} createTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAddingApi
     */
    public teamAddingControllerCreateNewTeam(createTeamInDto: CreateTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamAddingApiFp(this.configuration).teamAddingControllerCreateNewTeam(createTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamEditingApi - axios parameter creator
 * @export
 */
export const TeamEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamEditingControllerChangeTeamInfo: async (changeTeamInfoInDto: ChangeTeamInfoInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeTeamInfoInDto' is not null or undefined
            assertParamExists('teamEditingControllerChangeTeamInfo', 'changeTeamInfoInDto', changeTeamInfoInDto)
            const localVarPath = `/submodules/teams/changeteaminfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeTeamInfoInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSelectionControllerAddPackToTeam: async (addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPackToTeamSelectionInDto' is not null or undefined
            assertParamExists('teamSelectionControllerAddPackToTeam', 'addPackToTeamSelectionInDto', addPackToTeamSelectionInDto)
            const localVarPath = `/submodules/teams/selection/add/pack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPackToTeamSelectionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSelectionControllerRemovePackFromTeam: async (addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPackToTeamSelectionInDto' is not null or undefined
            assertParamExists('teamSelectionControllerRemovePackFromTeam', 'addPackToTeamSelectionInDto', addPackToTeamSelectionInDto)
            const localVarPath = `/submodules/teams/selection/remove/pack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPackToTeamSelectionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReplaceWithCopyInDto} replaceWithCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSelectionControllerReplaceWithCopy: async (replaceWithCopyInDto: ReplaceWithCopyInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'replaceWithCopyInDto' is not null or undefined
            assertParamExists('teamSelectionControllerReplaceWithCopy', 'replaceWithCopyInDto', replaceWithCopyInDto)
            const localVarPath = `/submodules/teams/selection/replacewithcopy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceWithCopyInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamEditingApi - functional programming interface
 * @export
 */
export const TeamEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamEditingControllerChangeTeamInfo(changeTeamInfoInDto: ChangeTeamInfoInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamEditingControllerChangeTeamInfo(changeTeamInfoInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.teamEditingControllerChangeTeamInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamSelectionControllerAddPackToTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItemOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamSelectionControllerAddPackToTeam(addPackToTeamSelectionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.teamSelectionControllerAddPackToTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamSelectionControllerRemovePackFromTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamSelectionControllerRemovePackFromTeam(addPackToTeamSelectionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.teamSelectionControllerRemovePackFromTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ReplaceWithCopyInDto} replaceWithCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamSelectionControllerReplaceWithCopy(replaceWithCopyInDto: ReplaceWithCopyInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReplaceWithCopyOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamSelectionControllerReplaceWithCopy(replaceWithCopyInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamEditingApi.teamSelectionControllerReplaceWithCopy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamEditingApi - factory interface
 * @export
 */
export const TeamEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamEditingControllerChangeTeamInfo(changeTeamInfoInDto: ChangeTeamInfoInDto, options?: any): AxiosPromise<void> {
            return localVarFp.teamEditingControllerChangeTeamInfo(changeTeamInfoInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSelectionControllerAddPackToTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: any): AxiosPromise<PlaylistItemOutDto> {
            return localVarFp.teamSelectionControllerAddPackToTeam(addPackToTeamSelectionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSelectionControllerRemovePackFromTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.teamSelectionControllerRemovePackFromTeam(addPackToTeamSelectionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReplaceWithCopyInDto} replaceWithCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamSelectionControllerReplaceWithCopy(replaceWithCopyInDto: ReplaceWithCopyInDto, options?: any): AxiosPromise<ReplaceWithCopyOutDto> {
            return localVarFp.teamSelectionControllerReplaceWithCopy(replaceWithCopyInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamEditingApi - object-oriented interface
 * @export
 * @class TeamEditingApi
 * @extends {BaseAPI}
 */
export class TeamEditingApi extends BaseAPI {
    /**
     * 
     * @param {ChangeTeamInfoInDto} changeTeamInfoInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public teamEditingControllerChangeTeamInfo(changeTeamInfoInDto: ChangeTeamInfoInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).teamEditingControllerChangeTeamInfo(changeTeamInfoInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public teamSelectionControllerAddPackToTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).teamSelectionControllerAddPackToTeam(addPackToTeamSelectionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public teamSelectionControllerRemovePackFromTeam(addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).teamSelectionControllerRemovePackFromTeam(addPackToTeamSelectionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReplaceWithCopyInDto} replaceWithCopyInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamEditingApi
     */
    public teamSelectionControllerReplaceWithCopy(replaceWithCopyInDto: ReplaceWithCopyInDto, options?: RawAxiosRequestConfig) {
        return TeamEditingApiFp(this.configuration).teamSelectionControllerReplaceWithCopy(replaceWithCopyInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamGettingApi - axios parameter creator
 * @export
 */
export const TeamGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamGettingControllerGetAliasBySubdomain: async (subdomain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subdomain' is not null or undefined
            assertParamExists('teamGettingControllerGetAliasBySubdomain', 'subdomain', subdomain)
            const localVarPath = `/submodules/teams/aliasbysubdomain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subdomain !== undefined) {
                localVarQueryParameter['subdomain'] = subdomain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamGettingControllerGetTeamBasicInfo: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('teamGettingControllerGetTeamBasicInfo', 'alias', alias)
            const localVarPath = `/submodules/teams/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamGettingApi - functional programming interface
 * @export
 */
export const TeamGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamGettingControllerGetAliasBySubdomain(subdomain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamAliasFromSubdomainOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamGettingControllerGetAliasBySubdomain(subdomain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamGettingApi.teamGettingControllerGetAliasBySubdomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamGettingControllerGetTeamBasicInfo(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamInfoOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamGettingControllerGetTeamBasicInfo(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamGettingApi.teamGettingControllerGetTeamBasicInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamGettingApi - factory interface
 * @export
 */
export const TeamGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamGettingControllerGetAliasBySubdomain(subdomain: string, options?: any): AxiosPromise<GetTeamAliasFromSubdomainOutDto> {
            return localVarFp.teamGettingControllerGetAliasBySubdomain(subdomain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamGettingControllerGetTeamBasicInfo(alias: string, options?: any): AxiosPromise<GetTeamInfoOutDto> {
            return localVarFp.teamGettingControllerGetTeamBasicInfo(alias, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamGettingApi - object-oriented interface
 * @export
 * @class TeamGettingApi
 * @extends {BaseAPI}
 */
export class TeamGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} subdomain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamGettingApi
     */
    public teamGettingControllerGetAliasBySubdomain(subdomain: string, options?: RawAxiosRequestConfig) {
        return TeamGettingApiFp(this.configuration).teamGettingControllerGetAliasBySubdomain(subdomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamGettingApi
     */
    public teamGettingControllerGetTeamBasicInfo(alias: string, options?: RawAxiosRequestConfig) {
        return TeamGettingApiFp(this.configuration).teamGettingControllerGetTeamBasicInfo(alias, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamJoiningApi - axios parameter creator
 * @export
 */
export const TeamJoiningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamJoiningControllerGetJoinCode: async (teamAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAlias' is not null or undefined
            assertParamExists('teamJoiningControllerGetJoinCode', 'teamAlias', teamAlias)
            const localVarPath = `/submodules/teams/joincode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamAlias !== undefined) {
                localVarQueryParameter['teamAlias'] = teamAlias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JoinTeamInDto} joinTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamJoiningControllerJoinTeam: async (joinTeamInDto: JoinTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'joinTeamInDto' is not null or undefined
            assertParamExists('teamJoiningControllerJoinTeam', 'joinTeamInDto', joinTeamInDto)
            const localVarPath = `/submodules/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamJoiningApi - functional programming interface
 * @export
 */
export const TeamJoiningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamJoiningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamJoiningControllerGetJoinCode(teamAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJoinCodeOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamJoiningControllerGetJoinCode(teamAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamJoiningApi.teamJoiningControllerGetJoinCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {JoinTeamInDto} joinTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamJoiningControllerJoinTeam(joinTeamInDto: JoinTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JoinTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamJoiningControllerJoinTeam(joinTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamJoiningApi.teamJoiningControllerJoinTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamJoiningApi - factory interface
 * @export
 */
export const TeamJoiningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamJoiningApiFp(configuration)
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamJoiningControllerGetJoinCode(teamAlias: string, options?: any): AxiosPromise<GetJoinCodeOutDto> {
            return localVarFp.teamJoiningControllerGetJoinCode(teamAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JoinTeamInDto} joinTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamJoiningControllerJoinTeam(joinTeamInDto: JoinTeamInDto, options?: any): AxiosPromise<JoinTeamOutDto> {
            return localVarFp.teamJoiningControllerJoinTeam(joinTeamInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamJoiningApi - object-oriented interface
 * @export
 * @class TeamJoiningApi
 * @extends {BaseAPI}
 */
export class TeamJoiningApi extends BaseAPI {
    /**
     * 
     * @param {string} teamAlias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamJoiningApi
     */
    public teamJoiningControllerGetJoinCode(teamAlias: string, options?: RawAxiosRequestConfig) {
        return TeamJoiningApiFp(this.configuration).teamJoiningControllerGetJoinCode(teamAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JoinTeamInDto} joinTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamJoiningApi
     */
    public teamJoiningControllerJoinTeam(joinTeamInDto: JoinTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamJoiningApiFp(this.configuration).teamJoiningControllerJoinTeam(joinTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamMembersApi - axios parameter creator
 * @export
 */
export const TeamMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerGetTeamMembers: async (teamAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAlias' is not null or undefined
            assertParamExists('teamMemberControllerGetTeamMembers', 'teamAlias', teamAlias)
            const localVarPath = `/submodules/teams/ofteam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamAlias !== undefined) {
                localVarQueryParameter['teamAlias'] = teamAlias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerIsUserMemberOfTeam: async (teamAlias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAlias' is not null or undefined
            assertParamExists('teamMemberControllerIsUserMemberOfTeam', 'teamAlias', teamAlias)
            const localVarPath = `/submodules/teams/isUserMemberOfTeam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (teamAlias !== undefined) {
                localVarQueryParameter['teamAlias'] = teamAlias;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LeaveTeamInDto} leaveTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerLeaveTeam: async (leaveTeamInDto: LeaveTeamInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaveTeamInDto' is not null or undefined
            assertParamExists('teamMemberControllerLeaveTeam', 'leaveTeamInDto', leaveTeamInDto)
            const localVarPath = `/submodules/teams/leaveteam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveTeamInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetMemberRoleInDto} setMemberRoleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerSetMemberRole: async (setMemberRoleInDto: SetMemberRoleInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setMemberRoleInDto' is not null or undefined
            assertParamExists('teamMemberControllerSetMemberRole', 'setMemberRoleInDto', setMemberRoleInDto)
            const localVarPath = `/submodules/teams/setrole`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setMemberRoleInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamMembersApi - functional programming interface
 * @export
 */
export const TeamMembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamMembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMemberControllerGetTeamMembers(teamAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamMembersOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMemberControllerGetTeamMembers(teamAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.teamMemberControllerGetTeamMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMemberControllerIsUserMemberOfTeam(teamAlias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsUserMemberOfTeamOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMemberControllerIsUserMemberOfTeam(teamAlias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.teamMemberControllerIsUserMemberOfTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LeaveTeamInDto} leaveTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMemberControllerLeaveTeam(leaveTeamInDto: LeaveTeamInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMemberControllerLeaveTeam(leaveTeamInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.teamMemberControllerLeaveTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetMemberRoleInDto} setMemberRoleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMemberControllerSetMemberRole(setMemberRoleInDto: SetMemberRoleInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMemberControllerSetMemberRole(setMemberRoleInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamMembersApi.teamMemberControllerSetMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamMembersApi - factory interface
 * @export
 */
export const TeamMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamMembersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerGetTeamMembers(teamAlias: string, options?: any): AxiosPromise<GetTeamMembersOutDto> {
            return localVarFp.teamMemberControllerGetTeamMembers(teamAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamAlias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerIsUserMemberOfTeam(teamAlias: string, options?: any): AxiosPromise<IsUserMemberOfTeamOutDto> {
            return localVarFp.teamMemberControllerIsUserMemberOfTeam(teamAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LeaveTeamInDto} leaveTeamInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerLeaveTeam(leaveTeamInDto: LeaveTeamInDto, options?: any): AxiosPromise<void> {
            return localVarFp.teamMemberControllerLeaveTeam(leaveTeamInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetMemberRoleInDto} setMemberRoleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberControllerSetMemberRole(setMemberRoleInDto: SetMemberRoleInDto, options?: any): AxiosPromise<void> {
            return localVarFp.teamMemberControllerSetMemberRole(setMemberRoleInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamMembersApi - object-oriented interface
 * @export
 * @class TeamMembersApi
 * @extends {BaseAPI}
 */
export class TeamMembersApi extends BaseAPI {
    /**
     * 
     * @param {string} teamAlias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public teamMemberControllerGetTeamMembers(teamAlias: string, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).teamMemberControllerGetTeamMembers(teamAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamAlias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public teamMemberControllerIsUserMemberOfTeam(teamAlias: string, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).teamMemberControllerIsUserMemberOfTeam(teamAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LeaveTeamInDto} leaveTeamInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public teamMemberControllerLeaveTeam(leaveTeamInDto: LeaveTeamInDto, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).teamMemberControllerLeaveTeam(leaveTeamInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetMemberRoleInDto} setMemberRoleInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public teamMemberControllerSetMemberRole(setMemberRoleInDto: SetMemberRoleInDto, options?: RawAxiosRequestConfig) {
        return TeamMembersApiFp(this.configuration).teamMemberControllerSetMemberRole(setMemberRoleInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerRegisterWebhookExtension: async (registerWebhookExtensionBody: RegisterWebhookExtensionBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerWebhookExtensionBody' is not null or undefined
            assertParamExists('webhookControllerRegisterWebhookExtension', 'registerWebhookExtensionBody', registerWebhookExtensionBody)
            const localVarPath = `/webhook/registerWebhookExtension`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerWebhookExtensionBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MessengerResponseInDto} messengerResponseInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhook: async (messengerResponseInDto: MessengerResponseInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messengerResponseInDto' is not null or undefined
            assertParamExists('webhookControllerWebhook', 'messengerResponseInDto', messengerResponseInDto)
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messengerResponseInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhookGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody: RegisterWebhookExtensionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerRegisterWebhookExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MessengerResponseInDto} messengerResponseInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerWebhook(messengerResponseInDto: MessengerResponseInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerWebhook(messengerResponseInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerWebhookGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerWebhookGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerWebhookGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody: RegisterWebhookExtensionBody, options?: any): AxiosPromise<object> {
            return localVarFp.webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MessengerResponseInDto} messengerResponseInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhook(messengerResponseInDto: MessengerResponseInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.webhookControllerWebhook(messengerResponseInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhookGet(options?: any): AxiosPromise<object> {
            return localVarFp.webhookControllerWebhookGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody: RegisterWebhookExtensionBody, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MessengerResponseInDto} messengerResponseInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerWebhook(messengerResponseInDto: MessengerResponseInDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerWebhook(messengerResponseInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerWebhookGet(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerWebhookGet(options).then((request) => request(this.axios, this.basePath));
    }
}



