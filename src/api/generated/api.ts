/* tslint:disable */
/* eslint-disable */
/**
 * WorshipTool API
 * API for WorshipTool app
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig as RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddPermissionToUserInDto
 */
export interface AddPermissionToUserInDto {
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'userGuid': string;
    /**
     * 
     * @type {string}
     * @memberof AddPermissionToUserInDto
     */
    'permissionGuid': string;
}
/**
 * 
 * @export
 * @interface AddVariantToPlaylistInDto
 */
export interface AddVariantToPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof AddVariantToPlaylistInDto
     */
    'playlist': string;
}
/**
 * 
 * @export
 * @interface BaseUserInfoOutDto
 */
export interface BaseUserInfoOutDto {
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof BaseUserInfoOutDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof BaseUserInfoOutDto
     */
    'role': BaseUserInfoOutDtoRoleEnum;
}

export const BaseUserInfoOutDtoRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type BaseUserInfoOutDtoRoleEnum = typeof BaseUserInfoOutDtoRoleEnum[keyof typeof BaseUserInfoOutDtoRoleEnum];

/**
 * 
 * @export
 * @interface CSVLink
 */
export interface CSVLink {
    /**
     * 
     * @type {string}
     * @memberof CSVLink
     */
    'guid': string;
    /**
     * 
     * @type {Creator}
     * @memberof CSVLink
     */
    'creator': Creator;
    /**
     * 
     * @type {number}
     * @memberof CSVLink
     */
    'type': CSVLinkTypeEnum;
    /**
     * 
     * @type {SongVariant}
     * @memberof CSVLink
     */
    'variant': SongVariant;
}

export const CSVLinkTypeEnum = {
    NUMBER_0: 0
} as const;

export type CSVLinkTypeEnum = typeof CSVLinkTypeEnum[keyof typeof CSVLinkTypeEnum];

/**
 * 
 * @export
 * @interface CreatePlaylistInDto
 */
export interface CreatePlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface Creator
 */
export interface Creator {
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'name': string;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof Creator
     */
    'links': Array<CSVLink>;
}
/**
 * 
 * @export
 * @interface CreatorDTO
 */
export interface CreatorDTO {
    /**
     * 
     * @type {string}
     * @memberof CreatorDTO
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreatorDTO
     */
    'type': CreatorDTOTypeEnum;
}

export const CreatorDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type CreatorDTOTypeEnum = typeof CreatorDTOTypeEnum[keyof typeof CreatorDTOTypeEnum];

/**
 * 
 * @export
 * @interface EditVariantOutDto
 */
export interface EditVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof EditVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof EditVariantOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface GetGroupInfoResult
 */
export interface GetGroupInfoResult {
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'selection': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupInfoResult
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface GetGroupListItem
 */
export interface GetGroupListItem {
    /**
     * 
     * @type {string}
     * @memberof GetGroupListItem
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetGroupListItem
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetGroupsCountResult
 */
export interface GetGroupsCountResult {
    /**
     * 
     * @type {number}
     * @memberof GetGroupsCountResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetListSongData
 */
export interface GetListSongData {
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetListSongData
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface GetOrCreatePermissionInDto
 */
export interface GetOrCreatePermissionInDto {
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrCreatePermissionInDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetPlaylistsResult
 */
export interface GetPlaylistsResult {
    /**
     * 
     * @type {Array<PlaylistData>}
     * @memberof GetPlaylistsResult
     */
    'playlists': Array<PlaylistData>;
}
/**
 * 
 * @export
 * @interface GetRecommendedSongsOutDto
 */
export interface GetRecommendedSongsOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetRecommendedSongsOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface GetSearchInPlaylistResult
 */
export interface GetSearchInPlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof GetSearchInPlaylistResult
     */
    'guid': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof GetSearchInPlaylistResult
     */
    'items': Array<PlaylistItemOutDto>;
}
/**
 * 
 * @export
 * @interface GetSongDataOutDto
 */
export interface GetSongDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetSongDataOutDto
     */
    'mainTitle': string;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof GetSongDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {Array<SongDataVariant>}
     * @memberof GetSongDataOutDto
     */
    'variants': Array<SongDataVariant>;
    /**
     * 
     * @type {Array<SongDataMedia>}
     * @memberof GetSongDataOutDto
     */
    'media': Array<SongDataMedia>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSongDataOutDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface GetUserPermissionOutDto
 */
export interface GetUserPermissionOutDto {
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionOutDto
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface GetVariantsOfUserOutDto
 */
export interface GetVariantsOfUserOutDto {
    /**
     * 
     * @type {Array<SongVariantDataOutDto>}
     * @memberof GetVariantsOfUserOutDto
     */
    'variants': Array<SongVariantDataOutDto>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {Playlist}
     * @memberof Group
     */
    'selection': Playlist;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface JwtResult
 */
export interface JwtResult {
    /**
     * 
     * @type {LoginUserItemResult}
     * @memberof JwtResult
     */
    'user': LoginUserItemResult;
    /**
     * 
     * @type {string}
     * @memberof JwtResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LoginInputData
 */
export interface LoginInputData {
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginInputData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {LoginUserItemResult}
     * @memberof LoginResult
     */
    'user': LoginUserItemResult;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LoginUserItemResult
 */
export interface LoginUserItemResult {
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserItemResult
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof LoginUserItemResult
     */
    'role': LoginUserItemResultRoleEnum;
}

export const LoginUserItemResultRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type LoginUserItemResultRoleEnum = typeof LoginUserItemResultRoleEnum[keyof typeof LoginUserItemResultRoleEnum];

/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'guid': string;
    /**
     * 
     * @type {Song}
     * @memberof Media
     */
    'song': Song;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'type': MediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'url': string;
}

export const MediaTypeEnum = {
    NUMBER_0: 0
} as const;

export type MediaTypeEnum = typeof MediaTypeEnum[keyof typeof MediaTypeEnum];

/**
 * 
 * @export
 * @interface ParserSongData
 */
export interface ParserSongData {
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ParserSongData
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface ParserSongDataResult
 */
export interface ParserSongDataResult {
    /**
     * 
     * @type {Array<ParserSongData>}
     * @memberof ParserSongDataResult
     */
    'sheets': Array<ParserSongData>;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'payload'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Permission
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof Playlist
     */
    'items': Array<PlaylistItem>;
    /**
     * 
     * @type {User}
     * @memberof Playlist
     */
    'owner': User;
    /**
     * 
     * @type {boolean}
     * @memberof Playlist
     */
    'isSelection': boolean;
}
/**
 * 
 * @export
 * @interface PlaylistData
 */
export interface PlaylistData {
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistData
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PlaylistDataOutDto
 */
export interface PlaylistDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'title': string;
    /**
     * 
     * @type {Array<PlaylistItemOutDto>}
     * @memberof PlaylistDataOutDto
     */
    'items': Array<PlaylistItemOutDto>;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDataOutDto
     */
    'ownerGuid': string;
}
/**
 * 
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {object}
     * @memberof PlaylistItem
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'order': number;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof PlaylistItem
     */
    'variantPack': SongVariantHistoryPack;
    /**
     * 
     * @type {Playlist}
     * @memberof PlaylistItem
     */
    'playlist': Playlist;
}
/**
 * 
 * @export
 * @interface PlaylistItemOutDto
 */
export interface PlaylistItemOutDto {
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItemOutDto
     */
    'toneKey': string;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItemOutDto
     */
    'order': number;
    /**
     * 
     * @type {SongVariantDataOutDto}
     * @memberof PlaylistItemOutDto
     */
    'variant': SongVariantDataOutDto;
}
/**
 * 
 * @export
 * @interface PostChangeLanguageInDto
 */
export interface PostChangeLanguageInDto {
    /**
     * 
     * @type {string}
     * @memberof PostChangeLanguageInDto
     */
    'variantGuid': string;
    /**
     * 
     * @type {string}
     * @memberof PostChangeLanguageInDto
     */
    'languageString'?: string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyInDto
 */
export interface PostCreateCopyInDto {
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyInDto
     */
    'variantGuid': string;
}
/**
 * 
 * @export
 * @interface PostCreateCopyOutDto
 */
export interface PostCreateCopyOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateCopyOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateCopyOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface PostCreateGroupBody
 */
export interface PostCreateGroupBody {
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupBody
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface PostCreateGroupResult
 */
export interface PostCreateGroupResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateGroupResult
     */
    'selection': string;
}
/**
 * 
 * @export
 * @interface PostCreatePlaylistResult
 */
export interface PostCreatePlaylistResult {
    /**
     * 
     * @type {string}
     * @memberof PostCreatePlaylistResult
     */
    'guid': string;
}
/**
 * 
 * @export
 * @interface PostCreateVariantInDto
 */
export interface PostCreateVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantInDto
     */
    'sheetData': string;
    /**
     * 
     * @type {SongDataSource}
     * @memberof PostCreateVariantInDto
     */
    'source'?: SongDataSource;
    /**
     * 
     * @type {number}
     * @memberof PostCreateVariantInDto
     */
    'createdType': PostCreateVariantInDtoCreatedTypeEnum;
}

export const PostCreateVariantInDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostCreateVariantInDtoCreatedTypeEnum = typeof PostCreateVariantInDtoCreatedTypeEnum[keyof typeof PostCreateVariantInDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface PostCreateVariantOutDto
 */
export interface PostCreateVariantOutDto {
    /**
     * 
     * @type {SongVariant}
     * @memberof PostCreateVariantOutDto
     */
    'variant': SongVariant;
    /**
     * 
     * @type {string}
     * @memberof PostCreateVariantOutDto
     */
    'alias': string;
}
/**
 * 
 * @export
 * @interface PostEditVariantInDto
 */
export interface PostEditVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'variantAlias': string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'sheetData'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostEditVariantInDto
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostEditVariantInDto
     */
    'createdType': PostEditVariantInDtoCreatedTypeEnum;
}

export const PostEditVariantInDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PostEditVariantInDtoCreatedTypeEnum = typeof PostEditVariantInDtoCreatedTypeEnum[keyof typeof PostEditVariantInDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface PostGoogleLoginBody
 */
export interface PostGoogleLoginBody {
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'userToken': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PostGoogleLoginBody
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface PostPublishVariantInDto
 */
export interface PostPublishVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostPublishVariantInDto
     */
    'variantGuid': string;
}
/**
 * 
 * @export
 * @interface PostSendCustomMessageBody
 */
export interface PostSendCustomMessageBody {
    /**
     * 
     * @type {object}
     * @memberof PostSendCustomMessageBody
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface PostSendFeedbackBody
 */
export interface PostSendFeedbackBody {
    /**
     * 
     * @type {string}
     * @memberof PostSendFeedbackBody
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostSendFeedbackBody
     */
    'userName'?: string;
}
/**
 * 
 * @export
 * @interface PostSendMessageBody
 */
export interface PostSendMessageBody {
    /**
     * 
     * @type {string}
     * @memberof PostSendMessageBody
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostValidateSheetDataAndTitleInDto
 */
export interface PostValidateSheetDataAndTitleInDto {
    /**
     * 
     * @type {string}
     * @memberof PostValidateSheetDataAndTitleInDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof PostValidateSheetDataAndTitleInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PostVerifyVariantInDto
 */
export interface PostVerifyVariantInDto {
    /**
     * 
     * @type {string}
     * @memberof PostVerifyVariantInDto
     */
    'variantGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostVerifyVariantInDto
     */
    'verify': boolean | null;
}
/**
 * 
 * @export
 * @interface ProgramSongData
 */
export interface ProgramSongData {
    /**
     * 
     * @type {number}
     * @memberof ProgramSongData
     */
    'confidence': number;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramSongData
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof ProgramSongData
     */
    'createdType': ProgramSongDataCreatedTypeEnum;
}

export const ProgramSongDataCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type ProgramSongDataCreatedTypeEnum = typeof ProgramSongDataCreatedTypeEnum[keyof typeof ProgramSongDataCreatedTypeEnum];

/**
 * 
 * @export
 * @interface RegisterWebhookExtensionBody
 */
export interface RegisterWebhookExtensionBody {
    /**
     * 
     * @type {string}
     * @memberof RegisterWebhookExtensionBody
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RenamePlaylistInDto
 */
export interface RenamePlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof RenamePlaylistInDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistInDto
 */
export interface ReorderPlaylistInDto {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistInDto
     */
    'guid': string;
    /**
     * 
     * @type {Array<ReorderPlaylistItem>}
     * @memberof ReorderPlaylistInDto
     */
    'items': Array<ReorderPlaylistItem>;
}
/**
 * 
 * @export
 * @interface ReorderPlaylistItem
 */
export interface ReorderPlaylistItem {
    /**
     * 
     * @type {string}
     * @memberof ReorderPlaylistItem
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof ReorderPlaylistItem
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface SetGroupPayloadInDto
 */
export interface SetGroupPayloadInDto {
    /**
     * 
     * @type {string}
     * @memberof SetGroupPayloadInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SetGroupPayloadInDto
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface SignUpInputData
 */
export interface SignUpInputData {
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpInputData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'guid': string;
    /**
     * 
     * @type {SongTitle}
     * @memberof Song
     */
    'mainTitle': SongTitle;
    /**
     * 
     * @type {Array<SongVariantHistoryPack>}
     * @memberof Song
     */
    'variantPacks': Array<SongVariantHistoryPack>;
    /**
     * 
     * @type {Array<Media>}
     * @memberof Song
     */
    'media': Array<Media>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Song
     */
    'tags': Array<Tag>;
}
/**
 * 
 * @export
 * @interface SongDataCreator
 */
export interface SongDataCreator {
    /**
     * 
     * @type {string}
     * @memberof SongDataCreator
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SongDataCreator
     */
    'type': SongDataCreatorTypeEnum;
}

export const SongDataCreatorTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataCreatorTypeEnum = typeof SongDataCreatorTypeEnum[keyof typeof SongDataCreatorTypeEnum];

/**
 * 
 * @export
 * @interface SongDataMedia
 */
export interface SongDataMedia {
    /**
     * 
     * @type {number}
     * @memberof SongDataMedia
     */
    'type': SongDataMediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataMedia
     */
    'url': string;
}

export const SongDataMediaTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataMediaTypeEnum = typeof SongDataMediaTypeEnum[keyof typeof SongDataMediaTypeEnum];

/**
 * 
 * @export
 * @interface SongDataSource
 */
export interface SongDataSource {
    /**
     * 
     * @type {number}
     * @memberof SongDataSource
     */
    'type': SongDataSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataSource
     */
    'value': string;
}

export const SongDataSourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SongDataSourceTypeEnum = typeof SongDataSourceTypeEnum[keyof typeof SongDataSourceTypeEnum];

/**
 * 
 * @export
 * @interface SongDataVariant
 */
export interface SongDataVariant {
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'packGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'songGuid': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongDataVariant
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'createdByGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {Array<SourceDTO>}
     * @memberof SongDataVariant
     */
    'sources': Array<SourceDTO>;
    /**
     * 
     * @type {Array<CreatorDTO>}
     * @memberof SongDataVariant
     */
    'creators': Array<CreatorDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongDataVariant
     */
    'createdType': SongDataVariantCreatedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'alias': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'inFormat': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongDataVariant
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongDataVariant
     */
    'public': boolean;
}

export const SongDataVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongDataVariantCreatedTypeEnum = typeof SongDataVariantCreatedTypeEnum[keyof typeof SongDataVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongTitle
 */
export interface SongTitle {
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SongTitle
     */
    'searchValue': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongTitle
     */
    'variant': SongVariant;
}
/**
 * 
 * @export
 * @interface SongVariant
 */
export interface SongVariant {
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'searchValue': string;
    /**
     * 
     * @type {object}
     * @memberof SongVariant
     */
    'toneKey': object;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'type'?: SongVariantTypeEnum;
    /**
     * 
     * @type {SongTitle}
     * @memberof SongVariant
     */
    'prefferedTitle': SongTitle;
    /**
     * 
     * @type {Array<SongTitle>}
     * @memberof SongVariant
     */
    'titles': Array<SongTitle>;
    /**
     * 
     * @type {User}
     * @memberof SongVariant
     */
    'createdBy': User;
    /**
     * 
     * @type {Array<CSVLink>}
     * @memberof SongVariant
     */
    'links': Array<CSVLink>;
    /**
     * 
     * @type {Array<Source>}
     * @memberof SongVariant
     */
    'sources': Array<Source>;
    /**
     * 
     * @type {number}
     * @memberof SongVariant
     */
    'createdType': SongVariantCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariant
     */
    'children': Array<SongVariant>;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariant
     */
    'parent': SongVariant;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof SongVariant
     */
    'historyPack': SongVariantHistoryPack;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'inFormat': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'verified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariant
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariant
     */
    'hasChords': boolean;
}

export const SongVariantTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SongVariantTypeEnum = typeof SongVariantTypeEnum[keyof typeof SongVariantTypeEnum];
export const SongVariantCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantCreatedTypeEnum = typeof SongVariantCreatedTypeEnum[keyof typeof SongVariantCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongVariantDataOutDto
 */
export interface SongVariantDataOutDto {
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'prefferedTitle': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongVariantDataOutDto
     */
    'titles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'sheetData': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'sheetText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'createdBy': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'createdByLoader': boolean;
    /**
     * 
     * @type {number}
     * @memberof SongVariantDataOutDto
     */
    'createdType': SongVariantDataOutDtoCreatedTypeEnum;
    /**
     * 
     * @type {Array<SongDataSource>}
     * @memberof SongVariantDataOutDto
     */
    'sources': Array<SongDataSource>;
    /**
     * 
     * @type {Array<SongDataCreator>}
     * @memberof SongVariantDataOutDto
     */
    'creators': Array<SongDataCreator>;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'alias': string;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'packGuid': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'inFormat': boolean;
    /**
     * 
     * @type {string}
     * @memberof SongVariantDataOutDto
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantDataOutDto
     */
    'deleted': boolean;
}

export const SongVariantDataOutDtoCreatedTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SongVariantDataOutDtoCreatedTypeEnum = typeof SongVariantDataOutDtoCreatedTypeEnum[keyof typeof SongVariantDataOutDtoCreatedTypeEnum];

/**
 * 
 * @export
 * @interface SongVariantHistoryPack
 */
export interface SongVariantHistoryPack {
    /**
     * 
     * @type {string}
     * @memberof SongVariantHistoryPack
     */
    'guid': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof SongVariantHistoryPack
     */
    'last': SongVariant;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof SongVariantHistoryPack
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Song}
     * @memberof SongVariantHistoryPack
     */
    'song': Song;
    /**
     * 
     * @type {Array<UrlAlias>}
     * @memberof SongVariantHistoryPack
     */
    'aliases': Array<UrlAlias>;
    /**
     * 
     * @type {UrlAlias}
     * @memberof SongVariantHistoryPack
     */
    'alias': UrlAlias;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof SongVariantHistoryPack
     */
    'playlistItems': Array<PlaylistItem>;
    /**
     * 
     * @type {boolean}
     * @memberof SongVariantHistoryPack
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'guid': string;
    /**
     * 
     * @type {number}
     * @memberof Source
     */
    'type': SourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'value': string;
    /**
     * 
     * @type {SongVariant}
     * @memberof Source
     */
    'variant': SongVariant;
}

export const SourceTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceTypeEnum = typeof SourceTypeEnum[keyof typeof SourceTypeEnum];

/**
 * 
 * @export
 * @interface SourceDTO
 */
export interface SourceDTO {
    /**
     * 
     * @type {number}
     * @memberof SourceDTO
     */
    'type': SourceDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDTO
     */
    'value': string;
}

export const SourceDTOTypeEnum = {
    NUMBER_0: 0
} as const;

export type SourceDTOTypeEnum = typeof SourceDTOTypeEnum[keyof typeof SourceDTOTypeEnum];

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'guid': string;
    /**
     * 
     * @type {Array<Song>}
     * @memberof Tag
     */
    'songs': Array<Song>;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TransposePlaylistItemInDto
 */
export interface TransposePlaylistItemInDto {
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof TransposePlaylistItemInDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UrlAlias
 */
export interface UrlAlias {
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof UrlAlias
     */
    'alias': string;
    /**
     * 
     * @type {number}
     * @memberof UrlAlias
     */
    'type': UrlAliasTypeEnum;
    /**
     * 
     * @type {SongVariantHistoryPack}
     * @memberof UrlAlias
     */
    'pack': SongVariantHistoryPack;
}

export const UrlAliasTypeEnum = {
    NUMBER_0: 0
} as const;

export type UrlAliasTypeEnum = typeof UrlAliasTypeEnum[keyof typeof UrlAliasTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'guid': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'loginType': UserLoginTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googleId': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {Array<SongVariant>}
     * @memberof User
     */
    'variants': Array<SongVariant>;
    /**
     * 
     * @type {Array<Playlist>}
     * @memberof User
     */
    'playlists': Array<Playlist>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof User
     */
    'permissions': Array<Permission>;
}

export const UserLoginTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type UserLoginTypeEnum = typeof UserLoginTypeEnum[keyof typeof UserLoginTypeEnum];
export const UserRoleEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface ValidationResult
 */
export interface ValidationResult {
    /**
     * 
     * @type {boolean}
     * @memberof ValidationResult
     */
    'success': boolean;
    /**
     * 
     * @type {object}
     * @memberof ValidationResult
     */
    'qualities': object;
    /**
     * 
     * @type {string}
     * @memberof ValidationResult
     */
    'message': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetUserGuidFromEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('authControllerGetUserGuidFromEmail', 'email', email)
            const localVarPath = `/auth/guidfromemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginInputData: LoginInputData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInputData' is not null or undefined
            assertParamExists('authControllerLogin', 'loginInputData', loginInputData)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('authControllerLoginWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInputData} signUpInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signUpInputData: SignUpInputData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpInputData' is not null or undefined
            assertParamExists('authControllerSignup', 'signUpInputData', signUpInputData)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpInputData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignupWithGoogle: async (postGoogleLoginBody: PostGoogleLoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGoogleLoginBody' is not null or undefined
            assertParamExists('authControllerSignupWithGoogle', 'postGoogleLoginBody', postGoogleLoginBody)
            const localVarPath = `/auth/signup/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGoogleLoginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetUserGuidFromEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetUserGuidFromEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginInputData: LoginInputData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginInputData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithGoogle(postGoogleLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLoginWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInputData} signUpInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signUpInputData: SignUpInputData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signUpInputData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignupWithGoogle(postGoogleLoginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignupWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetUserGuidFromEmail(email: string, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerGetUserGuidFromEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using email and password.
         * @summary Logs in the user using email and password.
         * @param {LoginInputData} loginInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginInputData: LoginInputData, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.authControllerLogin(loginInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to log in using Google.
         * @summary Logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerLoginWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up using email and password.
         * @summary Signs up the user using email and password.
         * @param {SignUpInputData} signUpInputData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signUpInputData: SignUpInputData, options?: any): AxiosPromise<boolean> {
            return localVarFp.authControllerSignup(signUpInputData, options).then((request) => request(axios, basePath));
        },
        /**
         * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
         * @summary Signs up or logs in the user using Google.
         * @param {PostGoogleLoginBody} postGoogleLoginBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: any): AxiosPromise<JwtResult> {
            return localVarFp.authControllerSignupWithGoogle(postGoogleLoginBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetUserGuidFromEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using email and password.
     * @summary Logs in the user using email and password.
     * @param {LoginInputData} loginInputData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginInputData: LoginInputData, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to log in using Google.
     * @summary Logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLoginWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up using email and password.
     * @summary Signs up the user using email and password.
     * @param {SignUpInputData} signUpInputData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignup(signUpInputData: SignUpInputData, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(signUpInputData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
     * @summary Signs up or logs in the user using Google.
     * @param {PostGoogleLoginBody} postGoogleLoginBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignupWithGoogle(postGoogleLoginBody: PostGoogleLoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignupWithGoogle(postGoogleLoginBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMonitorControllerRoot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monitor/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusMonitorControllerRoot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusMonitorControllerRoot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.statusMonitorControllerRoot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusMonitorControllerRoot(options?: any): AxiosPromise<void> {
            return localVarFp.statusMonitorControllerRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statusMonitorControllerRoot(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statusMonitorControllerRoot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup: async (postCreateGroupBody: PostCreateGroupBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateGroupBody' is not null or undefined
            assertParamExists('groupControllerCreateGroup', 'postCreateGroupBody', postCreateGroupBody)
            const localVarPath = `/group/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateGroupBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup: async (guid?: string, code?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupInfo: async (guid?: string, code?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupSelection: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('groupControllerGetGroupSelection', 'guid', guid)
            const localVarPath = `/group/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerSearchGroups: async (searchString: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchString' is not null or undefined
            assertParamExists('groupControllerSearchGroups', 'searchString', searchString)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroupPayload: async (setGroupPayloadInDto: SetGroupPayloadInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setGroupPayloadInDto' is not null or undefined
            assertParamExists('groupControllerUpdateGroupPayload', 'setGroupPayloadInDto', setGroupPayloadInDto)
            const localVarPath = `/payload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGroupPayloadInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateGroupResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerCreateGroup(postCreateGroupBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerCreateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerDeleteGroup(guid?: string, code?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerDeleteGroup(guid, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupsCountResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupInfo(guid?: string, code?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupInfoResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupInfo(guid, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetGroupInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupSelection(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupSelection(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetGroupSelection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroupsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGroupListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroupsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerGetGroupsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerSearchGroups(searchString: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerSearchGroups(searchString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerSearchGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerUpdateGroupPayload(setGroupPayloadInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.groupControllerUpdateGroupPayload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * The function creates a new group. Only admin users can access this endpoint.
         * @summary Creates a new group.
         * @param {PostCreateGroupBody} postCreateGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: any): AxiosPromise<PostCreateGroupResult> {
            return localVarFp.groupControllerCreateGroup(postCreateGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function deletes a group. Only admin users can access this endpoint.
         * @summary Deletes a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerDeleteGroup(guid?: string, code?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.groupControllerDeleteGroup(guid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns number of all groups.
         * @summary Returns number of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetCount(options?: any): AxiosPromise<GetGroupsCountResult> {
            return localVarFp.groupControllerGetCount(options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns information about a group.
         * @summary Returns information about a group.
         * @param {string} [guid] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupInfo(guid?: string, code?: string, options?: any): AxiosPromise<GetGroupInfoResult> {
            return localVarFp.groupControllerGetGroupInfo(guid, code, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns the selection of a group.
         * @summary Returns the selection of a group.
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupSelection(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.groupControllerGetGroupSelection(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * The function returns a list of all groups. Only admin users can access this endpoint.
         * @summary Returns a list of all groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroupsList(options?: any): AxiosPromise<Array<GetGroupListItem>> {
            return localVarFp.groupControllerGetGroupsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerSearchGroups(searchString: string, options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.groupControllerSearchGroups(searchString, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: any): AxiosPromise<void> {
            return localVarFp.groupControllerUpdateGroupPayload(setGroupPayloadInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * The function creates a new group. Only admin users can access this endpoint.
     * @summary Creates a new group.
     * @param {PostCreateGroupBody} postCreateGroupBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerCreateGroup(postCreateGroupBody: PostCreateGroupBody, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerCreateGroup(postCreateGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function deletes a group. Only admin users can access this endpoint.
     * @summary Deletes a group.
     * @param {string} [guid] 
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerDeleteGroup(guid?: string, code?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerDeleteGroup(guid, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns number of all groups.
     * @summary Returns number of all groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetCount(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns information about a group.
     * @summary Returns information about a group.
     * @param {string} [guid] 
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupInfo(guid?: string, code?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupInfo(guid, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns the selection of a group.
     * @summary Returns the selection of a group.
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupSelection(guid: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupSelection(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function returns a list of all groups. Only admin users can access this endpoint.
     * @summary Returns a list of all groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroupsList(options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerGetGroupsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchString 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerSearchGroups(searchString: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerSearchGroups(searchString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetGroupPayloadInDto} setGroupPayloadInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerUpdateGroupPayload(setGroupPayloadInDto: SetGroupPayloadInDto, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).groupControllerUpdateGroupPayload(setGroupPayloadInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessengerApi - axios parameter creator
 * @export
 */
export const MessengerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostFeedback: async (postSendFeedbackBody: PostSendFeedbackBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendFeedbackBody' is not null or undefined
            assertParamExists('messengerControllerPostFeedback', 'postSendFeedbackBody', postSendFeedbackBody)
            const localVarPath = `/sendfeedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendFeedbackBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostMessage: async (postSendMessageBody: PostSendMessageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendMessageBody' is not null or undefined
            assertParamExists('messengerControllerPostMessage', 'postSendMessageBody', postSendMessageBody)
            const localVarPath = `/sendmessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendMessageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends a formatted message to the messenger.
         * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerSendCustomMessage: async (postSendCustomMessageBody: PostSendCustomMessageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postSendCustomMessageBody' is not null or undefined
            assertParamExists('messengerControllerSendCustomMessage', 'postSendCustomMessageBody', postSendCustomMessageBody)
            const localVarPath = `/sendCustomMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSendCustomMessageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessengerApi - functional programming interface
 * @export
 */
export const MessengerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessengerApiAxiosParamCreator(configuration)
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerPostFeedback(postSendFeedbackBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.messengerControllerPostFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerPostMessage(postSendMessageBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.messengerControllerPostMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sends a formatted message to the messenger.
         * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messengerControllerSendCustomMessage(postSendCustomMessageBody: PostSendCustomMessageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messengerControllerSendCustomMessage(postSendCustomMessageBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessengerApi.messengerControllerSendCustomMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessengerApi - factory interface
 * @export
 */
export const MessengerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessengerApiFp(configuration)
    return {
        /**
         * Handles the HTTP POST request for sending feedback.
         * @summary Sends a feedback to the messenger.
         * @param {PostSendFeedbackBody} postSendFeedbackBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerPostFeedback(postSendFeedbackBody, options).then((request) => request(axios, basePath));
        },
        /**
         * The function sends a message using the messenger service and returns a success message if the message is not empty.
         * @summary Sends a message to the messenger.
         * @param {PostSendMessageBody} postSendMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerPostMessage(postSendMessageBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends a formatted message to the messenger.
         * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messengerControllerSendCustomMessage(postSendCustomMessageBody: PostSendCustomMessageBody, options?: any): AxiosPromise<boolean> {
            return localVarFp.messengerControllerSendCustomMessage(postSendCustomMessageBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessengerApi - object-oriented interface
 * @export
 * @class MessengerApi
 * @extends {BaseAPI}
 */
export class MessengerApi extends BaseAPI {
    /**
     * Handles the HTTP POST request for sending feedback.
     * @summary Sends a feedback to the messenger.
     * @param {PostSendFeedbackBody} postSendFeedbackBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerPostFeedback(postSendFeedbackBody: PostSendFeedbackBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerPostFeedback(postSendFeedbackBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function sends a message using the messenger service and returns a success message if the message is not empty.
     * @summary Sends a message to the messenger.
     * @param {PostSendMessageBody} postSendMessageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerPostMessage(postSendMessageBody: PostSendMessageBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerPostMessage(postSendMessageBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends a formatted message to the messenger.
     * @param {PostSendCustomMessageBody} postSendCustomMessageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
    public messengerControllerSendCustomMessage(postSendCustomMessageBody: PostSendCustomMessageBody, options?: RawAxiosRequestConfig) {
        return MessengerApiFp(this.configuration).messengerControllerSendCustomMessage(postSendCustomMessageBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('permissionControllerAddPermissionToUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetAllUsersWithPermission: async (type: string, payload?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('permissionControllerGetAllUsersWithPermission', 'type', type)
            const localVarPath = `/permissions/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (payload !== undefined) {
                localVarQueryParameter['payload'] = payload;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetOrAddPermission: async (getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOrCreatePermissionInDto' is not null or undefined
            assertParamExists('permissionControllerGetOrAddPermission', 'getOrCreatePermissionInDto', getOrCreatePermissionInDto)
            const localVarPath = `/permissions/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOrCreatePermissionInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetUserPermissions: async (userGuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userGuid !== undefined) {
                localVarQueryParameter['userGuid'] = userGuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromUser: async (addPermissionToUserInDto: AddPermissionToUserInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addPermissionToUserInDto' is not null or undefined
            assertParamExists('permissionControllerRemovePermissionFromUser', 'addPermissionToUserInDto', addPermissionToUserInDto)
            const localVarPath = `/permissions/user/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPermissionToUserInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerAddPermissionToUser(addPermissionToUserInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerAddPermissionToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseUserInfoOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetAllUsersWithPermission(type, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerGetAllUsersWithPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerGetOrAddPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerGetUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserPermissionOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerGetUserPermissions(userGuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerGetUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionControllerRemovePermissionFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerAddPermissionToUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} type 
         * @param {string} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: any): AxiosPromise<Array<BaseUserInfoOutDto>> {
            return localVarFp.permissionControllerGetAllUsersWithPermission(type, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerGetUserPermissions(userGuid?: string, options?: any): AxiosPromise<Array<GetUserPermissionOutDto>> {
            return localVarFp.permissionControllerGetUserPermissions(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: any): AxiosPromise<Permission> {
            return localVarFp.permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerAddPermissionToUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerAddPermissionToUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} type 
     * @param {string} [payload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetAllUsersWithPermission(type: string, payload?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetAllUsersWithPermission(type, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetOrAddPermission(getOrCreatePermissionInDto: GetOrCreatePermissionInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetOrAddPermission(getOrCreatePermissionInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userGuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerGetUserPermissions(userGuid?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerGetUserPermissions(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddPermissionToUserInDto} addPermissionToUserInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionControllerRemovePermissionFromUser(addPermissionToUserInDto: AddPermissionToUserInDto, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionControllerRemovePermissionFromUser(addPermissionToUserInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistEditingApi - axios parameter creator
 * @export
 */
export const PlaylistEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerAddVariantToPlaylist: async (addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addVariantToPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerAddVariantToPlaylist', 'addVariantToPlaylistInDto', addVariantToPlaylistInDto)
            const localVarPath = `/playlist/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVariantToPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePlaylistInDto} createPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerCreatePlaylist: async (createPlaylistInDto: CreatePlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerCreatePlaylist', 'createPlaylistInDto', createPlaylistInDto)
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerDeletePlaylist: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('playlistEditingControllerDeletePlaylist', 'guid', guid)
            const localVarPath = `/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRemoveVariantFromPlaylistDelete: async (alias: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('playlistEditingControllerRemoveVariantFromPlaylistDelete', 'alias', alias)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistEditingControllerRemoveVariantFromPlaylistDelete', 'playlist', playlist)
            const localVarPath = `/playlist/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = alias;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRenamePlaylist: async (renamePlaylistInDto: RenamePlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renamePlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerRenamePlaylist', 'renamePlaylistInDto', renamePlaylistInDto)
            const localVarPath = `/playlist/rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renamePlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerReorderPlaylist: async (reorderPlaylistInDto: ReorderPlaylistInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reorderPlaylistInDto' is not null or undefined
            assertParamExists('playlistEditingControllerReorderPlaylist', 'reorderPlaylistInDto', reorderPlaylistInDto)
            const localVarPath = `/playlist/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reorderPlaylistInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerTransposePlaylistItem: async (transposePlaylistItemInDto: TransposePlaylistItemInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transposePlaylistItemInDto' is not null or undefined
            assertParamExists('playlistEditingControllerTransposePlaylistItem', 'transposePlaylistItemInDto', transposePlaylistItemInDto)
            const localVarPath = `/playlist/transpose`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transposePlaylistItemInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistEditingApi - functional programming interface
 * @export
 */
export const PlaylistEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerAddVariantToPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreatePlaylistInDto} createPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerCreatePlaylist(createPlaylistInDto: CreatePlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreatePlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerCreatePlaylist(createPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerCreatePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerDeletePlaylist(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerDeletePlaylist(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerDeletePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRemoveVariantFromPlaylistDelete(alias: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRemoveVariantFromPlaylistDelete(alias, playlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRemoveVariantFromPlaylistDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerRenamePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerReorderPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistEditingApi.playlistEditingControllerTransposePlaylistItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistEditingApi - factory interface
 * @export
 */
export const PlaylistEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: any): AxiosPromise<PlaylistItem> {
            return localVarFp.playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePlaylistInDto} createPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerCreatePlaylist(createPlaylistInDto: CreatePlaylistInDto, options?: any): AxiosPromise<PostCreatePlaylistResult> {
            return localVarFp.playlistEditingControllerCreatePlaylist(createPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerDeletePlaylist(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerDeletePlaylist(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRemoveVariantFromPlaylistDelete(alias: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRemoveVariantFromPlaylistDelete(alias, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RenamePlaylistInDto} renamePlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistEditingApi - object-oriented interface
 * @export
 * @class PlaylistEditingApi
 * @extends {BaseAPI}
 */
export class PlaylistEditingApi extends BaseAPI {
    /**
     * 
     * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto: AddVariantToPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerAddVariantToPlaylist(addVariantToPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePlaylistInDto} createPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerCreatePlaylist(createPlaylistInDto: CreatePlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerCreatePlaylist(createPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerDeletePlaylist(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerDeletePlaylist(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRemoveVariantFromPlaylistDelete(alias: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRemoveVariantFromPlaylistDelete(alias, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RenamePlaylistInDto} renamePlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerRenamePlaylist(renamePlaylistInDto: RenamePlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerRenamePlaylist(renamePlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReorderPlaylistInDto} reorderPlaylistInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerReorderPlaylist(reorderPlaylistInDto: ReorderPlaylistInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerReorderPlaylist(reorderPlaylistInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistEditingApi
     */
    public playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto: TransposePlaylistItemInDto, options?: RawAxiosRequestConfig) {
        return PlaylistEditingApiFp(this.configuration).playlistEditingControllerTransposePlaylistItem(transposePlaylistItemInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistGettingApi - axios parameter creator
 * @export
 */
export const PlaylistGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistDataByGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('playlistGettingControllerGetPlaylistDataByGuid', 'guid', guid)
            const localVarPath = `/playlist/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistsOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist/ofuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variantAlias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerIsVariantInPlaylist: async (variantAlias: string, playlist: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantAlias' is not null or undefined
            assertParamExists('playlistGettingControllerIsVariantInPlaylist', 'variantAlias', variantAlias)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistGettingControllerIsVariantInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/contains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (variantAlias !== undefined) {
                localVarQueryParameter['variantAlias'] = variantAlias;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerSearchInPlaylist: async (searchKey: string, playlist: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('playlistGettingControllerSearchInPlaylist', 'searchKey', searchKey)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistGettingControllerSearchInPlaylist', 'playlist', playlist)
            const localVarPath = `/playlist/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (playlist !== undefined) {
                localVarQueryParameter['playlist'] = playlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistGettingApi - functional programming interface
 * @export
 */
export const PlaylistGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerGetPlaylistDataByGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerGetPlaylistDataByGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerGetPlaylistsOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlaylistsResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerGetPlaylistsOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerGetPlaylistsOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variantAlias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerIsVariantInPlaylist(variantAlias: string, playlist: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerIsVariantInPlaylist(variantAlias, playlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerIsVariantInPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchInPlaylistResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistGettingApi.playlistGettingControllerSearchInPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistGettingApi - factory interface
 * @export
 */
export const PlaylistGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: any): AxiosPromise<PlaylistDataOutDto> {
            return localVarFp.playlistGettingControllerGetPlaylistDataByGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerGetPlaylistsOfUser(options?: any): AxiosPromise<GetPlaylistsResult> {
            return localVarFp.playlistGettingControllerGetPlaylistsOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variantAlias 
         * @param {string} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerIsVariantInPlaylist(variantAlias: string, playlist: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.playlistGettingControllerIsVariantInPlaylist(variantAlias, playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchKey 
         * @param {string} playlist 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: any): AxiosPromise<GetSearchInPlaylistResult> {
            return localVarFp.playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistGettingApi - object-oriented interface
 * @export
 * @class PlaylistGettingApi
 * @extends {BaseAPI}
 */
export class PlaylistGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerGetPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerGetPlaylistDataByGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerGetPlaylistsOfUser(options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerGetPlaylistsOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variantAlias 
     * @param {string} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerIsVariantInPlaylist(variantAlias: string, playlist: string, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerIsVariantInPlaylist(variantAlias, playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchKey 
     * @param {string} playlist 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistGettingApi
     */
    public playlistGettingControllerSearchInPlaylist(searchKey: string, playlist: string, page?: number, options?: RawAxiosRequestConfig) {
        return PlaylistGettingApiFp(this.configuration).playlistGettingControllerSearchInPlaylist(searchKey, playlist, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramSongAddingApi - axios parameter creator
 * @export
 */
export const ProgramSongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programSongAddingControllerProcessDataStream: async (programSongData: ProgramSongData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programSongData' is not null or undefined
            assertParamExists('programSongAddingControllerProcessDataStream', 'programSongData', programSongData)
            const localVarPath = `/song/processdatastream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(programSongData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramSongAddingApi - functional programming interface
 * @export
 */
export const ProgramSongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramSongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programSongAddingControllerProcessDataStream(programSongData: ProgramSongData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programSongAddingControllerProcessDataStream(programSongData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramSongAddingApi.programSongAddingControllerProcessDataStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramSongAddingApi - factory interface
 * @export
 */
export const ProgramSongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramSongAddingApiFp(configuration)
    return {
        /**
         * This function process data stream from loader\'s program. Getter and so on.
         * @summary 
         * @param {ProgramSongData} programSongData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programSongAddingControllerProcessDataStream(programSongData: ProgramSongData, options?: any): AxiosPromise<boolean> {
            return localVarFp.programSongAddingControllerProcessDataStream(programSongData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramSongAddingApi - object-oriented interface
 * @export
 * @class ProgramSongAddingApi
 * @extends {BaseAPI}
 */
export class ProgramSongAddingApi extends BaseAPI {
    /**
     * This function process data stream from loader\'s program. Getter and so on.
     * @summary 
     * @param {ProgramSongData} programSongData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramSongAddingApi
     */
    public programSongAddingControllerProcessDataStream(programSongData: ProgramSongData, options?: RawAxiosRequestConfig) {
        return ProgramSongAddingApiFp(this.configuration).programSongAddingControllerProcessDataStream(programSongData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongAddingApi - axios parameter creator
 * @export
 */
export const SongAddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreate: async (postCreateVariantInDto: PostCreateVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateVariantInDto' is not null or undefined
            assertParamExists('songAddingControllerCreate', 'postCreateVariantInDto', postCreateVariantInDto)
            const localVarPath = `/song`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreateCopy: async (postCreateCopyInDto: PostCreateCopyInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCreateCopyInDto' is not null or undefined
            assertParamExists('songAddingControllerCreateCopy', 'postCreateCopyInDto', postCreateCopyInDto)
            const localVarPath = `/song/create/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCreateCopyInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerIsParserAvailable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/parser/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerParse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongAddingApi - functional programming interface
 * @export
 */
export const SongAddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongAddingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerCreate(postCreateVariantInDto: PostCreateVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerCreate(postCreateVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateCopyOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerCreateCopy(postCreateCopyInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerCreateCopy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerIsParserAvailable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerIsParserAvailable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerIsParserAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songAddingControllerParse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParserSongDataResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songAddingControllerParse(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongAddingApi.songAddingControllerParse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongAddingApi - factory interface
 * @export
 */
export const SongAddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongAddingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostCreateVariantInDto} postCreateVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreate(postCreateVariantInDto: PostCreateVariantInDto, options?: any): AxiosPromise<PostCreateVariantOutDto> {
            return localVarFp.songAddingControllerCreate(postCreateVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostCreateCopyInDto} postCreateCopyInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: any): AxiosPromise<PostCreateCopyOutDto> {
            return localVarFp.songAddingControllerCreateCopy(postCreateCopyInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerIsParserAvailable(options?: any): AxiosPromise<boolean> {
            return localVarFp.songAddingControllerIsParserAvailable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songAddingControllerParse(options?: any): AxiosPromise<ParserSongDataResult> {
            return localVarFp.songAddingControllerParse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongAddingApi - object-oriented interface
 * @export
 * @class SongAddingApi
 * @extends {BaseAPI}
 */
export class SongAddingApi extends BaseAPI {
    /**
     * 
     * @param {PostCreateVariantInDto} postCreateVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerCreate(postCreateVariantInDto: PostCreateVariantInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerCreate(postCreateVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostCreateCopyInDto} postCreateCopyInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerCreateCopy(postCreateCopyInDto: PostCreateCopyInDto, options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerCreateCopy(postCreateCopyInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerIsParserAvailable(options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerIsParserAvailable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongAddingApi
     */
    public songAddingControllerParse(options?: RawAxiosRequestConfig) {
        return SongAddingApiFp(this.configuration).songAddingControllerParse(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongDeletingApi - axios parameter creator
 * @export
 */
export const SongDeletingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerDelete: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songDeletingControllerDelete', 'guid', guid)
            const localVarPath = `/song/variant/delete/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerRestore: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songDeletingControllerRestore', 'guid', guid)
            const localVarPath = `/song/variant/restore/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongDeletingApi - functional programming interface
 * @export
 */
export const SongDeletingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongDeletingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songDeletingControllerDelete(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songDeletingControllerDelete(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongDeletingApi.songDeletingControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songDeletingControllerRestore(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songDeletingControllerRestore(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongDeletingApi.songDeletingControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongDeletingApi - factory interface
 * @export
 */
export const SongDeletingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongDeletingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerDelete(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.songDeletingControllerDelete(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songDeletingControllerRestore(guid: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.songDeletingControllerRestore(guid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongDeletingApi - object-oriented interface
 * @export
 * @class SongDeletingApi
 * @extends {BaseAPI}
 */
export class SongDeletingApi extends BaseAPI {
    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public songDeletingControllerDelete(guid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).songDeletingControllerDelete(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongDeletingApi
     */
    public songDeletingControllerRestore(guid: string, options?: RawAxiosRequestConfig) {
        return SongDeletingApiFp(this.configuration).songDeletingControllerRestore(guid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongEditingApi - axios parameter creator
 * @export
 */
export const SongEditingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerChangeLanguage: async (postChangeLanguageInDto: PostChangeLanguageInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postChangeLanguageInDto' is not null or undefined
            assertParamExists('songEditingControllerChangeLanguage', 'postChangeLanguageInDto', postChangeLanguageInDto)
            const localVarPath = `/song/variant/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postChangeLanguageInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerEditVariant: async (postEditVariantInDto: PostEditVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postEditVariantInDto' is not null or undefined
            assertParamExists('songEditingControllerEditVariant', 'postEditVariantInDto', postEditVariantInDto)
            const localVarPath = `/song/variant/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postEditVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongEditingApi - functional programming interface
 * @export
 */
export const SongEditingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongEditingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerChangeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerChangeLanguage(postChangeLanguageInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongEditingApi.songEditingControllerChangeLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditVariantOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songEditingControllerEditVariant(postEditVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongEditingApi.songEditingControllerEditVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongEditingApi - factory interface
 * @export
 */
export const SongEditingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongEditingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerChangeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: any): AxiosPromise<string> {
            return localVarFp.songEditingControllerChangeLanguage(postChangeLanguageInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostEditVariantInDto} postEditVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: any): AxiosPromise<EditVariantOutDto> {
            return localVarFp.songEditingControllerEditVariant(postEditVariantInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongEditingApi - object-oriented interface
 * @export
 * @class SongEditingApi
 * @extends {BaseAPI}
 */
export class SongEditingApi extends BaseAPI {
    /**
     * 
     * @param {PostChangeLanguageInDto} postChangeLanguageInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerChangeLanguage(postChangeLanguageInDto: PostChangeLanguageInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerChangeLanguage(postChangeLanguageInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostEditVariantInDto} postEditVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongEditingApi
     */
    public songEditingControllerEditVariant(postEditVariantInDto: PostEditVariantInDto, options?: RawAxiosRequestConfig) {
        return SongEditingApiFp(this.configuration).songEditingControllerEditVariant(postEditVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongGettingApi - axios parameter creator
 * @export
 */
export const SongGettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetBySearch: async (searchKey: string, page: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('songGettingControllerGetBySearch', 'searchKey', searchKey)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('songGettingControllerGetBySearch', 'page', page)
            const localVarPath = `/song/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchKey !== undefined) {
                localVarQueryParameter['searchKey'] = searchKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetList: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRecommendedSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongDataByVariantGuid: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('songGettingControllerGetSongDataByVariantGuid', 'guid', guid)
            const localVarPath = `/song/ofvariant/{guid}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongListOfUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/song/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetVariantFromAlias: async (alias: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alias' is not null or undefined
            assertParamExists('songGettingControllerGetVariantFromAlias', 'alias', alias)
            const localVarPath = `/song/alias/variant/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongGettingApi - functional programming interface
 * @export
 */
export const SongGettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongGettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetBySearch(searchKey: string, page: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SongVariantDataOutDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetBySearch(searchKey, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetBySearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetList(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetListSongData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetList(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetRecommendedSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecommendedSongsOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetRecommendedSongs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetRecommendedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSongDataOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongDataByVariantGuid(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongDataByVariantGuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongListOfUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVariantsOfUserOutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongListOfUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongListOfUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetSongsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetSongsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetSongsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songGettingControllerGetVariantFromAlias(alias: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songGettingControllerGetVariantFromAlias(alias, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongGettingApi.songGettingControllerGetVariantFromAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongGettingApi - factory interface
 * @export
 */
export const SongGettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongGettingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} searchKey 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetBySearch(searchKey: string, page: number, options?: any): AxiosPromise<Array<SongVariantDataOutDto>> {
            return localVarFp.songGettingControllerGetBySearch(searchKey, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetList(page?: number, options?: any): AxiosPromise<Array<GetListSongData>> {
            return localVarFp.songGettingControllerGetList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetRecommendedSongs(options?: any): AxiosPromise<GetRecommendedSongsOutDto> {
            return localVarFp.songGettingControllerGetRecommendedSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} guid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongDataByVariantGuid(guid: string, options?: any): AxiosPromise<GetSongDataOutDto> {
            return localVarFp.songGettingControllerGetSongDataByVariantGuid(guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongListOfUser(options?: any): AxiosPromise<GetVariantsOfUserOutDto> {
            return localVarFp.songGettingControllerGetSongListOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetSongsCount(options?: any): AxiosPromise<number> {
            return localVarFp.songGettingControllerGetSongsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songGettingControllerGetVariantFromAlias(alias: string, options?: any): AxiosPromise<string> {
            return localVarFp.songGettingControllerGetVariantFromAlias(alias, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongGettingApi - object-oriented interface
 * @export
 * @class SongGettingApi
 * @extends {BaseAPI}
 */
export class SongGettingApi extends BaseAPI {
    /**
     * 
     * @param {string} searchKey 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetBySearch(searchKey: string, page: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetBySearch(searchKey, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetList(page?: number, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetRecommendedSongs(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetRecommendedSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} guid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongDataByVariantGuid(guid: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongDataByVariantGuid(guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongListOfUser(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongListOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetSongsCount(options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetSongsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongGettingApi
     */
    public songGettingControllerGetVariantFromAlias(alias: string, options?: RawAxiosRequestConfig) {
        return SongGettingApiFp(this.configuration).songGettingControllerGetVariantFromAlias(alias, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongPublishingApi - axios parameter creator
 * @export
 */
export const SongPublishingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerPublishVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('songPublishingControllerPublishVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerUnpublishVariant: async (postPublishVariantInDto: PostPublishVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublishVariantInDto' is not null or undefined
            assertParamExists('songPublishingControllerUnpublishVariant', 'postPublishVariantInDto', postPublishVariantInDto)
            const localVarPath = `/song/unpublish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublishVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerVerifyVariant: async (postVerifyVariantInDto: PostVerifyVariantInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postVerifyVariantInDto' is not null or undefined
            assertParamExists('songPublishingControllerVerifyVariant', 'postVerifyVariantInDto', postVerifyVariantInDto)
            const localVarPath = `/song/verifystatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postVerifyVariantInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongPublishingApi - functional programming interface
 * @export
 */
export const SongPublishingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongPublishingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerPublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerPublishVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerPublishVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerUnpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerUnpublishVariant(postPublishVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerUnpublishVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songPublishingControllerVerifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songPublishingControllerVerifyVariant(postVerifyVariantInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongPublishingApi.songPublishingControllerVerifyVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongPublishingApi - factory interface
 * @export
 */
export const SongPublishingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongPublishingApiFp(configuration)
    return {
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerPublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.songPublishingControllerPublishVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostPublishVariantInDto} postPublishVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerUnpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.songPublishingControllerUnpublishVariant(postPublishVariantInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songPublishingControllerVerifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: any): AxiosPromise<SongVariant> {
            return localVarFp.songPublishingControllerVerifyVariant(postVerifyVariantInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongPublishingApi - object-oriented interface
 * @export
 * @class SongPublishingApi
 * @extends {BaseAPI}
 */
export class SongPublishingApi extends BaseAPI {
    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerPublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerPublishVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostPublishVariantInDto} postPublishVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerUnpublishVariant(postPublishVariantInDto: PostPublishVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerUnpublishVariant(postPublishVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostVerifyVariantInDto} postVerifyVariantInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongPublishingApi
     */
    public songPublishingControllerVerifyVariant(postVerifyVariantInDto: PostVerifyVariantInDto, options?: RawAxiosRequestConfig) {
        return SongPublishingApiFp(this.configuration).songPublishingControllerVerifyVariant(postVerifyVariantInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SongValidationApi - axios parameter creator
 * @export
 */
export const SongValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songValidationControllerValidateSheetDataAndTitle: async (postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postValidateSheetDataAndTitleInDto' is not null or undefined
            assertParamExists('songValidationControllerValidateSheetDataAndTitle', 'postValidateSheetDataAndTitleInDto', postValidateSheetDataAndTitleInDto)
            const localVarPath = `/song/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postValidateSheetDataAndTitleInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongValidationApi - functional programming interface
 * @export
 */
export const SongValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SongValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SongValidationApi.songValidationControllerValidateSheetDataAndTitle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SongValidationApi - factory interface
 * @export
 */
export const SongValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SongValidationApiFp(configuration)
    return {
        /**
         * 
         * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: any): AxiosPromise<ValidationResult> {
            return localVarFp.songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongValidationApi - object-oriented interface
 * @export
 * @class SongValidationApi
 * @extends {BaseAPI}
 */
export class SongValidationApi extends BaseAPI {
    /**
     * 
     * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongValidationApi
     */
    public songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto, options?: RawAxiosRequestConfig) {
        return SongValidationApiFp(this.configuration).songValidationControllerValidateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerRegisterWebhookExtension: async (registerWebhookExtensionBody: RegisterWebhookExtensionBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerWebhookExtensionBody' is not null or undefined
            assertParamExists('webhookControllerRegisterWebhookExtension', 'registerWebhookExtensionBody', registerWebhookExtensionBody)
            const localVarPath = `/webhook/registerWebhookExtension`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerWebhookExtensionBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhookGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody: RegisterWebhookExtensionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerRegisterWebhookExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerWebhookGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerWebhookGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerWebhookGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody: RegisterWebhookExtensionBody, options?: any): AxiosPromise<object> {
            return localVarFp.webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhook(options?: any): AxiosPromise<string> {
            return localVarFp.webhookControllerWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerWebhookGet(options?: any): AxiosPromise<object> {
            return localVarFp.webhookControllerWebhookGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {RegisterWebhookExtensionBody} registerWebhookExtensionBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody: RegisterWebhookExtensionBody, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerRegisterWebhookExtension(registerWebhookExtensionBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerWebhook(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerWebhookGet(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerWebhookGet(options).then((request) => request(this.axios, this.basePath));
    }
}



